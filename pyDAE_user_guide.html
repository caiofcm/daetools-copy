<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>6. User Guide &#8212; DAE Tools 1.9.0 documentation</title>
    
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootswatch-3.3.6/readable/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.9.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="_static/bootstrap-3.3.6/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="_static/[d][a][e].ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="7. API Reference" href="pyDAE_api_ref.html" />
    <link rel="prev" title="5. Getting Started with DAE Tools" href="getting_started.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body role="document">

  <div id="navbar" class="navbar navbar-inverse navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html"><span><img src="_static/[d][a][e]_Tools_project.png"></span>
          DAE Tools</a>
        <span class="navbar-text navbar-version pull-left"><b>1.9.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="/">Home</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="paradigms.html">2. Programming Paradigms</a></li>
<li class="toctree-l1"><a class="reference internal" href="architecture.html">3. Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_daetools.html">4. Getting DAE Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">5. Getting Started with DAE Tools</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">6. User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyDAE_api_ref.html">7. API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials.html">Tutorials</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">6. User Guide</a><ul>
<li><a class="reference internal" href="#importing-dae-tools-modules">6.1. Importing DAE Tools modules</a></li>
<li><a class="reference internal" href="#developing-models">6.2. Developing models</a><ul>
<li><a class="reference internal" href="#parameters">6.2.1. Parameters</a><ul>
<li><a class="reference internal" href="#declaring-parameters">6.2.1.1. Declaring parameters</a></li>
<li><a class="reference internal" href="#initialising-parameters">6.2.1.2. Initialising parameters</a></li>
<li><a class="reference internal" href="#using-parameters">6.2.1.3. Using parameters</a></li>
</ul>
</li>
<li><a class="reference internal" href="#variable-types">6.2.2. Variable types</a></li>
<li><a class="reference internal" href="#distribution-domains">6.2.3. Distribution domains</a><ul>
<li><a class="reference internal" href="#declaring-domains">6.2.3.1. Declaring domains</a></li>
<li><a class="reference internal" href="#initialising-domains">6.2.3.2. Initialising domains</a></li>
<li><a class="reference internal" href="#using-domains">6.2.3.3. Using domains</a></li>
</ul>
</li>
<li><a class="reference internal" href="#variables">6.2.4. Variables</a><ul>
<li><a class="reference internal" href="#declaring-variables">6.2.4.1. Declaring variables</a></li>
<li><a class="reference internal" href="#initialising-variables">6.2.4.2. Initialising variables</a></li>
<li><a class="reference internal" href="#using-variables">6.2.4.3. Using variables</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ports">6.2.5. Ports</a></li>
<li><a class="reference internal" href="#event-ports">6.2.6. Event ports</a></li>
<li><a class="reference internal" href="#equations">6.2.7. Equations</a><ul>
<li><a class="reference internal" href="#declaring-equations">6.2.7.1. Declaring equations</a></li>
<li><a class="reference internal" href="#defining-equations">6.2.7.2. Defining equations</a></li>
<li><a class="reference internal" href="#supported-mathematical-operations-and-functions">6.2.7.3. Supported mathematical operations and functions</a></li>
<li><a class="reference internal" href="#interoperability-with-numpy">6.2.7.4. Interoperability with NumPy</a></li>
<li><a class="reference internal" href="#details-on-autodifferentiation-support">6.2.7.5. Details on autodifferentiation support</a></li>
<li><a class="reference internal" href="#defining-boundary-conditions">6.2.7.6. Defining boundary conditions</a></li>
<li><a class="reference internal" href="#making-equations-more-readable">6.2.7.7. Making equations more readable</a></li>
</ul>
</li>
<li><a class="reference internal" href="#state-transition-networks">6.2.8. State Transition Networks</a></li>
<li><a class="reference internal" href="#oncondition-actions">6.2.9. OnCondition actions</a></li>
<li><a class="reference internal" href="#onevent-actions">6.2.10. OnEvent actions</a></li>
<li><a class="reference internal" href="#user-defined-actions">6.2.11. User-defined actions</a></li>
<li><a class="reference internal" href="#external-functions">6.2.12. External functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#numerical-methods-for-partial-differential-equations">6.3. Numerical Methods for Partial Differential Equations</a><ul>
<li><a class="reference internal" href="#the-finite-difference-method">6.3.1. The Finite Difference Method</a></li>
<li><a class="reference internal" href="#the-finite-volume-method">6.3.2. The Finite Volume Method</a></li>
<li><a class="reference internal" href="#the-finite-element-method">6.3.3. The Finite Element Method</a></li>
</ul>
</li>
<li><a class="reference internal" href="#configuration">6.4. Configuration</a></li>
<li><a class="reference internal" href="#units-and-quantities">6.5. Units and quantities</a></li>
<li><a class="reference internal" href="#logging">6.6. Logging</a></li>
<li><a class="reference internal" href="#dae-solvers">6.7. DAE Solvers</a></li>
<li><a class="reference internal" href="#linear-equation-solvers">6.8. Linear Equation Solvers</a></li>
<li><a class="reference internal" href="#data-reporting">6.9. Data Reporting</a><ul>
<li><a class="reference internal" href="#dae-plotter-application">6.9.1. DAE Plotter Application</a></li>
</ul>
</li>
<li><a class="reference internal" href="#executing-simulations">6.10. Executing simulations</a><ul>
<li><a class="reference internal" href="#initialising-domains-and-parameters">6.10.1. Initialising domains and parameters</a></li>
<li><a class="reference internal" href="#initialising-variables-initial-conditions-degrees-of-freedom">6.10.2. Initialising variables (initial conditions, degrees of freedom)</a></li>
<li><a class="reference internal" href="#developing-schedules-operating-procedures">6.10.3. Developing schedules (operating procedures)</a></li>
<li><a class="reference internal" href="#exploring-models-using-the-gui-simulation-explorer">6.10.4. Exploring models using the GUI (Simulation Explorer)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#parallel-computation">6.11. Parallel computation</a><ul>
<li><a class="reference internal" href="#evaluation-of-equations">6.11.1. Evaluation of equations</a></li>
<li><a class="reference internal" href="#assembly-of-finite-element-systems">6.11.2. Assembly of Finite Element systems</a></li>
<li><a class="reference internal" href="#solution-of-systems-of-linear-equations">6.11.3. Solution of systems of linear equations</a></li>
<li><a class="reference internal" href="#global-sensitivity-analysis">6.11.4. Global Sensitivity Analysis</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dae-tools-web-services">6.12. DAE Tools web services</a></li>
<li><a class="reference internal" href="#generating-code-for-other-modelling-languages">6.13. Generating code for other modelling languages</a></li>
<li><a class="reference internal" href="#simulating-models-in-other-simulators-co-simulation">6.14. Simulating models in other simulators (co-simulation)</a><ul>
<li><a class="reference internal" href="#functional-mock-up-interface-for-co-simulation-fmi">6.14.1. Functional Mock-up Interface for co-simulation (FMI)</a></li>
<li><a class="reference internal" href="#mex-functions">6.14.2. MEX functions</a></li>
<li><a class="reference internal" href="#simulink-s-functions">6.14.3. Simulink S-functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#performing-sensitivity-analysis">6.15. Performing sensitivity analysis</a><ul>
<li><a class="reference internal" href="#local-derivative-based-sa-methods">6.15.1. Local (derivative-based) SA methods</a></li>
<li><a class="reference internal" href="#global-sa-methods">6.15.2. Global SA methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#executing-optimisations">6.16. Executing optimisations</a><ul>
<li><a class="reference internal" href="#optimisation-setup">6.16.1. Optimisation setup</a><ul>
<li><a class="reference internal" href="#specifying-the-objective-function">6.16.1.1. Specifying the objective function</a></li>
<li><a class="reference internal" href="#specifying-optimisation-variables">6.16.1.2. Specifying optimisation variables</a></li>
<li><a class="reference internal" href="#specifying-optimisation-constraints">6.16.1.3. Specifying optimisation constraints</a></li>
</ul>
</li>
<li><a class="reference internal" href="#optimisation-solvers">6.16.2. Optimisation Solvers</a></li>
<li><a class="reference internal" href="#running-an-optimisation">6.16.3. Running an optimisation</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <div class="section" id="user-guide">
<h1>6. User Guide<a class="headerlink" href="#user-guide" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#importing-dae-tools-modules" id="id27">Importing DAE Tools modules</a></li>
<li><a class="reference internal" href="#developing-models" id="id28">Developing models</a><ul>
<li><a class="reference internal" href="#parameters" id="id29">Parameters</a><ul>
<li><a class="reference internal" href="#declaring-parameters" id="id30">Declaring parameters</a></li>
<li><a class="reference internal" href="#initialising-parameters" id="id31">Initialising parameters</a></li>
<li><a class="reference internal" href="#using-parameters" id="id32">Using parameters</a></li>
</ul>
</li>
<li><a class="reference internal" href="#variable-types" id="id33">Variable types</a></li>
<li><a class="reference internal" href="#distribution-domains" id="id34">Distribution domains</a><ul>
<li><a class="reference internal" href="#declaring-domains" id="id35">Declaring domains</a></li>
<li><a class="reference internal" href="#initialising-domains" id="id36">Initialising domains</a></li>
<li><a class="reference internal" href="#using-domains" id="id37">Using domains</a></li>
</ul>
</li>
<li><a class="reference internal" href="#variables" id="id38">Variables</a><ul>
<li><a class="reference internal" href="#declaring-variables" id="id39">Declaring variables</a></li>
<li><a class="reference internal" href="#initialising-variables" id="id40">Initialising variables</a></li>
<li><a class="reference internal" href="#using-variables" id="id41">Using variables</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ports" id="id42">Ports</a></li>
<li><a class="reference internal" href="#event-ports" id="id43">Event ports</a></li>
<li><a class="reference internal" href="#equations" id="id44">Equations</a><ul>
<li><a class="reference internal" href="#declaring-equations" id="id45">Declaring equations</a></li>
<li><a class="reference internal" href="#defining-equations" id="id46">Defining equations</a></li>
<li><a class="reference internal" href="#supported-mathematical-operations-and-functions" id="id47">Supported mathematical operations and functions</a></li>
<li><a class="reference internal" href="#interoperability-with-numpy" id="id48">Interoperability with NumPy</a></li>
<li><a class="reference internal" href="#details-on-autodifferentiation-support" id="id49">Details on autodifferentiation support</a></li>
<li><a class="reference internal" href="#defining-boundary-conditions" id="id50">Defining boundary conditions</a></li>
<li><a class="reference internal" href="#making-equations-more-readable" id="id51">Making equations more readable</a></li>
</ul>
</li>
<li><a class="reference internal" href="#state-transition-networks" id="id52">State Transition Networks</a></li>
<li><a class="reference internal" href="#oncondition-actions" id="id53">OnCondition actions</a></li>
<li><a class="reference internal" href="#onevent-actions" id="id54">OnEvent actions</a></li>
<li><a class="reference internal" href="#user-defined-actions" id="id55">User-defined actions</a></li>
<li><a class="reference internal" href="#external-functions" id="id56">External functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#numerical-methods-for-partial-differential-equations" id="id57">Numerical Methods for Partial Differential Equations</a><ul>
<li><a class="reference internal" href="#the-finite-difference-method" id="id58">The Finite Difference Method</a></li>
<li><a class="reference internal" href="#the-finite-volume-method" id="id59">The Finite Volume Method</a></li>
<li><a class="reference internal" href="#the-finite-element-method" id="id60">The Finite Element Method</a></li>
</ul>
</li>
<li><a class="reference internal" href="#configuration" id="id61">Configuration</a></li>
<li><a class="reference internal" href="#units-and-quantities" id="id62">Units and quantities</a></li>
<li><a class="reference internal" href="#logging" id="id63">Logging</a></li>
<li><a class="reference internal" href="#dae-solvers" id="id64">DAE Solvers</a></li>
<li><a class="reference internal" href="#linear-equation-solvers" id="id65">Linear Equation Solvers</a></li>
<li><a class="reference internal" href="#data-reporting" id="id66">Data Reporting</a><ul>
<li><a class="reference internal" href="#dae-plotter-application" id="id67">DAE Plotter Application</a></li>
</ul>
</li>
<li><a class="reference internal" href="#executing-simulations" id="id68">Executing simulations</a><ul>
<li><a class="reference internal" href="#initialising-domains-and-parameters" id="id69">Initialising domains and parameters</a></li>
<li><a class="reference internal" href="#initialising-variables-initial-conditions-degrees-of-freedom" id="id70">Initialising variables (initial conditions, degrees of freedom)</a></li>
<li><a class="reference internal" href="#developing-schedules-operating-procedures" id="id71">Developing schedules (operating procedures)</a></li>
<li><a class="reference internal" href="#exploring-models-using-the-gui-simulation-explorer" id="id72">Exploring models using the GUI (Simulation Explorer)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#parallel-computation" id="id73">Parallel computation</a><ul>
<li><a class="reference internal" href="#evaluation-of-equations" id="id74">Evaluation of equations</a></li>
<li><a class="reference internal" href="#assembly-of-finite-element-systems" id="id75">Assembly of Finite Element systems</a></li>
<li><a class="reference internal" href="#solution-of-systems-of-linear-equations" id="id76">Solution of systems of linear equations</a></li>
<li><a class="reference internal" href="#global-sensitivity-analysis" id="id77">Global Sensitivity Analysis</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dae-tools-web-services" id="id78">DAE Tools web services</a></li>
<li><a class="reference internal" href="#generating-code-for-other-modelling-languages" id="id79">Generating code for other modelling languages</a></li>
<li><a class="reference internal" href="#simulating-models-in-other-simulators-co-simulation" id="id80">Simulating models in other simulators (co-simulation)</a><ul>
<li><a class="reference internal" href="#functional-mock-up-interface-for-co-simulation-fmi" id="id81">Functional Mock-up Interface for co-simulation (FMI)</a></li>
<li><a class="reference internal" href="#mex-functions" id="id82">MEX functions</a></li>
<li><a class="reference internal" href="#simulink-s-functions" id="id83">Simulink S-functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#performing-sensitivity-analysis" id="id84">Performing sensitivity analysis</a><ul>
<li><a class="reference internal" href="#local-derivative-based-sa-methods" id="id85">Local (derivative-based) SA methods</a></li>
<li><a class="reference internal" href="#global-sa-methods" id="id86">Global SA methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#executing-optimisations" id="id87">Executing optimisations</a><ul>
<li><a class="reference internal" href="#optimisation-setup" id="id88">Optimisation setup</a><ul>
<li><a class="reference internal" href="#specifying-the-objective-function" id="id89">Specifying the objective function</a></li>
<li><a class="reference internal" href="#specifying-optimisation-variables" id="id90">Specifying optimisation variables</a></li>
<li><a class="reference internal" href="#specifying-optimisation-constraints" id="id91">Specifying optimisation constraints</a></li>
</ul>
</li>
<li><a class="reference internal" href="#optimisation-solvers" id="id92">Optimisation Solvers</a></li>
<li><a class="reference internal" href="#running-an-optimisation" id="id93">Running an optimisation</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="importing-dae-tools-modules">
<h2>6.1. Importing DAE Tools modules<a class="headerlink" href="#importing-dae-tools-modules" title="Permalink to this headline">¶</a></h2>
<p><strong>DAE Tools</strong> are loaded by importing <code class="xref py py-mod docutils literal"><span class="pre">daetools.pyDAE</span></code> Python module:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">daetools.pyDAE</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>This sets the python <cite>sys.path</cite> for importing the platform dependent extension modules
(i.e. <cite>.../daetools/pyDAE/Windows_win32_py34</cite> and <cite>.../daetools/solvers/Windows_win32_py34</cite> in Windows,
<cite>.../daetools/pyDAE/Linux_x86_64_py34</cite> and <cite>.../daetools/solvers/Linux_x86_64_py34</cite> in GNU/Linux),
import all symbols from all <code class="xref py py-mod docutils literal"><span class="pre">pyDAE</span></code> modules: <a class="reference internal" href="core.html#module-pyCore" title="pyCore"><code class="xref py py-mod docutils literal"><span class="pre">pyCore</span></code></a>,
<a class="reference internal" href="activity.html#module-pyActivity" title="pyActivity"><code class="xref py py-mod docutils literal"><span class="pre">pyActivity</span></code></a>, <a class="reference internal" href="data_reporting.html#module-pyDataReporting" title="pyDataReporting"><code class="xref py py-mod docutils literal"><span class="pre">pyDataReporting</span></code></a>, <a class="reference internal" href="dae_solver.html#module-pyIDAS" title="pyIDAS"><code class="xref py py-mod docutils literal"><span class="pre">pyIDAS</span></code></a>,
<a class="reference internal" href="units.html#module-pyUnits" title="pyUnits"><code class="xref py py-mod docutils literal"><span class="pre">pyUnits</span></code></a> and import some platform independent modules: <a class="reference internal" href="log.html#module-daetools.pyDAE.logs" title="daetools.pyDAE.logs"><code class="xref py py-mod docutils literal"><span class="pre">logs</span></code></a>,
<a class="reference internal" href="variable_types.html#module-daetools.pyDAE.variable_types" title="daetools.pyDAE.variable_types"><code class="xref py py-mod docutils literal"><span class="pre">variable_types</span></code></a>, <a class="reference internal" href="hr_upwind_scheme.html#module-daetools.pyDAE.hr_upwind_scheme" title="daetools.pyDAE.hr_upwind_scheme"><code class="xref py py-mod docutils literal"><span class="pre">hr_upwind_scheme</span></code></a>,
<a class="reference internal" href="dae_simulator.html#module-daetools.dae_simulator.simulator" title="daetools.dae_simulator.simulator"><code class="xref py py-mod docutils literal"><span class="pre">simulator</span></code></a>, <a class="reference internal" href="dae_simulator.html#module-daetools.dae_simulator.simulation_explorer" title="daetools.dae_simulator.simulation_explorer"><code class="xref py py-mod docutils literal"><span class="pre">simulation_explorer</span></code></a>,
<a class="reference internal" href="dae_simulator.html#module-daetools.dae_simulator.simulation_inspector" title="daetools.dae_simulator.simulation_inspector"><code class="xref py py-mod docutils literal"><span class="pre">simulation_inspector</span></code></a>, <a class="reference internal" href="thermo_packages.html#module-daetools.pyDAE.thermo_packages" title="daetools.pyDAE.thermo_packages"><code class="xref py py-mod docutils literal"><span class="pre">thermo_packages</span></code></a>.</p>
<p>Alternatively, the <code class="xref py py-mod docutils literal"><span class="pre">daetools.pyDAE</span></code> module can be imported and classes from the
<code class="xref py py-mod docutils literal"><span class="pre">pyDAE</span></code> extension modules accessed using the fully qualified names.
For instance:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">daetools.pyDAE</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">daetools</span><span class="o">.</span><span class="n">pyDAE</span><span class="o">.</span><span class="n">pyCore</span><span class="o">.</span><span class="n">daeModel</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Once the <code class="xref py py-mod docutils literal"><span class="pre">daetools.pyDAE</span></code> module is loaded, the other modules (such as third party linear solvers,
optimisation solvers etc.) can be imported.
Since domains, parameters and variables in <strong>DAE Tools</strong> have a numerical value in terms
of a unit of measurement (<a class="reference internal" href="units.html#pyUnits.quantity" title="pyUnits.quantity"><code class="xref py py-class docutils literal"><span class="pre">quantity</span></code></a>) the modules containing definitions of
units and variable types must be imported:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">daetools.pyDAE.variable_types</span> <span class="kn">import</span> <span class="n">length_t</span><span class="p">,</span> <span class="n">area_t</span><span class="p">,</span> <span class="n">volume_t</span>
<span class="kn">from</span> <span class="nn">daetools.pyDAE.pyUnits</span> <span class="kn">import</span> <span class="n">m</span><span class="p">,</span> <span class="n">kg</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">Pa</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">W</span>
</pre></div>
</div>
<p>The complete list of units and variable types can be found in
<a class="reference internal" href="variable_types.html#module-daetools.pyDAE.variable_types" title="daetools.pyDAE.variable_types"><code class="xref py py-mod docutils literal"><span class="pre">variable_types</span></code></a> and <a class="reference internal" href="units.html#module-pyUnits" title="pyUnits"><code class="xref py py-mod docutils literal"><span class="pre">pyUnits</span></code></a> modules.</p>
</div>
<div class="section" id="developing-models">
<h2>6.2. Developing models<a class="headerlink" href="#developing-models" title="Permalink to this headline">¶</a></h2>
<p><strong>DAE Tools</strong> models are developed by deriving a class from the base <a class="reference internal" href="core.html#pyCore.daeModel" title="pyCore.daeModel"><code class="xref py py-class docutils literal"><span class="pre">daeModel</span></code></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">myModel</span><span class="p">(</span><span class="n">daeModel</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="n">daeModel</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">description</span><span class="p">)</span>

        <span class="c1"># Declaration/instantiation of domains, parameters, variables, ports, etc:</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">DeclareEquations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Declaration of equations, state transition networks etc.:</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>Every model definition requires specification of the model structure and its functionality in two phases:</p>
<ol class="arabic">
<li><p class="first">Declaring the model structure (domains, parameters, variables, ports, components etc.) in the
<a class="reference internal" href="core.html#pyCore.daeModel.__init__" title="pyCore.daeModel.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> function:</p>
<p>In <strong>DAE Tools</strong> the model specification is separated from the activities that can be performed on the model.
This way, based on a single model definition different simulation scenarios can be developed.
Thus, all objects are specified in two stages:</p>
<ul class="simple">
<li>Declaration in the <a class="reference internal" href="core.html#pyCore.daeModel.__init__" title="pyCore.daeModel.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> function</li>
<li>Initialisation of domains and parameters in <a class="reference internal" href="activity.html#pyActivity.daeSimulation.SetUpParametersAndDomains" title="pyActivity.daeSimulation.SetUpParametersAndDomains"><code class="xref py py-meth docutils literal"><span class="pre">SetUpParametersAndDomains()</span></code></a> and
variables in <a class="reference internal" href="activity.html#pyActivity.daeSimulation.SetUpVariables" title="pyActivity.daeSimulation.SetUpVariables"><code class="xref py py-meth docutils literal"><span class="pre">SetUpVariables()</span></code></a> function.</li>
</ul>
<p>Therefore, parameters, domains and variables are only declared here, while their initialisation
(i.e. setting parameter values or initial conditions) is postponed and performed in the simulation class.</p>
<p>All objects must be stored in the model since the base <a class="reference internal" href="core.html#pyCore.daeModel" title="pyCore.daeModel"><code class="xref py py-class docutils literal"><span class="pre">daeModel</span></code></a>
class keeps only week references to them:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">domain</span>    <span class="o">=</span> <span class="n">daeDomain</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">parameter</span> <span class="o">=</span> <span class="n">daeParameter</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">variable</span>  <span class="o">=</span> <span class="n">daeVariable</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="o">...</span> <span class="n">etc</span><span class="o">.</span>
</pre></div>
</div>
<p>and not:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
    <span class="n">domain</span>    <span class="o">=</span> <span class="n">daeDomain</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">parameter</span> <span class="o">=</span> <span class="n">daeParameter</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">variable</span>  <span class="o">=</span> <span class="n">daeVariable</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="o">...</span> <span class="n">etc</span><span class="o">.</span>
</pre></div>
</div>
<p>because at the exit from the <a class="reference internal" href="core.html#pyCore.daeModel.__init__" title="pyCore.daeModel.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> function the objects
will go out of scope and get destroyed. However, the underlying c++ model still holds
pointers which eventually results in the segmentation fault.</p>
</li>
<li><p class="first">Specification of the model functionality (equations, state transition networks,
and <cite>OnEvent</cite> and <cite>OnCondition</cite> actions)
in the <a class="reference internal" href="core.html#pyCore.daeModel.DeclareEquations" title="pyCore.daeModel.DeclareEquations"><code class="xref py py-meth docutils literal"><span class="pre">DeclareEquations()</span></code></a> function.</p>
<p><strong>Nota bene</strong>: This function is never called directly by the user and will be called automatically
by the framework.</p>
<p>Initialisation of the simulation object is carried out in several phases.
At the point when this function is called by the framework,
the model parameters, domains, variables etc. are fully initialised.
Therefore, it is safe to obtain the values of parameters or domain points and use them to
create equations at the run-time.</p>
<p><strong>Nota bene</strong>: However, the <strong>variable values</strong> are obviously <strong>not available</strong> at this moment
(they get initialised at the later stage) and using the variable values during the model specification
phase is not allowed.</p>
</li>
</ol>
<p>A simplest <strong>DAE Tools</strong> model with a description of all steps/tasks necessary to develop a model
can be found in the <a class="reference internal" href="tutorials-all.html#whats-the-time"><span class="std std-ref">What&#8217;s the time? (AKA: Hello world!)</span></a> tutorial (<a class="reference external" href="examples/whats_the_time.html">whats_the_time.py</a>).</p>
<div class="section" id="parameters">
<h3>6.2.1. Parameters<a class="headerlink" href="#parameters" title="Permalink to this headline">¶</a></h3>
<p>Parameters are time invariant quantities that do not change during
a simulation. Usually a good choice what should be a parameter is a
physical constant, number of discretisation points in a domain etc.</p>
<p>Again, parameters are defined in two phases:</p>
<ul class="simple">
<li>Declaration in the <a class="reference internal" href="core.html#pyCore.daeModel.__init__" title="pyCore.daeModel.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> function</li>
<li>Initialisation (by setting its value) in the <a class="reference internal" href="activity.html#pyActivity.daeSimulation.SetUpParametersAndDomains" title="pyActivity.daeSimulation.SetUpParametersAndDomains"><code class="xref py py-meth docutils literal"><span class="pre">SetUpParametersAndDomains()</span></code></a> function</li>
</ul>
<div class="section" id="declaring-parameters">
<h4>6.2.1.1. Declaring parameters<a class="headerlink" href="#declaring-parameters" title="Permalink to this headline">¶</a></h4>
<p>Parameters are declared in the <a class="reference internal" href="core.html#pyCore.daeModel.__init__" title="pyCore.daeModel.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">myParam</span> <span class="o">=</span> <span class="n">daeParameter</span><span class="p">(</span><span class="s2">&quot;myParam&quot;</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="n">parentModel</span><span class="p">,</span> <span class="s2">&quot;description&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Parameters can also be distributed on domains:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">myParam</span> <span class="o">=</span> <span class="n">daeParameter</span><span class="p">(</span><span class="s2">&quot;myParam&quot;</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="n">parentModel</span><span class="p">,</span> <span class="s2">&quot;description&quot;</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">myParam</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="n">myDomain</span><span class="p">)</span>

<span class="c1"># Or simply:</span>
<span class="bp">self</span><span class="o">.</span><span class="n">myParam</span> <span class="o">=</span> <span class="n">daeParameter</span><span class="p">(</span><span class="s2">&quot;myParam&quot;</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="n">parentModel</span><span class="p">,</span> <span class="s2">&quot;description&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">myDomain</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="initialising-parameters">
<h4>6.2.1.2. Initialising parameters<a class="headerlink" href="#initialising-parameters" title="Permalink to this headline">¶</a></h4>
<p>Parameters are initialised in the <a class="reference internal" href="activity.html#pyActivity.daeSimulation.SetUpParametersAndDomains" title="pyActivity.daeSimulation.SetUpParametersAndDomains"><code class="xref py py-meth docutils literal"><span class="pre">SetUpParametersAndDomains()</span></code></a> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Ordinary parameters:</span>
<span class="n">myParam</span><span class="o">.</span><span class="n">SetValue</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<span class="c1"># Distributed parameters (one-dimensional):</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">myDomain</span><span class="o">.</span><span class="n">NumberOfPoints</span><span class="p">):</span>
    <span class="n">myParam</span><span class="o">.</span><span class="n">SetValue</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>where <cite>value</cite> can be either a floating point number or the <a class="reference internal" href="units.html#pyUnits.quantity" title="pyUnits.quantity"><code class="xref py py-class docutils literal"><span class="pre">quantity</span></code></a> object (i.e. 1.34 * W/(m*K)).
If the simple floats are used it is assumed that they represent values with the same units as in the parameter definition.</p>
<div class="topic">
<p class="topic-title first">Nota bene</p>
<p><cite>DAE Tools</cite> (as it is the case in C/C++ and Python) use <cite>zero-based arrays</cite>
in which the <cite>initial element of a sequence is assigned the index 0</cite>, rather than 1.</p>
</div>
<p>In addition, all values in a distributed parameter can be set in a single call:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">myParam</span><span class="o">.</span><span class="n">SetValues</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
</pre></div>
</div>
<p>where <cite>values</cite> is a numpy array of floats/quantity objects.</p>
</div>
<div class="section" id="using-parameters">
<h4>6.2.1.3. Using parameters<a class="headerlink" href="#using-parameters" title="Permalink to this headline">¶</a></h4>
<p>Model equations consist of mathematical operations and functions that operate on <a class="reference internal" href="core.html#pyCore.adouble" title="pyCore.adouble"><code class="xref py py-class docutils literal"><span class="pre">adouble</span></code></a> and
<a class="reference internal" href="core.html#pyCore.adouble_array" title="pyCore.adouble_array"><code class="xref py py-class docutils literal"><span class="pre">adouble_array</span></code></a> objects.
They contain information about the functions and operands in the <a class="reference internal" href="core.html#pyCore.adouble.Node" title="pyCore.adouble.Node"><code class="xref py py-attr docutils literal"><span class="pre">Node</span></code></a> attribute.
<a class="reference internal" href="core.html#pyCore.adouble" title="pyCore.adouble"><code class="xref py py-class docutils literal"><span class="pre">adouble</span></code></a> objects contain the values of parameters and variables while
<a class="reference internal" href="core.html#pyCore.adouble_array" title="pyCore.adouble_array"><code class="xref py py-class docutils literal"><span class="pre">adouble_array</span></code></a> objects contain arrays of values.</p>
<ol class="arabic">
<li><p class="first">A parameter value can be obtained using the <a class="reference internal" href="core.html#pyCore.daeParameter.__call__" title="pyCore.daeParameter.__call__"><code class="xref py py-meth docutils literal"><span class="pre">__call__()</span></code></a> function (<cite>operator ()</cite>)
which returns the <a class="reference internal" href="core.html#pyCore.adouble" title="pyCore.adouble"><code class="xref py py-class docutils literal"><span class="pre">adouble</span></code></a> object.
For instance, the equation:</p>
<div class="math">
\[myVar = myParam + 15\]</div>
<p>is specified in the following (acausal) way:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Notation:</span>
<span class="c1">#  - eq is a daeEquation object created using the model.CreateEquation(...) function</span>
<span class="c1">#  - myParam is an ordinary daeParameter object (not distributed)</span>
<span class="c1">#  - myVar is an ordinary daeVariable (not distributed)</span>

<span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">myVar</span><span class="p">()</span> <span class="o">-</span> <span class="p">(</span><span class="n">myParam</span><span class="p">()</span> <span class="o">+</span> <span class="mi">15</span><span class="p">)</span>
</pre></div>
</div>
<p>The same function is used for distributed parameters.
For instance, the equation:</p>
<div class="math">
\[myVar(i) = myParam(i) + 15; \forall i \in [0, n_d - 1]\]</div>
<p>is given as:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Notation:</span>
<span class="c1">#  - myDomain is daeDomain object</span>
<span class="c1">#  - eq is a daeEquation object distributed on myDomain</span>
<span class="c1">#  - i is daeDistributedEquationDomainInfo object (used to iterate through the domain points)</span>
<span class="c1">#  - myParam is daeParameter object distributed on myDomain</span>
<span class="c1">#  - myVar is daeVariable object distributed on myDomain</span>
<span class="n">i</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="n">myDomain</span><span class="p">,</span> <span class="n">eClosedClosed</span><span class="p">)</span>
<span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">myVar</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">myParam</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">15</span><span class="p">)</span>
</pre></div>
</div>
<p>This code translates into a set of <cite>n</cite> algebraic equations.</p>
<p>Obviously, a parameter can be distributed on more than one domain.
The equation:</p>
<div class="math">
\[myVar(d_1,d_2) = myParam(d_1,d_2) + 15; \forall d_1 \in [0, n_{d1} - 1], \forall d_2 \in [0, n_{d2} - 1]\]</div>
<p>is specified as:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Notation:</span>
<span class="c1">#  - myDomain1, myDomain2 are daeDomain objects</span>
<span class="c1">#  - eq is a daeEquation object distributed on the domains myDomain1 and myDomain2</span>
<span class="c1">#  - i1, i2 are daeDistributedEquationDomainInfo objects (used to iterate through the domain points)</span>
<span class="c1">#  - myParam is daeParameter object distributed on myDomain1 and myDomain2</span>
<span class="c1">#  - myVar is daeVariable object distributed on myDomain1 and myDomain2</span>
<span class="n">i1</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="n">myDomain1</span><span class="p">,</span> <span class="n">eClosedClosed</span><span class="p">)</span>
<span class="n">i2</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="n">myDomain2</span><span class="p">,</span> <span class="n">eClosedClosed</span><span class="p">)</span>
<span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">myVar</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span><span class="n">i2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">myParam</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span><span class="n">i2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">15</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">An array of parameter values can be obtained using the function <a class="reference internal" href="core.html#pyCore.daeParameter.array" title="pyCore.daeParameter.array"><code class="xref py py-meth docutils literal"><span class="pre">array()</span></code></a>
which returns the <a class="reference internal" href="core.html#pyCore.adouble_array" title="pyCore.adouble_array"><code class="xref py py-class docutils literal"><span class="pre">adouble_array</span></code></a> object.
The function accepts the following type of arguments:</p>
<ul class="simple">
<li>integers (to select a single index from a domain); a special case is index <cite>-1</cite> that returns the last point in the domain)</li>
<li>python list (to select a list of indexes from a domain)</li>
<li>python slice (to select a portion of indexes from a domain: startIndex, endIindex, step)</li>
<li>character &#8216;*&#8217; or an empty python list <cite>[]</cite> (to select all points from a domain)</li>
</ul>
<p>For example, the equation:</p>
<div class="math">
\[myVar = \sum myParam(0, *)\]</div>
<p>can be written in two ways:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Notation:</span>
<span class="c1">#  - myDomain1, myDomain2 are daeDomain objects</span>
<span class="c1">#  - n1, n2 are the number of points in myDomain1 and myDomain2 domains</span>
<span class="c1">#  - eq is daeEquation objects</span>
<span class="c1">#  - mySum is daeVariable object</span>
<span class="c1">#  - myParam is daeParameter object distributed on myDomain1 and myDomain2 domains</span>
<span class="c1">#  - values is the adouble_array object</span>

<span class="c1"># An array contains myParam values for:</span>
<span class="c1">#  - the first point in the domain myDomain1</span>
<span class="c1">#  - all points from the domain myDomain2</span>
<span class="c1"># The expressions below are equivalent:</span>
<span class="n">values</span> <span class="o">=</span> <span class="n">myParam</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">)</span>
<span class="n">values</span> <span class="o">=</span> <span class="n">myParam</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">[])</span>

<span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">mySum</span><span class="p">()</span> <span class="o">-</span> <span class="n">Sum</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
</pre></div>
</div>
<p>The code translates into:</p>
<div class="math">
\[mySum = myParam(0,0) + myParam(0,1) + ... + myParam(0,n_2 - 1)\]</div>
<p>where <cite>n2</cite> is the number of points in the domain <cite>myDomain2</cite>.</p>
<p>In addition, the function supports advanced indexing. For instance, the equation:</p>
<div class="math">
\[myVar = \sum myParam([0,1,2], [even\_points\_in\_myDomain2])\]</div>
<p>is defined as:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># An array contains the following values from myParam:</span>
<span class="c1">#  - the first three points in the domain myDomain1</span>
<span class="c1">#  - all even points from the domain myDomain2</span>
<span class="n">values</span> <span class="o">=</span> <span class="n">myParam</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">myDomain2</span><span class="o">.</span><span class="n">NumberOfPoints</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

<span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">mySum</span><span class="p">()</span> <span class="o">-</span> <span class="n">Sum</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
</pre></div>
</div>
<p>The code translates into:</p>
<div class="math">
\[\begin{split}mySum = &amp; myParam(0,0) + myParam(0,2) + myParam(0,4) + ... + myParam(0, n_2 - 1) + \\
        &amp; myParam(1,0) + myParam(1,2) + myParam(1,4) + ... + myParam(1, n_2 - 1) + \\
        &amp; myParam(2,0) + myParam(2,2) + myParam(2,4) + ... + myParam(2, n_2 - 1)\end{split}\]</div>
</li>
</ol>
<p>The property <a class="reference internal" href="core.html#pyCore.daeParameter.npyValues" title="pyCore.daeParameter.npyValues"><code class="xref py py-attr docutils literal"><span class="pre">npyValues</span></code></a> contains the parameter values as a numpy multi-dimensional array
(with &#8216;numpy.float&#8217; data type).</p>
<div class="topic">
<p class="topic-title first">Notate bene</p>
<p>The functions <a class="reference internal" href="core.html#pyCore.daeParameter.__call__" title="pyCore.daeParameter.__call__"><code class="xref py py-meth docutils literal"><span class="pre">__call__()</span></code></a> and <a class="reference internal" href="core.html#pyCore.daeParameter.array" title="pyCore.daeParameter.array"><code class="xref py py-meth docutils literal"><span class="pre">array()</span></code></a>
return <a class="reference internal" href="core.html#pyCore.adouble" title="pyCore.adouble"><code class="xref py py-class docutils literal"><span class="pre">adouble</span></code></a> and <a class="reference internal" href="core.html#pyCore.adouble_array" title="pyCore.adouble_array"><code class="xref py py-class docutils literal"><span class="pre">adouble_array</span></code></a> objects, respectively
and does not contain values. They are only used to specify equations&#8217; residual expressions
which are stored in their <a class="reference internal" href="core.html#pyCore.adouble.Node" title="pyCore.adouble.Node"><code class="xref py py-attr docutils literal"><span class="pre">pyCore.adouble.Node</span></code></a> / <a class="reference internal" href="core.html#pyCore.adouble_array.Node" title="pyCore.adouble_array.Node"><code class="xref py py-attr docutils literal"><span class="pre">pyCore.adouble_array.Node</span></code></a> properties.</p>
<p>Other functions (such as <a class="reference internal" href="core.html#pyCore.daeParameter.npyValues" title="pyCore.daeParameter.npyValues"><code class="xref py py-attr docutils literal"><span class="pre">npyValues</span></code></a> and <a class="reference internal" href="core.html#pyCore.daeParameter.GetValue" title="pyCore.daeParameter.GetValue"><code class="xref py py-meth docutils literal"><span class="pre">GetValue()</span></code></a>)
can be used to access the values data during the simulation.</p>
<p>All above stands for similar functions in <a class="reference internal" href="core.html#pyCore.daeDomain" title="pyCore.daeDomain"><code class="xref py py-class docutils literal"><span class="pre">daeDomain</span></code></a> and <a class="reference internal" href="core.html#pyCore.daeVariable" title="pyCore.daeVariable"><code class="xref py py-class docutils literal"><span class="pre">daeVariable</span></code></a> classes.</p>
</div>
<p>More information about parameters can be found in the API reference <a class="reference internal" href="core.html#pyCore.daeParameter" title="pyCore.daeParameter"><code class="xref py py-class docutils literal"><span class="pre">daeParameter</span></code></a>
and in <a class="reference internal" href="tutorials.html"><span class="doc">Tutorials</span></a>.</p>
</div>
</div>
<div class="section" id="variable-types">
<h3>6.2.2. Variable types<a class="headerlink" href="#variable-types" title="Permalink to this headline">¶</a></h3>
<p>Variable types describe variables and contain the information such as:</p>
<ul class="simple">
<li>Name: string</li>
<li>Units: <a class="reference internal" href="units.html#pyUnits.unit" title="pyUnits.unit"><code class="xref py py-class docutils literal"><span class="pre">unit</span></code></a> object</li>
<li>LowerBound: float</li>
<li>UpperBound: float</li>
<li>InitialGuess: float</li>
<li>AbsoluteTolerance: float</li>
<li>ValueConstraint: enumeration <code class="xref py py-class docutils literal"><span class="pre">daeeVariableValueConstraint</span></code></li>
</ul>
<p>Declaration of variable types is commonly done outside of the model definition (in the module scope):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Temperature type with units Kelvin, limits 100-1000K, the default value 273K and the absolute tolerance 1E-5</span>
<span class="n">typeTemperature</span> <span class="o">=</span> <span class="n">daeVariableType</span><span class="p">(</span><span class="s2">&quot;Temperature&quot;</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">273</span><span class="p">,</span> <span class="mf">1E-5</span><span class="p">,</span> <span class="n">constraint</span><span class="p">)</span>
</pre></div>
</div>
<p>where the argument <cite>constraint</cite> specifies the value constraint and can be one of:</p>
<ul class="simple">
<li>eNoConstraint (default)</li>
<li>eValueGTEQ: imposes &gt;= 0 constraint</li>
<li>eValueLTEQ: imposes &lt;= 0 constraint</li>
<li>eValueGT:   imposes &gt; 0 constraint</li>
<li>eValueLT:   imposes &lt; 0 constraint</li>
</ul>
</div>
<div class="section" id="distribution-domains">
<h3>6.2.3. Distribution domains<a class="headerlink" href="#distribution-domains" title="Permalink to this headline">¶</a></h3>
<p>Domains in <strong>DAE Tools</strong> are used to to create simple arrays of variables, parameters, equations and ports
and their distributions in space.
They can define uniform (the default) or non-uniform grids (user-specified) and are defined in two phases:</p>
<ul class="simple">
<li>Declaring a domain in the model</li>
<li>Initialising it in the simulation</li>
</ul>
<div class="section" id="declaring-domains">
<h4>6.2.3.1. Declaring domains<a class="headerlink" href="#declaring-domains" title="Permalink to this headline">¶</a></h4>
<p>Domains are declared in the <a class="reference internal" href="core.html#pyCore.daeModel.__init__" title="pyCore.daeModel.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">myDomain</span> <span class="o">=</span> <span class="n">daeDomain</span><span class="p">(</span><span class="s2">&quot;myDomain&quot;</span><span class="p">,</span> <span class="n">parentModel</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="s2">&quot;description&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="initialising-domains">
<h4>6.2.3.2. Initialising domains<a class="headerlink" href="#initialising-domains" title="Permalink to this headline">¶</a></h4>
<p>Domains are initialised in the <a class="reference internal" href="activity.html#pyActivity.daeSimulation.SetUpParametersAndDomains" title="pyActivity.daeSimulation.SetUpParametersAndDomains"><code class="xref py py-meth docutils literal"><span class="pre">SetUpParametersAndDomains()</span></code></a> function.
Simple arrays are defined using the function <a class="reference internal" href="core.html#pyCore.daeDomain.CreateArray" title="pyCore.daeDomain.CreateArray"><code class="xref py py-meth docutils literal"><span class="pre">CreateArray()</span></code></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Array of N elements</span>
<span class="n">myDomain</span><span class="o">.</span><span class="n">CreateArray</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
</pre></div>
</div>
<p>while the domains distributed on a structured grid using the function
<a class="reference internal" href="core.html#pyCore.daeDomain.CreateStructuredGrid" title="pyCore.daeDomain.CreateStructuredGrid"><code class="xref py py-meth docutils literal"><span class="pre">CreateStructuredGrid()</span></code></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Uniform structured grid with N elements and bounds [lowerBound, upperBound]</span>
<span class="n">myDomain</span><span class="o">.</span><span class="n">CreateStructuredGrid</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">lowerBound</span><span class="p">,</span> <span class="n">upperBound</span><span class="p">)</span>
</pre></div>
</div>
<p>where the lower and upper bounds are the floating point values or quantity objects.
If the floats are used it is assumed that they contain values with the same units as in the domain definition.
Using the quantities is advised (to avoid problems when the domain units change).</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Uniform structured grid with 10 elements and bounds [0,1] in centimeters:</span>
<span class="n">myDomain</span><span class="o">.</span><span class="n">CreateStructuredGrid</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mf">0.0</span> <span class="o">*</span> <span class="n">cm</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">cm</span><span class="p">)</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title first">Nota bene</p>
<p>Structured grids with <cite>N</cite> elements contain <cite>N+1</cite> points.</p>
</div>
<p>It is also possible to create an unstructured grid (for use in Finite Element models).
However, their structure is an implementation detail (i.e. as in deal.II).</p>
<p>In certain situations it is desired to have a non-uniform distribution
of the points within the given interval, defined by the lower and upper bounds.
In these cases, a non-uniform structured grid can be specified using the attribute
<a class="reference internal" href="core.html#pyCore.daeDomain.Points" title="pyCore.daeDomain.Points"><code class="xref py py-attr docutils literal"><span class="pre">Points</span></code></a> which contains the list of the points and that
can be manipulated by the user:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># First create a structured grid domain</span>
<span class="n">myDomain</span><span class="o">.</span><span class="n">CreateStructuredGrid</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

<span class="c1"># The original 11 points are: [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]</span>
<span class="c1"># If the system is stiff at the beginning of the domain more points can be placed there</span>
<span class="n">myDomain</span><span class="o">.</span><span class="n">Points</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.10</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.20</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.30</span><span class="p">,</span> <span class="mf">0.35</span><span class="p">,</span> <span class="mf">0.40</span><span class="p">,</span> <span class="mf">0.60</span><span class="p">,</span> <span class="mf">1.00</span><span class="p">]</span>
</pre></div>
</div>
<p>The effect of uniform and non-uniform grids is given
in <a class="reference internal" href="#figure-non-uniform-grid"><span class="std std-numref">Fig. 6.1</span></a> (a simple heat conduction problem from the <a class="reference internal" href="tutorials-all.html#tutorial3"><span class="std std-ref">Tutorial 3</span></a>
has been served as a basis for comparison). Here, there are three cases:</p>
<ul class="simple">
<li>Black line: the analytic solution</li>
<li>Blue line (10 intervals): uniform grid - a very rough prediction</li>
<li>Red line (10 intervals): non-uniform grid - more points at the beginning of the domain</li>
</ul>
<div class="figure align-center" id="id15" style="width: 450pt">
<span id="figure-non-uniform-grid"></span><a class="reference internal image-reference" href="_images/NonUniformGrid.png"><img alt="_images/NonUniformGrid.png" src="_images/NonUniformGrid.png" style="width: 400pt;" /></a>
<p class="caption"><span class="caption-number">Fig. 6.1 </span><span class="caption-text">Effect of uniform and non-uniform grids on numerical solution (zoomed to the first 5 points)</span></p>
</div>
<p>More precise results are obtained by using denser grid at the beginning of the interval.</p>
</div>
<div class="section" id="using-domains">
<h4>6.2.3.3. Using domains<a class="headerlink" href="#using-domains" title="Permalink to this headline">¶</a></h4>
<p>The functions <a class="reference internal" href="core.html#pyCore.daeDomain.__call__" title="pyCore.daeDomain.__call__"><code class="xref py py-meth docutils literal"><span class="pre">__call__()</span></code></a> (<cite>operator ()</cite>) and <a class="reference internal" href="core.html#pyCore.daeDomain.__getitem__" title="pyCore.daeDomain.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a> (<cite>operator []</cite>)
are used to return the <a class="reference internal" href="core.html#pyCore.adouble" title="pyCore.adouble"><code class="xref py py-class docutils literal"><span class="pre">adouble</span></code></a> object with the value of the point
at the specified index within the domain. Both functions have the same functionality.
For instance, the equation:</p>
<div class="math">
\[myVar = myDomain[5]\]</div>
<p>is specified in the following way:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Notation:</span>
<span class="c1">#  - eq is a daeEquation object</span>
<span class="c1">#  - myDomain is daeDomain object</span>
<span class="c1">#  - myVar is daeVariable object</span>
<span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">myVar</span><span class="p">()</span> <span class="o">-</span> <span class="n">myDomain</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</div>
<p>The function <a class="reference internal" href="core.html#pyCore.daeDomain.array" title="pyCore.daeDomain.array"><code class="xref py py-meth docutils literal"><span class="pre">array()</span></code></a> returns the <a class="reference internal" href="core.html#pyCore.adouble_array" title="pyCore.adouble_array"><code class="xref py py-class docutils literal"><span class="pre">adouble_array</span></code></a>
object with an array of points. It accepts the same type of arguments as explained in the section <a class="reference internal" href="#using-parameters">Using parameters</a>.</p>
<p>The property <a class="reference internal" href="core.html#pyCore.daeDomain.Points" title="pyCore.daeDomain.Points"><code class="xref py py-attr docutils literal"><span class="pre">Points</span></code></a> contains a list of the points in the domain.</p>
<div class="topic">
<p class="topic-title first">Nota bene</p>
<p>The functions <a class="reference internal" href="core.html#pyCore.daeDomain.__call__" title="pyCore.daeDomain.__call__"><code class="xref py py-meth docutils literal"><span class="pre">__call__()</span></code></a>, <a class="reference internal" href="core.html#pyCore.daeDomain.__getitem__" title="pyCore.daeDomain.__getitem__"><code class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></code></a>
and <a class="reference internal" href="core.html#pyCore.daeDomain.array" title="pyCore.daeDomain.array"><code class="xref py py-meth docutils literal"><span class="pre">array()</span></code></a> can only be used to build equations&#8217; residual expressions.
On the other hand, the attribute <a class="reference internal" href="core.html#pyCore.daeDomain.Points" title="pyCore.daeDomain.Points"><code class="xref py py-attr docutils literal"><span class="pre">Points</span></code></a> can be used at any point.</p>
</div>
<p>More information about domains can be found in the API reference <a class="reference internal" href="core.html#pyCore.daeDomain" title="pyCore.daeDomain"><code class="xref py py-class docutils literal"><span class="pre">daeDomain</span></code></a> and in <a class="reference internal" href="tutorials.html"><span class="doc">Tutorials</span></a>.</p>
</div>
</div>
<div class="section" id="variables">
<h3>6.2.4. Variables<a class="headerlink" href="#variables" title="Permalink to this headline">¶</a></h3>
<p>Variables define time varying quantities that change during a simulation
and can be:</p>
<ul class="simple">
<li>Algebraic</li>
<li>Differential</li>
<li>Assigned (that is their value is assigned by fixing the number of degrees of freedom - DOF)</li>
</ul>
<p>They are defined in two phases:</p>
<ul class="simple">
<li>Declaring a variable in the model</li>
<li>Initialising it, if required (by assigning its value or setting an initial condition) in the simulation</li>
</ul>
<div class="section" id="declaring-variables">
<h4>6.2.4.1. Declaring variables<a class="headerlink" href="#declaring-variables" title="Permalink to this headline">¶</a></h4>
<p>Variables are declared in the <a class="reference internal" href="core.html#pyCore.daeModel.__init__" title="pyCore.daeModel.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Ordinary variables:</span>
<span class="bp">self</span><span class="o">.</span><span class="n">myVar</span> <span class="o">=</span> <span class="n">daeVariable</span><span class="p">(</span><span class="s2">&quot;myVar&quot;</span><span class="p">,</span> <span class="n">variableType</span><span class="p">,</span> <span class="n">parentModel</span><span class="p">,</span> <span class="s2">&quot;description&quot;</span><span class="p">)</span>

<span class="c1"># Distributed variables:</span>
<span class="bp">self</span><span class="o">.</span><span class="n">myVar</span> <span class="o">=</span> <span class="n">daeVariable</span><span class="p">(</span><span class="s2">&quot;myVar&quot;</span><span class="p">,</span> <span class="n">variableType</span><span class="p">,</span> <span class="n">parentModel</span><span class="p">,</span> <span class="s2">&quot;description&quot;</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">myVar</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="n">myDomain</span><span class="p">)</span>
<span class="c1"># or simply:</span>
<span class="bp">self</span><span class="o">.</span><span class="n">myVar</span> <span class="o">=</span> <span class="n">daeVariable</span><span class="p">(</span><span class="s2">&quot;myVar&quot;</span><span class="p">,</span> <span class="n">variableType</span><span class="p">,</span> <span class="n">parentModel</span><span class="p">,</span> <span class="s2">&quot;description&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">myDomain</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="initialising-variables">
<h4>6.2.4.2. Initialising variables<a class="headerlink" href="#initialising-variables" title="Permalink to this headline">¶</a></h4>
<p>Variables are initialised in the <a class="reference internal" href="activity.html#pyActivity.daeSimulation.SetUpVariables" title="pyActivity.daeSimulation.SetUpVariables"><code class="xref py py-meth docutils literal"><span class="pre">SetUpVariables()</span></code></a> function:</p>
<ul>
<li><p class="first">The function <a class="reference internal" href="core.html#pyCore.daeVariable.AssignValue" title="pyCore.daeVariable.AssignValue"><code class="xref py py-meth docutils literal"><span class="pre">AssignValue()</span></code></a> is used to specify degrees of freedom:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">myVar</span><span class="o">.</span><span class="n">AssignValue</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<span class="c1"># If the variable is distributed:</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">myDomain</span><span class="o">.</span><span class="n">NumberOfPoints</span><span class="p">):</span>
    <span class="n">myVar</span><span class="o">.</span><span class="n">AssignValue</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<span class="c1"># In addition, all values can be specified in a single call using a numpy array:</span>
<span class="n">myVar</span><span class="o">.</span><span class="n">AssignValues</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
</pre></div>
</div>
<p>where the argument <cite>value</cite> can be either a floating point number or the <a class="reference internal" href="units.html#pyUnits.quantity" title="pyUnits.quantity"><code class="xref py py-class docutils literal"><span class="pre">quantity</span></code></a> object
(i.e. 1.34 * W/(m*K)), and <cite>values</cite> is a numpy array of floats or <a class="reference internal" href="units.html#pyUnits.quantity" title="pyUnits.quantity"><code class="xref py py-class docutils literal"><span class="pre">quantity</span></code></a> objects.
If the simple floats are used it is assumed that they represent values with the same units as in the
variable type definition.</p>
<p>The functions <a class="reference internal" href="core.html#pyCore.daeVariable.ReAssignValue" title="pyCore.daeVariable.ReAssignValue"><code class="xref py py-meth docutils literal"><span class="pre">ReAssignValue()</span></code></a> and <a class="reference internal" href="core.html#pyCore.daeVariable.ReAssignValues" title="pyCore.daeVariable.ReAssignValues"><code class="xref py py-meth docutils literal"><span class="pre">ReAssignValues()</span></code></a>
are used in a schedule during a simulation (in the function <a class="reference internal" href="activity.html#pyActivity.daeSimulation.Run" title="pyActivity.daeSimulation.Run"><code class="xref py py-meth docutils literal"><span class="pre">Run()</span></code></a>)
to re-assign the variable with the new value(s).</p>
</li>
<li><p class="first">The function <a class="reference internal" href="core.html#pyCore.daeVariable.SetInitialCondition" title="pyCore.daeVariable.SetInitialCondition"><code class="xref py py-meth docutils literal"><span class="pre">SetInitialCondition()</span></code></a> is used to set initial conditions:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">myVar</span><span class="o">.</span><span class="n">SetInitialCondition</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<span class="c1"># If the variable is distributed:</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">myDomain</span><span class="o">.</span><span class="n">NumberOfPoints</span><span class="p">):</span>
    <span class="n">myVar</span><span class="o">.</span><span class="n">SetInitialCondition</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<span class="c1"># In addition, all values can be specified in a single call using a numpy array:</span>
<span class="n">myVar</span><span class="o">.</span><span class="n">SetInitialConditions</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
</pre></div>
</div>
<p>The functions <a class="reference internal" href="core.html#pyCore.daeVariable.ReSetInitialCondition" title="pyCore.daeVariable.ReSetInitialCondition"><code class="xref py py-meth docutils literal"><span class="pre">ReSetInitialCondition()</span></code></a> and <a class="reference internal" href="core.html#pyCore.daeVariable.ReSetInitialConditions" title="pyCore.daeVariable.ReSetInitialConditions"><code class="xref py py-meth docutils literal"><span class="pre">ReSetInitialConditions()</span></code></a>
are used in a schedule during a simulation (in the function <a class="reference internal" href="activity.html#pyActivity.daeSimulation.Run" title="pyActivity.daeSimulation.Run"><code class="xref py py-meth docutils literal"><span class="pre">Run()</span></code></a>)
to re-initialise the variable with the new value(s).</p>
</li>
<li><p class="first">The function <a class="reference internal" href="core.html#pyCore.daeVariable.SetAbsoluteTolerances" title="pyCore.daeVariable.SetAbsoluteTolerances"><code class="xref py py-meth docutils literal"><span class="pre">SetAbsoluteTolerances()</span></code></a> is used to set absolute tolerances:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">myVar</span><span class="o">.</span><span class="n">SetAbsoluteTolerances</span><span class="p">(</span><span class="mf">1E-5</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">The function <a class="reference internal" href="core.html#pyCore.daeVariable.SetInitialGuess" title="pyCore.daeVariable.SetInitialGuess"><code class="xref py py-meth docutils literal"><span class="pre">SetInitialGuess()</span></code></a> is used to set initial guesses:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">myVar</span><span class="o">.</span><span class="n">SetInitialGuess</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<span class="c1"># If the variable is distributed:</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">myDomain</span><span class="o">.</span><span class="n">NumberOfPoints</span><span class="p">):</span>
    <span class="n">myVar</span><span class="o">.</span><span class="n">SetInitialGuess</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<span class="c1"># In addition, all values can be specified in a single call using a numpy array:</span>
<span class="n">myVar</span><span class="o">.</span><span class="n">SetInitialGuesses</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="using-variables">
<h4>6.2.4.3. Using variables<a class="headerlink" href="#using-variables" title="Permalink to this headline">¶</a></h4>
<p>The functions <code class="xref py py-meth docutils literal"><span class="pre">__call__()</span></code> and <a class="reference internal" href="core.html#pyCore.daeVariable.array" title="pyCore.daeVariable.array"><code class="xref py py-meth docutils literal"><span class="pre">array()</span></code></a> are used
to get a value or an array of values (for use in model equations only).
They accept the same type of arguments as explained in the section <a class="reference internal" href="#using-parameters">Using parameters</a>.
In addition, the following functions are used to get derivatives:</p>
<ol class="arabic">
<li><p class="first">The function <a class="reference internal" href="core.html#pyCore.dt" title="pyCore.dt"><code class="xref py py-meth docutils literal"><span class="pre">dt()</span></code></a> is used to get a time derivative of an ordinary variable.
For instance, the equation:</p>
<div class="math">
\[{ d(myVar) \over {d}{t} } = 1\]</div>
<p>is given as:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Notation:</span>
<span class="c1">#  - eq is a daeEquation object</span>
<span class="c1">#  - myVar is an ordinary daeVariable</span>
<span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">dt</span><span class="p">(</span><span class="n">myVar</span><span class="p">())</span> <span class="o">-</span> <span class="mf">1.0</span>
</pre></div>
</div>
<p>The same function is used for distributed variables. For example, the equation:</p>
<div class="math">
\[{d(myVar(i)) \over dt} = 1; \forall i \in [0, n]\]</div>
<p>is written as:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Notation:</span>
<span class="c1">#  - myDomain is daeDomain object</span>
<span class="c1">#  - n is the number of points in myDomain</span>
<span class="c1">#  - eq is a daeEquation object distributed on myDomain</span>
<span class="c1">#  - d1,d2 are objects used to iterate through the domain points</span>
<span class="c1">#  - myVar is daeVariable object distributed on myDomain</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="n">myDomain</span><span class="p">,</span> <span class="n">eClosedClosed</span><span class="p">)</span>
<span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">dt</span><span class="p">(</span><span class="n">myVar</span><span class="p">(</span><span class="n">d</span><span class="p">))</span> <span class="o">-</span> <span class="mf">1.0</span>
</pre></div>
</div>
<p>For variables that are distributed on more than one domain, the equation:</p>
<div class="math">
\[{d(myVar(d_1, d_2)) \over dt} = 1; \forall d_1 \in [0, n_1], \forall d_2 \in [0, n_2]\]</div>
<p>is specified as:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Notation:</span>
<span class="c1">#  - myDomain1, myDomain2 are daeDomain objects</span>
<span class="c1">#  - n1 is the number of points in myDomain1</span>
<span class="c1">#  - n2 is the number of points in myDomain2</span>
<span class="c1">#  - eq is a daeEquation object distributed on the domains myDomain1 and myDomain2</span>
<span class="c1">#  - d is daeDEDI object (used to iterate through the domain points)</span>
<span class="c1">#  - myVar is daeVariable object distributed on myDomain1 and myDomain2</span>
<span class="n">d1</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="n">myDomain1</span><span class="p">,</span> <span class="n">eClosedClosed</span><span class="p">)</span>
<span class="n">d2</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="n">myDomain2</span><span class="p">,</span> <span class="n">eClosedClosed</span><span class="p">)</span>
<span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">dt</span><span class="p">(</span><span class="n">myVar</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span><span class="n">d2</span><span class="p">))</span> <span class="o">-</span> <span class="mf">1.0</span>
</pre></div>
</div>
<p>The code translates into a set of <cite>n1 x n2</cite> equations.</p>
<p>The function <a class="reference internal" href="core.html#pyCore.dt_array" title="pyCore.dt_array"><code class="xref py py-meth docutils literal"><span class="pre">dt_array()</span></code></a> is used to get an array of time derivatives.
It accepts the same type of arguments as explained in the section <a class="reference internal" href="#using-parameters">Using parameters</a>.</p>
</li>
<li><p class="first">The functions <a class="reference internal" href="core.html#pyCore.d" title="pyCore.d"><code class="xref py py-meth docutils literal"><span class="pre">d()</span></code></a> and <a class="reference internal" href="core.html#pyCore.d2" title="pyCore.d2"><code class="xref py py-meth docutils literal"><span class="pre">d2()</span></code></a> are used to get a partial derivative of distributed variables.
For instance, the equation:</p>
<div class="math">
\[{\partial myVar(d) \over \partial myDomain} = 1.0; \forall d \in [0, n]\]</div>
<p>is written as:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Notation:</span>
<span class="c1">#  - myDomain is daeDomain object</span>
<span class="c1">#  - n is the number of points in myDomain</span>
<span class="c1">#  - eq is a daeEquation object distributed on myDomain</span>
<span class="c1">#  - d is daeDEDI object (used to iterate through the domain points)</span>
<span class="c1">#  - myVar is daeVariable object distributed on myDomain</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="n">myDomain</span><span class="p">,</span> <span class="n">eClosedClosed</span><span class="p">)</span>
<span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">d</span><span class="p">(</span><span class="n">myVar</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">myDomain</span><span class="p">,</span> <span class="n">discretizationMethod</span><span class="o">=</span><span class="n">eCFDM</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{})</span> <span class="o">-</span> <span class="mf">1.0</span>

<span class="c1"># since the defaults are eCFDM and an empty options dictionary the above is equivalent to:</span>
<span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">d</span><span class="p">(</span><span class="n">myVar</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">myDomain</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span>
</pre></div>
</div>
<p>The default discretisation method is center finite difference method (<cite>eCFDM`</cite>) and the default
discretisation order is 2 and can be specified in the <cite>options</cite> dictionary: <cite>options[&#8220;DiscretizationOrder&#8221;] = integer</cite>.
At the moment, only the finite difference discretisation methods are supported by default
(but the finite volume and finite elements implementations are available using the third party libraries):</p>
<ul class="simple">
<li>Center finite difference method (<cite>eCFDM</cite>)</li>
<li>Backward finite difference method (<cite>eBFDM</cite>)</li>
<li>Forward finite difference method (<cite>eFFDM</cite>)</li>
</ul>
<p>The functions <a class="reference internal" href="core.html#pyCore.d_array" title="pyCore.d_array"><code class="xref py py-meth docutils literal"><span class="pre">d_array()</span></code></a> and <a class="reference internal" href="core.html#pyCore.d2_array" title="pyCore.d2_array"><code class="xref py py-meth docutils literal"><span class="pre">d2_array()</span></code></a> are used to get an array of partial derivatives.
They accept the same type of arguments as explained in the section <a class="reference internal" href="#using-parameters">Using parameters</a>.</p>
</li>
</ol>
<p>The property <a class="reference internal" href="core.html#pyCore.daeVariable.npyValues" title="pyCore.daeVariable.npyValues"><code class="xref py py-attr docutils literal"><span class="pre">npyValues</span></code></a> contains the variable values as a numpy multi-dimensional array
(with <cite>numpy.float</cite> data type).
The functions <a class="reference internal" href="core.html#pyCore.daeVariable.SetValue" title="pyCore.daeVariable.SetValue"><code class="xref py py-meth docutils literal"><span class="pre">SetValue()</span></code></a> and <a class="reference internal" href="core.html#pyCore.daeVariable.GetValue" title="pyCore.daeVariable.GetValue"><code class="xref py py-meth docutils literal"><span class="pre">GetValue()</span></code></a> /
<a class="reference internal" href="core.html#pyCore.daeVariable.GetQuantity" title="pyCore.daeVariable.GetQuantity"><code class="xref py py-meth docutils literal"><span class="pre">GetQuantity()</span></code></a> are used to get/set the variable value as a floating point number or
the <a class="reference internal" href="units.html#pyUnits.quantity" title="pyUnits.quantity"><code class="xref py py-class docutils literal"><span class="pre">quantity</span></code></a> object.</p>
<div class="topic">
<p class="topic-title first">Nota bene</p>
<p>The functions <code class="xref py py-meth docutils literal"><span class="pre">__call__()</span></code>, <a class="reference internal" href="core.html#pyCore.dt" title="pyCore.dt"><code class="xref py py-meth docutils literal"><span class="pre">dt()</span></code></a>,
<a class="reference internal" href="core.html#pyCore.d" title="pyCore.d"><code class="xref py py-meth docutils literal"><span class="pre">d()</span></code></a>, <a class="reference internal" href="core.html#pyCore.d2" title="pyCore.d2"><code class="xref py py-meth docutils literal"><span class="pre">d2()</span></code></a>, <a class="reference internal" href="core.html#pyCore.daeVariable.array" title="pyCore.daeVariable.array"><code class="xref py py-meth docutils literal"><span class="pre">array()</span></code></a>,
<a class="reference internal" href="core.html#pyCore.dt_array" title="pyCore.dt_array"><code class="xref py py-meth docutils literal"><span class="pre">dt_array()</span></code></a>, <a class="reference internal" href="core.html#pyCore.d_array" title="pyCore.d_array"><code class="xref py py-meth docutils literal"><span class="pre">d_array()</span></code></a>
and <a class="reference internal" href="core.html#pyCore.d2_array" title="pyCore.d2_array"><code class="xref py py-meth docutils literal"><span class="pre">d2_array()</span></code></a> can only be used to build equations&#8217; residual expressions.
On the other hand, the functions <a class="reference internal" href="core.html#pyCore.daeVariable.GetValue" title="pyCore.daeVariable.GetValue"><code class="xref py py-class docutils literal"><span class="pre">GetValue</span></code></a>,
<a class="reference internal" href="core.html#pyCore.daeVariable.SetValue" title="pyCore.daeVariable.SetValue"><code class="xref py py-class docutils literal"><span class="pre">SetValue</span></code></a> and <a class="reference internal" href="core.html#pyCore.daeVariable.npyValues" title="pyCore.daeVariable.npyValues"><code class="xref py py-attr docutils literal"><span class="pre">npyValues</span></code></a> can be used
to access the variable data at any point.</p>
</div>
<p>More information about variables can be found in the API reference <a class="reference internal" href="core.html#pyCore.daeVariable" title="pyCore.daeVariable"><code class="xref py py-class docutils literal"><span class="pre">daeVariable</span></code></a>
and in <a class="reference internal" href="tutorials.html"><span class="doc">Tutorials</span></a>.</p>
</div>
</div>
<div class="section" id="ports">
<h3>6.2.5. Ports<a class="headerlink" href="#ports" title="Permalink to this headline">¶</a></h3>
<p>Ports define connection points between model instances for exchange of continuous quantities.
Like models, they can contain domains, parameters and variables.</p>
<p>New type of ports are defined by deriving a class from the base <a class="reference internal" href="core.html#pyCore.daePort" title="pyCore.daePort"><code class="xref py py-class docutils literal"><span class="pre">daePort</span></code></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">myPort</span><span class="p">(</span><span class="n">daePort</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="n">daePort</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">description</span><span class="p">)</span>

        <span class="c1"># Declaration/instantiation of domains, parameters and variables</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>The port structure (domains, parameters and variables) is declared in the
<a class="reference internal" href="core.html#pyCore.daePort.__init__" title="pyCore.daePort.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> function.
The same rules apply as described in the section <a class="reference internal" href="#developing-models">Developing models</a>.
Two ports are connected using the <a class="reference internal" href="core.html#pyCore.daeModel.ConnectPorts" title="pyCore.daeModel.ConnectPorts"><code class="xref py py-meth docutils literal"><span class="pre">ConnectPorts()</span></code></a> function.
Ports are instantiated as <cite>inlet</cite> or <cite>outlet</cite> type in the <a class="reference internal" href="core.html#pyCore.daeModel.__init__" title="pyCore.daeModel.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">myPort</span> <span class="o">=</span> <span class="n">daePort</span><span class="p">(</span><span class="s2">&quot;myPort&quot;</span><span class="p">,</span> <span class="n">eInletPort</span><span class="p">,</span> <span class="n">parentModel</span><span class="p">,</span> <span class="s2">&quot;description&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="event-ports">
<h3>6.2.6. Event ports<a class="headerlink" href="#event-ports" title="Permalink to this headline">¶</a></h3>
<p>Event ports define connection points between model instances for exchange of discrete messages/events.
Events can be triggered manually (using the <a class="reference internal" href="core.html#pyCore.daeEventPort.SendEvent" title="pyCore.daeEventPort.SendEvent"><code class="xref py py-meth docutils literal"><span class="pre">SendEvent()</span></code></a> function) or when
a specified condition is satisfied.
The main difference between event and ordinary ports is that the former allow a discrete communication
between models while the latter allow a continuous exchange of information.</p>
<p>Messages are floating point values that can be used by a recipient. Upon a reception of an event,
a set of actions are executed. The actions are specified in the <a class="reference internal" href="core.html#pyCore.daeModel.ON_EVENT" title="pyCore.daeModel.ON_EVENT"><code class="xref py py-meth docutils literal"><span class="pre">ON_EVENT()</span></code></a> function.
The events received by an event port can be recorded by setting the boolean
<a class="reference internal" href="core.html#pyCore.daeEventPort.RecordEvents" title="pyCore.daeEventPort.RecordEvents"><code class="xref py py-attr docutils literal"><span class="pre">RecordEvents</span></code></a> property to <cite>True</cite> and retrieved using the
<a class="reference internal" href="core.html#pyCore.daeEventPort.Events" title="pyCore.daeEventPort.Events"><code class="xref py py-attr docutils literal"><span class="pre">Events</span></code></a> property.</p>
<p>Two event ports are connected using the <a class="reference internal" href="core.html#pyCore.daeModel.ConnectEventPorts" title="pyCore.daeModel.ConnectEventPorts"><code class="xref py py-meth docutils literal"><span class="pre">ConnectEventPorts()</span></code></a> function.
A single outlet event port can be connected to unlimited number of inlet event ports.
Event ports are instantiated in the <a class="reference internal" href="core.html#pyCore.daeModel.__init__" title="pyCore.daeModel.__init__"><code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code></a> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="bp">self</span><span class="o">.</span><span class="n">myEventPort</span> <span class="o">=</span> <span class="n">daeEventPort</span><span class="p">(</span><span class="s2">&quot;myEventPort&quot;</span><span class="p">,</span> <span class="n">eOutletPort</span><span class="p">,</span> <span class="n">parentModel</span><span class="p">,</span> <span class="s2">&quot;description&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="equations">
<h3>6.2.7. Equations<a class="headerlink" href="#equations" title="Permalink to this headline">¶</a></h3>
<p>Model equations are specified in an implicit (acausal) form.
They can be continuous or discontinuous and distributed on one or more domains.
Equations can be distributed on a whole domain, on a portion of it or even on
a single point (i.e. equations for boundary conditions).</p>
<div class="section" id="declaring-equations">
<h4>6.2.7.1. Declaring equations<a class="headerlink" href="#declaring-equations" title="Permalink to this headline">¶</a></h4>
<p>Equations are declared in the <a class="reference internal" href="core.html#pyCore.daeModel.DeclareEquations" title="pyCore.daeModel.DeclareEquations"><code class="xref py py-meth docutils literal"><span class="pre">DeclareEquations()</span></code></a> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Ordinary equation:</span>
<span class="n">eq</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">CreateEquation</span><span class="p">(</span><span class="s2">&quot;MyEquation&quot;</span><span class="p">,</span> <span class="s2">&quot;description&quot;</span><span class="p">)</span>

<span class="c1"># Distributed equation (on the whole domain, including the boundaries):</span>
<span class="n">eq</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">CreateEquation</span><span class="p">(</span><span class="s2">&quot;MyEquation&quot;</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="n">myDomain</span><span class="p">,</span> <span class="n">eClosedClosed</span><span class="p">)</span>
</pre></div>
</div>
<p>Currently, the following options for distributing equations are available:</p>
<ul class="simple">
<li>Distributed on a closed (whole) domain: <span class="math">\(x \in [x_0, x_n]\)</span></li>
<li>Distributed on a left open domain: <span class="math">\(x \in (x_0, x_n]\)</span></li>
<li>Distributed on a right open domain: <span class="math">\(x \in [x_0, x_n)\)</span></li>
<li>Distributed on a domain open on both sides: <span class="math">\(x \in (x_0, x_n)\)</span></li>
<li>Distributed on the lower bound: <span class="math">\(x \in \{ x_0 \}\)</span></li>
<li>Distributed on the upper bound: <span class="math">\(x \in \{ x_n \}\)</span></li>
<li>Distributed on a given set of points within a domain: i.e. <span class="math">\(x \in \{ x_0, x_3, x_7, x_8 \}\)</span></li>
</ul>
<p>where <span class="math">\(x_0\)</span> represents the lower bound and <span class="math">\(x_n\)</span> the upper bound of the domain.</p>
<p>An overview of available options is given in the table below.
The examples are given for an equation distributed on two domains: <cite>x</cite> and <cite>y</cite>.
Green squares represent portions of a domain included in the distributed equation,
while white squares represent excluded portions.</p>
<table border="1" class="docutils">
<colgroup>
<col width="49%" />
<col width="51%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><div class="first last line-block">
<div class="line"><a class="reference internal" href="_images/EquationBounds_CC_CC.png"><img alt="EquationBounds_CC_CC" src="_images/EquationBounds_CC_CC.png" style="width: 200pt;" /></a></div>
<div class="line-block">
<div class="line">x = eClosedClosed; y = eClosedClosed</div>
<div class="line"><span class="math">\(x \in [x_0, x_n], y \in [y_0, y_n]\)</span></div>
</div>
</div>
</td>
<td><div class="first last line-block">
<div class="line"><a class="reference internal" href="_images/EquationBounds_OO_OO.png"><img alt="EquationBounds_OO_OO" src="_images/EquationBounds_OO_OO.png" style="width: 200pt;" /></a></div>
<div class="line-block">
<div class="line">x = eOpenOpen; y = eOpenOpen</div>
<div class="line"><span class="math">\(x \in ( x_0, x_n ), y \in ( y_0, y_n )\)</span></div>
</div>
</div>
</td>
</tr>
<tr class="row-even"><td><div class="first last line-block">
<div class="line"><a class="reference internal" href="_images/EquationBounds_CC_OO.png"><img alt="EquationBounds_CC_OO" src="_images/EquationBounds_CC_OO.png" style="width: 200pt;" /></a></div>
<div class="line-block">
<div class="line">x = eClosedClosed; y = eOpenOpen</div>
<div class="line"><span class="math">\(x \in [x_0, x_n], y \in ( y_0, y_n )\)</span></div>
</div>
</div>
</td>
<td><div class="first last line-block">
<div class="line"><a class="reference internal" href="_images/EquationBounds_CC_OC.png"><img alt="EquationBounds_CC_OC" src="_images/EquationBounds_CC_OC.png" style="width: 200pt;" /></a></div>
<div class="line-block">
<div class="line">x = eClosedClosed; y = eOpenClosed</div>
<div class="line"><span class="math">\(x \in [x_0, x_n], y \in ( y_0, y_n ]\)</span></div>
</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><div class="first last line-block">
<div class="line"><a class="reference internal" href="_images/EquationBounds_LB_CO.png"><img alt="EquationBounds_LB_CO" src="_images/EquationBounds_LB_CO.png" style="width: 200pt;" /></a></div>
<div class="line-block">
<div class="line">x = eLowerBound; y = eClosedOpen</div>
<div class="line"><span class="math">\(x = x_0, y \in [ y_0, y_n )\)</span></div>
</div>
</div>
</td>
<td><div class="first last line-block">
<div class="line"><a class="reference internal" href="_images/EquationBounds_LB_CC.png"><img alt="EquationBounds_LB_CC" src="_images/EquationBounds_LB_CC.png" style="width: 200pt;" /></a></div>
<div class="line-block">
<div class="line">x = eLowerBound; y = eClosedClosed</div>
<div class="line"><span class="math">\(x = x_0, y \in [y_0, y_n]\)</span></div>
</div>
</div>
</td>
</tr>
<tr class="row-even"><td><div class="first last line-block">
<div class="line"><a class="reference internal" href="_images/EquationBounds_UB_CC.png"><img alt="EquationBounds_UB_CC" src="_images/EquationBounds_UB_CC.png" style="width: 200pt;" /></a></div>
<div class="line-block">
<div class="line">x = eUpperBound; y = eClosedClosed</div>
<div class="line"><span class="math">\(x = x_n, y \in [y_0, y_n]\)</span></div>
</div>
</div>
</td>
<td><div class="first last line-block">
<div class="line"><a class="reference internal" href="_images/EquationBounds_LB_UB.png"><img alt="EquationBounds_LB_UB" src="_images/EquationBounds_LB_UB.png" style="width: 200pt;" /></a></div>
<div class="line-block">
<div class="line">x = eLowerBound; y = eUpperBound</div>
<div class="line"><span class="math">\(x = x_0, y = y_n\)</span></div>
</div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="defining-equations">
<h4>6.2.7.2. Defining equations<a class="headerlink" href="#defining-equations" title="Permalink to this headline">¶</a></h4>
<p>Equations in <strong>DAE Tools</strong> are specified in implicit (acausal) form as residual expressions.
For instance, a residual for an ordinary equation:</p>
<div class="math">
\[{\partial V_{14} \over \partial t} + {V_1 \over V_{14} + 2.5} + sin(3.14 \cdot V_3) = 0\]</div>
<p>is specified as:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Notation:</span>
<span class="c1">#  - V1, V3, V14 are ordinary variables</span>
<span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">dt</span><span class="p">(</span><span class="n">V14</span><span class="p">())</span> <span class="o">+</span> <span class="n">V1</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="n">V14</span><span class="p">()</span> <span class="o">+</span> <span class="mf">2.5</span><span class="p">)</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="mf">3.14</span> <span class="o">*</span> <span class="n">V3</span><span class="p">())</span>
</pre></div>
</div>
<p>while a distributed equation:</p>
<div class="math">
\[{\partial V_{14}(x,y)) \over \partial t} + {V_1 \over V_{14}(x,y) + 2.5} + sin(3.14 \cdot V_3(x,y)) = 0;
\forall x \in [0, nx], \forall y \in (0, ny)\]</div>
<p>is given as:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Notation:</span>
<span class="c1">#  - V1 is an ordinary variable</span>
<span class="c1">#  - V3 and V14 are variables distributed on domains x and y</span>
<span class="n">eq</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">CreateEquation</span><span class="p">(</span><span class="s2">&quot;MyEquation&quot;</span><span class="p">)</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">eClosedClosed</span><span class="p">)</span>
<span class="n">dy</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">eOpenOpen</span><span class="p">)</span>
<span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">dt</span><span class="p">(</span><span class="n">V14</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span><span class="n">dy</span><span class="p">))</span> <span class="o">+</span> <span class="n">V1</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span> <span class="n">V14</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span><span class="n">dy</span><span class="p">)</span> <span class="o">+</span> <span class="mf">2.5</span><span class="p">)</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="mf">3.14</span> <span class="o">*</span> <span class="n">V3</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span><span class="n">dy</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>where <cite>dx</cite> and <cite>dy</cite> are <a class="reference internal" href="core.html#pyCore.daeDEDI" title="pyCore.daeDEDI"><code class="xref py py-class docutils literal"><span class="pre">daeDEDI</span></code></a> (which is short for <cite>daeDistributedEquationDomainInfo</cite>) objects.
These objects are used internally by the framework to iterate over the domain points when generating a set of equations
from a distributed equation.
Therefore, the equation above is equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Notation:</span>
<span class="c1">#  - V1 is an ordinary variable</span>
<span class="c1">#  - V3 and V14 are variables distributed on domains x and y</span>
<span class="k">for</span> <span class="n">dx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">NumberOfPoints</span><span class="p">):</span> <span class="c1"># x: [x0, xn]</span>
    <span class="k">for</span> <span class="n">dy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">NumberOfPoints</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># y: (y0, yn)</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">CreateEquation</span><span class="p">(</span><span class="s2">&quot;MyEquation(</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">)</span> <span class="p">)</span>
        <span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">dt</span><span class="p">(</span><span class="n">V14</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span><span class="n">dy</span><span class="p">))</span> <span class="o">+</span> <span class="n">V1</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span> <span class="n">V14</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span><span class="n">dy</span><span class="p">)</span> <span class="o">+</span> <span class="mf">2.5</span><span class="p">)</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="mf">3.14</span> <span class="o">*</span> <span class="n">V3</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span><span class="n">dy</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>The latter form can be used for specifying equations that take different forms in different regions within domains.</p>
<p><a class="reference internal" href="core.html#pyCore.daeDEDI" title="pyCore.daeDEDI"><code class="xref py py-class docutils literal"><span class="pre">daeDEDI</span></code></a> class provides the function <a class="reference internal" href="core.html#pyCore.daeDEDI.__call__" title="pyCore.daeDEDI.__call__"><code class="xref py py-class docutils literal"><span class="pre">__call__</span></code></a> (<cite>operator ()</cite>)
that returns the current index as the <a class="reference internal" href="core.html#pyCore.adouble" title="pyCore.adouble"><code class="xref py py-class docutils literal"><span class="pre">adouble</span></code></a> object.
In addition, the operators <cite>+</cite> and <cite>-</cite> can be used to offset the current index by the specified integer.
For instance, the equation below:</p>
<div class="math">
\[V_1(x) = V_2(x) + V_2(x+1); \forall x \in [0, nx)\]</div>
<p>is specified as:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Notation:</span>
<span class="c1">#  - V1 and V2 are variables distributed on the x domain</span>
<span class="n">eq</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">CreateEquation</span><span class="p">(</span><span class="s2">&quot;MyEquation&quot;</span><span class="p">)</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">eClosedOpen</span><span class="p">)</span>
<span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">V1</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span> <span class="n">V2</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span> <span class="o">+</span> <span class="n">V2</span><span class="p">(</span><span class="n">dx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>Units consistency for all equations is checked by default. This can be changed for individual equations using the
boolean property <a class="reference internal" href="core.html#pyCore.daeEquation.CheckUnitsConsistency" title="pyCore.daeEquation.CheckUnitsConsistency"><code class="xref py py-attr docutils literal"><span class="pre">CheckUnitsConsistency</span></code></a> or globally in the <cite>daetools.cfg</cite> config file.</p>
<p>Scaling of equations&#8217; residuals could be very important for the convergence of the numerical algorithm.
Large condition numbers produce ill-conditioned Jacobian matrices and a solution of a linear system of equations is
prone to large numerical errors. The equation scaling is 1.0 by default and can be changed using the
<a class="reference internal" href="core.html#pyCore.daeEquation.Scaling" title="pyCore.daeEquation.Scaling"><code class="xref py py-attr docutils literal"><span class="pre">Scaling</span></code></a> property.</p>
<p>Evaluation of derivatives of very large equations can be very costly since they contain a large number of variables.
For instance, taking an average value or a sum of all points in a large 2D or 3D domain can produce an equation residual with
tens of thousands of terms. Evaluation of all Jacobian items for such equations requires calculation of tens of thousands of
terms per every Jacobian item. However, only a single term has a non-zero value and a lot of time is wasted calculating terms
that always produce zero. Thus, building of Jacobian expressions ahead of time can significantly improve the numerical
performance (at the cost of larger memory requirements). Pre-building of Jacobian expressions can be performed
using the boolean property <a class="reference internal" href="core.html#pyCore.daeEquation.BuildJacobianExpressions" title="pyCore.daeEquation.BuildJacobianExpressions"><code class="xref py py-attr docutils literal"><span class="pre">BuildJacobianExpressions</span></code></a> (the default is <cite>False</cite>).</p>
</div>
<div class="section" id="supported-mathematical-operations-and-functions">
<h4>6.2.7.3. Supported mathematical operations and functions<a class="headerlink" href="#supported-mathematical-operations-and-functions" title="Permalink to this headline">¶</a></h4>
<p><strong>DAE Tools</strong> support five basic mathematical operations (+, -, <cite>*</cite>, /, <cite>**</cite>) and the following
standard mathematical functions: <a class="reference internal" href="core.html#pyCore.Sqrt" title="pyCore.Sqrt"><code class="xref py py-meth docutils literal"><span class="pre">Sqrt()</span></code></a>, <a class="reference internal" href="core.html#pyCore.Pow" title="pyCore.Pow"><code class="xref py py-meth docutils literal"><span class="pre">Pow()</span></code></a>, <a class="reference internal" href="core.html#pyCore.Log" title="pyCore.Log"><code class="xref py py-meth docutils literal"><span class="pre">Log()</span></code></a>,
<a class="reference internal" href="core.html#pyCore.Log10" title="pyCore.Log10"><code class="xref py py-meth docutils literal"><span class="pre">Log10()</span></code></a>, <a class="reference internal" href="core.html#pyCore.Exp" title="pyCore.Exp"><code class="xref py py-meth docutils literal"><span class="pre">Exp()</span></code></a>, <a class="reference internal" href="core.html#pyCore.Min" title="pyCore.Min"><code class="xref py py-meth docutils literal"><span class="pre">Min()</span></code></a>, <a class="reference internal" href="core.html#pyCore.Max" title="pyCore.Max"><code class="xref py py-meth docutils literal"><span class="pre">Max()</span></code></a>,
<a class="reference internal" href="core.html#pyCore.Floor" title="pyCore.Floor"><code class="xref py py-meth docutils literal"><span class="pre">Floor()</span></code></a>, <a class="reference internal" href="core.html#pyCore.Ceil" title="pyCore.Ceil"><code class="xref py py-meth docutils literal"><span class="pre">Ceil()</span></code></a>, <a class="reference internal" href="core.html#pyCore.Abs" title="pyCore.Abs"><code class="xref py py-meth docutils literal"><span class="pre">Abs()</span></code></a>, <a class="reference internal" href="core.html#pyCore.Sin" title="pyCore.Sin"><code class="xref py py-meth docutils literal"><span class="pre">Sin()</span></code></a>,
<a class="reference internal" href="core.html#pyCore.Cos" title="pyCore.Cos"><code class="xref py py-meth docutils literal"><span class="pre">Cos()</span></code></a>, <a class="reference internal" href="core.html#pyCore.Tan" title="pyCore.Tan"><code class="xref py py-meth docutils literal"><span class="pre">Tan()</span></code></a>, <a class="reference internal" href="core.html#pyCore.ASin" title="pyCore.ASin"><code class="xref py py-meth docutils literal"><span class="pre">ASin()</span></code></a>, <a class="reference internal" href="core.html#pyCore.ACos" title="pyCore.ACos"><code class="xref py py-meth docutils literal"><span class="pre">ACos()</span></code></a>,
<a class="reference internal" href="core.html#pyCore.ATan" title="pyCore.ATan"><code class="xref py py-meth docutils literal"><span class="pre">ATan()</span></code></a>, <a class="reference internal" href="core.html#pyCore.Sinh" title="pyCore.Sinh"><code class="xref py py-meth docutils literal"><span class="pre">Sinh()</span></code></a>, <a class="reference internal" href="core.html#pyCore.Cosh" title="pyCore.Cosh"><code class="xref py py-meth docutils literal"><span class="pre">Cosh()</span></code></a>, <a class="reference internal" href="core.html#pyCore.Tanh" title="pyCore.Tanh"><code class="xref py py-meth docutils literal"><span class="pre">Tanh()</span></code></a>,
<a class="reference internal" href="core.html#pyCore.ASinh" title="pyCore.ASinh"><code class="xref py py-meth docutils literal"><span class="pre">ASinh()</span></code></a>, <a class="reference internal" href="core.html#pyCore.ACosh" title="pyCore.ACosh"><code class="xref py py-meth docutils literal"><span class="pre">ACosh()</span></code></a>, <a class="reference internal" href="core.html#pyCore.ATanh" title="pyCore.ATanh"><code class="xref py py-meth docutils literal"><span class="pre">ATanh()</span></code></a>, <a class="reference internal" href="core.html#pyCore.ATan2" title="pyCore.ATan2"><code class="xref py py-meth docutils literal"><span class="pre">ATan2()</span></code></a> and
<a class="reference internal" href="core.html#pyCore.Erf" title="pyCore.Erf"><code class="xref py py-meth docutils literal"><span class="pre">Erf()</span></code></a>. All the above-mentioned operators and functions operate on <a class="reference internal" href="core.html#pyCore.adouble" title="pyCore.adouble"><code class="xref py py-class docutils literal"><span class="pre">adouble</span></code></a> and
<a class="reference internal" href="core.html#pyCore.adouble_array" title="pyCore.adouble_array"><code class="xref py py-class docutils literal"><span class="pre">adouble_array</span></code></a> objects.
In addition, functions such as <a class="reference internal" href="core.html#pyCore.Sum" title="pyCore.Sum"><code class="xref py py-meth docutils literal"><span class="pre">Sum()</span></code></a>,
<a class="reference internal" href="core.html#pyCore.Product" title="pyCore.Product"><code class="xref py py-meth docutils literal"><span class="pre">Product()</span></code></a>, <a class="reference internal" href="core.html#pyCore.Average" title="pyCore.Average"><code class="xref py py-meth docutils literal"><span class="pre">Average()</span></code></a>, <a class="reference internal" href="core.html#pyCore.Min" title="pyCore.Min"><code class="xref py py-meth docutils literal"><span class="pre">Min()</span></code></a> and <a class="reference internal" href="core.html#pyCore.Max" title="pyCore.Max"><code class="xref py py-meth docutils literal"><span class="pre">Max()</span></code></a>
operate only on <a class="reference internal" href="core.html#pyCore.adouble_array" title="pyCore.adouble_array"><code class="xref py py-class docutils literal"><span class="pre">adouble_array</span></code></a> objects.</p>
<p>Logical conditions are specified using the following comparison operators:
<cite>&lt;</cite> (less than),
<cite>&lt;=</cite> (less than or equal),
<cite>==</cite> (equal),
<cite>!=</cite> (not equal),
<cite>&gt;</cite> (greater than),
<cite>&gt;=</cite> (greater than or equal)
and the following logical operators:
<cite>&amp;</cite> (logical AND),
<cite>|</cite> (logical OR),
<cite>~</cite> (logical NOT)
can be used.</p>
<div class="topic">
<p class="topic-title first">Nota bene</p>
<p>It is not allowed to overload Python&#8217;s built-in operators <strong>and</strong>, <strong>or</strong> and <strong>not</strong>.
Therefore, the operators <strong>&amp;</strong>, <strong>|</strong> and <strong>~</strong> are defined and should be used instead.</p>
</div>
</div>
<div class="section" id="interoperability-with-numpy">
<h4>6.2.7.4. Interoperability with NumPy<a class="headerlink" href="#interoperability-with-numpy" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference internal" href="core.html#pyCore.adouble" title="pyCore.adouble"><code class="xref py py-class docutils literal"><span class="pre">adouble</span></code></a> and <a class="reference internal" href="core.html#pyCore.adouble_array" title="pyCore.adouble_array"><code class="xref py py-class docutils literal"><span class="pre">adouble_array</span></code></a> classes are designed with
the support for <code class="xref py py-class docutils literal"><span class="pre">numpy</span></code> library in mind.
They implement most of the standard mathematical functions available in <code class="xref py py-mod docutils literal"><span class="pre">numpy</span></code>
such as <code class="xref py py-meth docutils literal"><span class="pre">numpy.sqrt()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">numpy.pow()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">numpy.log()</span></code>,
<code class="xref py py-meth docutils literal"><span class="pre">numpy.log10()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">numpy.exp()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">numpy.min()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">numpy.max()</span></code>,
<code class="xref py py-meth docutils literal"><span class="pre">numpy.floor()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">numpy.ceil()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">numpy.abs()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">numpy.sin()</span></code>,
<code class="xref py py-meth docutils literal"><span class="pre">numpy.cos()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">numpy.tan()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">numpy.asin()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">numpy.acos()</span></code>,
<code class="xref py py-meth docutils literal"><span class="pre">numpy.atan()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">numpy.sinh()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">numpy.cosh()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">numpy.tanh()</span></code>,
<code class="xref py py-meth docutils literal"><span class="pre">numpy.asinh()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">numpy.acosh()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">numpy.atanh()</span></code>, <code class="xref py py-meth docutils literal"><span class="pre">numpy.atan2()</span></code>
and <code class="xref py py-meth docutils literal"><span class="pre">numpy.erf()</span></code>).
This way, <a class="reference internal" href="core.html#pyCore.adouble" title="pyCore.adouble"><code class="xref py py-class docutils literal"><span class="pre">adouble</span></code></a> and <a class="reference internal" href="core.html#pyCore.adouble_array" title="pyCore.adouble_array"><code class="xref py py-class docutils literal"><span class="pre">adouble_array</span></code></a> objects can be used
as native data types for <code class="xref py py-class docutils literal"><span class="pre">numpy</span></code> functions.
Moreover, <code class="xref py py-class docutils literal"><span class="pre">numpy</span></code> and <strong>DAE Tools</strong> mathematical functions are interchangeable.
In the example given below, <a class="reference internal" href="core.html#pyCore.Exp" title="pyCore.Exp"><code class="xref py py-meth docutils literal"><span class="pre">Exp()</span></code></a> and <code class="xref py py-meth docutils literal"><span class="pre">numpy.exp()</span></code> functions produce identical results:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Notation:</span>
<span class="c1">#  - Var is an ordinary variable</span>
<span class="c1">#  - result is an ordinary variable</span>
<span class="n">eq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CreateEquation</span><span class="p">(</span><span class="s2">&quot;...&quot;</span><span class="p">)</span>
<span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">result</span><span class="p">()</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="n">Var</span><span class="p">()</span> <span class="p">)</span>

<span class="c1"># The above is identical to:</span>
<span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">result</span><span class="p">()</span> <span class="o">-</span> <span class="n">Exp</span><span class="p">(</span> <span class="n">Var</span><span class="p">()</span> <span class="p">)</span>
</pre></div>
</div>
<p>Often, it is desired to apply <code class="xref py py-class docutils literal"><span class="pre">numpy</span></code>/<code class="xref py py-class docutils literal"><span class="pre">scipy</span></code> numerical functions on arrays of <a class="reference internal" href="core.html#pyCore.adouble" title="pyCore.adouble"><code class="xref py py-class docutils literal"><span class="pre">adouble</span></code></a> objects.
In those cases the functions such as <code class="xref py py-meth docutils literal"><span class="pre">array()</span></code>, <a class="reference internal" href="core.html#pyCore.d_array" title="pyCore.d_array"><code class="xref py py-meth docutils literal"><span class="pre">d_array()</span></code></a>,
<a class="reference internal" href="core.html#pyCore.dt_array" title="pyCore.dt_array"><code class="xref py py-meth docutils literal"><span class="pre">dt_array()</span></code></a>, <a class="reference internal" href="core.html#pyCore.Array" title="pyCore.Array"><code class="xref py py-meth docutils literal"><span class="pre">Array()</span></code></a> etc.
are NOT applicable since they return <a class="reference internal" href="core.html#pyCore.adouble_array" title="pyCore.adouble_array"><code class="xref py py-class docutils literal"><span class="pre">adouble_array</span></code></a> objects.
However, <code class="xref py py-class docutils literal"><span class="pre">numpy</span></code> arrays can be created and populated with <a class="reference internal" href="core.html#pyCore.adouble" title="pyCore.adouble"><code class="xref py py-class docutils literal"><span class="pre">adouble</span></code></a> objects and <code class="xref py py-class docutils literal"><span class="pre">numpy</span></code> functions
applied on them. In addition, an <a class="reference internal" href="core.html#pyCore.adouble_array" title="pyCore.adouble_array"><code class="xref py py-class docutils literal"><span class="pre">adouble_array</span></code></a> object can be created from resulting <code class="xref py py-class docutils literal"><span class="pre">numpy</span></code> arrays
of <a class="reference internal" href="core.html#pyCore.adouble" title="pyCore.adouble"><code class="xref py py-class docutils literal"><span class="pre">adouble</span></code></a> objects, if necessary.</p>
<p>For instance, to define the equation below:</p>
<div class="math">
\[sum = \sum\limits_{i=0}^{N_x-1} \left( V_1(i) + 2 \cdot V_2(i)^2 \right)\]</div>
<p>the following code can be used:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Notation:</span>
<span class="c1">#  - x is a continuous domain</span>
<span class="c1">#  - V1 is a variable distributed on the x domain</span>
<span class="c1">#  - V2 is a variable distributed on the x domain</span>
<span class="c1">#  - sum is an ordinary variable</span>
<span class="c1">#  - ndarr_V1 is one dimensional numpy array with dtype=object</span>
<span class="c1">#  - ndarr_V2 is one dimensional numpy array with dtype=object</span>
<span class="c1">#  - adarr_V1 is adouble_array object</span>
<span class="c1">#  - Nx is the number of points in the domain x</span>

<span class="c1"># 1. Create empty numpy arrays as a container for daetools adouble objects</span>
<span class="n">ndarr_V1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
<span class="n">ndarr_V2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

<span class="c1"># 2. Fill the created numpy arrays with adouble objects</span>
<span class="n">ndarr_V1</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">V1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nx</span><span class="p">)]</span>
<span class="n">ndarr_V2</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">V2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nx</span><span class="p">)]</span>

<span class="c1"># Now, ndarr_V1 and ndarr_V2 represent arrays of Nx adouble objects each:</span>
<span class="c1">#  ndarr_V1 := [V1(0), V1(1), V1(2), ..., V1(Nx-1)]</span>
<span class="c1">#  ndarr_V2 := [V2(0), V2(1), V2(2), ..., V2(Nx-1)]</span>

<span class="c1"># 3. Create an equation using the common numpy/scipy functions/operators</span>
<span class="n">eq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CreateEquation</span><span class="p">(</span><span class="s2">&quot;sum&quot;</span><span class="p">)</span>
<span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">()</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ndarr_V1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">ndarr_V2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># If adouble_array is needed after operations on a numpy array, the following two functions can be used:</span>
<span class="c1">#   a) static function adouble_array.FromList(python_list)</span>
<span class="c1">#   b) static function adouble_array.FromNumpyArray(numpy_array)</span>
<span class="c1"># Both return an adouble_array object.</span>
<span class="n">adarr_V1</span> <span class="o">=</span> <span class="n">adouble_array</span><span class="o">.</span><span class="n">FromNumpyArray</span><span class="p">(</span><span class="n">ndarr_V1</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">adarr_V1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="details-on-autodifferentiation-support">
<h4>6.2.7.5. Details on autodifferentiation support<a class="headerlink" href="#details-on-autodifferentiation-support" title="Permalink to this headline">¶</a></h4>
<p>To calculate a residual and its gradients
the <a class="reference external" href="http://en.wikipedia.org/wiki/Automatic_differentiation#Operator_overloading">operator overloading</a>
technique for <a class="reference external" href="http://en.wikipedia.org/wiki/Automatic_differentiation">automatic differentiation</a>
is applied (<a class="reference external" href="https://projects.coin-or.org/ADOL-C">ADOL-C</a>).
Model equations are stored in a tree-like data structure called <strong>Evaluation Tree</strong>.
Evaluation Trees consist of nodes representing mathematical operators and functions and their operands.
In <strong>DAE Tools</strong> the basic mathematical operators and functions are re-defined to operate on <strong>a modified ADOL-C</strong>
class <a class="reference internal" href="core.html#pyCore.adouble" title="pyCore.adouble"><code class="xref py py-class docutils literal"><span class="pre">adouble</span></code></a> extended with the simulator-specific information.
In addition, all operators/functions accept the <a class="reference internal" href="core.html#pyCore.adouble_array" title="pyCore.adouble_array"><code class="xref py py-class docutils literal"><span class="pre">adouble_array</span></code></a> objects to support operations on arrays.
Once built, Evaluation Trees can be used to calculate equation residuals or derivatives, check units consistency and
export equations into the Latex or MathML format.
For instance, the equation:</p>
<div class="math">
\[\frac{x[0]-x[1]} {x[2]-x[3]} + 1.2 \cdot sin(x[0]) = 0\]</div>
<p>is specified in <strong>DAE Tools</strong> as:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">eq</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">CreateEquation</span><span class="p">(</span><span class="s2">&quot;myEquation&quot;</span><span class="p">)</span>
<span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="n">x</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="o">+</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<p>and represented as the evaluation tree in <a class="reference internal" href="#figure-evaluationtree"><span class="std std-numref">Fig. 6.2</span></a>.</p>
<div class="figure align-center" id="id16" style="width: 420pt">
<span id="figure-evaluationtree"></span><a class="reference internal image-reference" href="_images/evaluation_tree.png"><img alt="_images/evaluation_tree.png" src="_images/evaluation_tree.png" style="width: 400pt;" /></a>
<p class="caption"><span class="caption-number">Fig. 6.2 </span><span class="caption-text">Evaluation Tree</span></p>
</div>
<p>As it has been described in the previous sections, domains, parameters, and variables contain functions
that return <a class="reference internal" href="core.html#pyCore.adouble" title="pyCore.adouble"><code class="xref py py-class docutils literal"><span class="pre">adouble</span></code></a>/<a class="reference internal" href="core.html#pyCore.adouble_array" title="pyCore.adouble_array"><code class="xref py py-class docutils literal"><span class="pre">adouble_array</span></code></a> objects used to construct the
evaluation trees. These functions include functions to get a value of
a parameter/variable (<code class="xref py py-meth docutils literal"><span class="pre">__call__()</span></code>), a time or a partial derivative of a variable
(functions <a class="reference internal" href="core.html#pyCore.dt" title="pyCore.dt"><code class="xref py py-meth docutils literal"><span class="pre">dt()</span></code></a>, <a class="reference internal" href="core.html#pyCore.d" title="pyCore.d"><code class="xref py py-meth docutils literal"><span class="pre">d()</span></code></a>, or <a class="reference internal" href="core.html#pyCore.d2" title="pyCore.d2"><code class="xref py py-meth docutils literal"><span class="pre">d2()</span></code></a>)
or functions to obtain an array of values, time or partial derivatives (<a class="reference internal" href="core.html#pyCore.daeVariable.array" title="pyCore.daeVariable.array"><code class="xref py py-meth docutils literal"><span class="pre">array()</span></code></a>,
<a class="reference internal" href="core.html#pyCore.dt_array" title="pyCore.dt_array"><code class="xref py py-meth docutils literal"><span class="pre">dt_array()</span></code></a>, <a class="reference internal" href="core.html#pyCore.d_array" title="pyCore.d_array"><code class="xref py py-meth docutils literal"><span class="pre">d_array()</span></code></a>, and <a class="reference internal" href="core.html#pyCore.d2_array" title="pyCore.d2_array"><code class="xref py py-meth docutils literal"><span class="pre">d2_array()</span></code></a>).</p>
</div>
<div class="section" id="defining-boundary-conditions">
<h4>6.2.7.6. Defining boundary conditions<a class="headerlink" href="#defining-boundary-conditions" title="Permalink to this headline">¶</a></h4>
<p><strong>DAE tools</strong> in general support all types of boundary conditions such as the Dirichlet, Neumann and Robin.
As an example, a simple heat transfer model is considered:
heat conduction through a very thin rectangular plate.
At one side (at y = 0) the Dirichlet boundary conditions are prescribed (the constant temperature: 500 K)
while at the opposite end the Neumann boundary conditions (the constant flux: <span class="math">\(10^6 {W}/{m^2}\)</span>).
The model is described by a single distributed equation:</p>
<div class="math">
\[\rho c_p {{dT(x,y)} \over {dt}} - k \left( {\partial^2 T(x,y) \over \partial x^2} + {\partial^2 T(x,y) \over \partial y^2} \right) = 0;
\forall x \in [0, nx], \forall y \in (0, ny)\]</div>
<p>specified as:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Notation:</span>
<span class="c1">#  - T is a variable distributed on x and y domains</span>
<span class="c1">#  - rho, k, and cp are parameters</span>
<span class="n">eq</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">CreateEquation</span><span class="p">(</span><span class="s2">&quot;MyEquation&quot;</span><span class="p">)</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">eClosedClosed</span><span class="p">)</span>
<span class="n">dy</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">eOpenOpen</span><span class="p">)</span>
<span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">rho</span><span class="p">()</span> <span class="o">*</span> <span class="n">cp</span><span class="p">()</span> <span class="o">*</span> <span class="n">dt</span><span class="p">(</span><span class="n">T</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span><span class="n">dy</span><span class="p">))</span> <span class="o">-</span> <span class="n">k</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span> <span class="n">d2</span><span class="p">(</span><span class="n">T</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span><span class="n">dy</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">d2</span><span class="p">(</span><span class="n">T</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span><span class="n">dy</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>The equation is distributed on the <cite>y</cite> domain open on both ends; thus, the additional equations
(boundary conditions at <cite>y = 0</cite> and <cite>y = ny-1</cite> points) need to be specified to make the system well posed:</p>
<div class="math">
\[\begin{split}T(x,y) &amp;= 500; \forall x \in [0, nx], y = 0 \\
-k {\partial T(x,y) \over \partial y} &amp;= 10^6; \forall x \in [0, nx], y = ny\end{split}\]</div>
<p>which is in <strong>DAE Tools</strong> given as:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># The Dirichlet boundary conditions at the &quot;bottom edge&quot; :</span>
<span class="n">bceq</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">CreateEquation</span><span class="p">(</span><span class="s2">&quot;Bottom_BC&quot;</span><span class="p">)</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">bceq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">eClosedClosed</span><span class="p">)</span>
<span class="n">dy</span> <span class="o">=</span> <span class="n">bceq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">eLowerBound</span><span class="p">)</span>
<span class="n">bceq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span><span class="n">dy</span><span class="p">)</span> <span class="o">-</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">500</span> <span class="o">*</span> <span class="n">K</span><span class="p">)</span>  <span class="c1"># Constant temperature (500 K)</span>

<span class="c1"># The Neumann boundary conditions at the &quot;top edge&quot;:</span>
<span class="n">bceq</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">CreateEquation</span><span class="p">(</span><span class="s2">&quot;Top_BC&quot;</span><span class="p">)</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">bceq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">eClosedClosed</span><span class="p">)</span>
<span class="n">dy</span> <span class="o">=</span> <span class="n">bceq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">eUpperBound</span><span class="p">)</span>
<span class="n">bceq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="o">-</span> <span class="n">k</span><span class="p">()</span> <span class="o">*</span> <span class="n">d</span><span class="p">(</span><span class="n">T</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span><span class="n">dy</span><span class="p">),</span> <span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">1E6</span> <span class="o">*</span> <span class="n">W</span><span class="o">/</span><span class="n">m</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># Constant flux (1E6 W/m2)</span>
</pre></div>
</div>
</div>
<div class="section" id="making-equations-more-readable">
<h4>6.2.7.7. Making equations more readable<a class="headerlink" href="#making-equations-more-readable" title="Permalink to this headline">¶</a></h4>
<p>Equations residuals can be made more readable by defining some auxiliary functions
(as illustrated in <a class="reference internal" href="tutorials-all.html#tutorial2"><span class="std std-ref">Tutorial 2</span></a>):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">DeclareEquations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">daeModel</span><span class="o">.</span><span class="n">DeclareEquations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1"># Auxiliary functions and objects</span>
    <span class="n">rho</span>     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">()</span>
    <span class="n">Q</span>       <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span>      <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">cp</span>      <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span>    <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
    <span class="n">k</span>       <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span>    <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
    <span class="n">T</span>       <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span>    <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
    <span class="n">dT_dt</span>   <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">dt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span>
    <span class="n">dT_dx</span>   <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span>  <span class="n">d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">eCFDM</span><span class="p">)</span>
    <span class="n">dT_dy</span>   <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span>  <span class="n">d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">eCFDM</span><span class="p">)</span>
    <span class="n">d2T_dx2</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">d2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">eCFDM</span><span class="p">)</span>
    <span class="n">d2T_dy2</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">d2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">eCFDM</span><span class="p">)</span>

    <span class="n">eq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CreateEquation</span><span class="p">(</span><span class="s2">&quot;HeatBalance&quot;</span><span class="p">,</span> <span class="s2">&quot;Heat balance equation valid on the open x and y domains&quot;</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">eOpenOpen</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">eOpenOpen</span><span class="p">)</span>
    <span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">rho</span> <span class="o">*</span> <span class="n">cp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">dT_dt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">k</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">d2T_dx2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">d2T_dy2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span>

    <span class="n">eq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CreateEquation</span><span class="p">(</span><span class="s2">&quot;BC_bottom&quot;</span><span class="p">,</span> <span class="s2">&quot;Neumann boundary conditions at the bottom edge (constant flux)&quot;</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">eOpenOpen</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">eLowerBound</span><span class="p">)</span>
    <span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="o">-</span><span class="n">k</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">dT_dy</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">Q</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">eq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CreateEquation</span><span class="p">(</span><span class="s2">&quot;BC_top&quot;</span><span class="p">,</span> <span class="s2">&quot;Neumann boundary conditions at the top edge (constant flux)&quot;</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">eOpenOpen</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">eUpperBound</span><span class="p">)</span>
    <span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="o">-</span><span class="n">k</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">dT_dy</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">Q</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">eq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CreateEquation</span><span class="p">(</span><span class="s2">&quot;BC_left&quot;</span><span class="p">,</span> <span class="s2">&quot;Neumann boundary conditions at the left edge (insulated)&quot;</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">eLowerBound</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">eClosedClosed</span><span class="p">)</span>
    <span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">dT_dx</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>

    <span class="n">eq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CreateEquation</span><span class="p">(</span><span class="s2">&quot;BC_right&quot;</span><span class="p">,</span> <span class="s2">&quot; Neumann boundary conditions at the right edge (insulated)&quot;</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">eUpperBound</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">eClosedClosed</span><span class="p">)</span>
    <span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">dT_dx</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>Obviously, the heat conduction equation from <a class="reference internal" href="tutorials-all.html#tutorial2"><span class="std std-ref">Tutorial 2</span></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="o">...</span>

<span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">rho</span> <span class="o">*</span> <span class="n">cp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">dT_dt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">k</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">d2T_dx2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">d2T_dy2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span>
</pre></div>
</div>
<p>is much more readable than the same equation from <a class="reference internal" href="tutorials-all.html#tutorial1"><span class="std std-ref">Tutorial 1</span></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="o">...</span>

<span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">()</span> <span class="o">*</span> <span class="n">dt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span> <span class="o">-</span> \
              <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">d2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">eCFDM</span><span class="p">)</span> <span class="o">+</span> <span class="n">d2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">eCFDM</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="state-transition-networks">
<h3>6.2.8. State Transition Networks<a class="headerlink" href="#state-transition-networks" title="Permalink to this headline">¶</a></h3>
<p>Discontinuous equations are equations that take different forms subject to certain conditions.
In <strong>DAE Tools</strong> they are modelled using the concept of State Transition Networks (STN).
State Transition Networks can be:</p>
<ol class="arabic simple">
<li><strong>Reversible</strong> (internally described by <a class="reference internal" href="core.html#pyCore.daeIF" title="pyCore.daeIF"><code class="xref py py-class docutils literal"><span class="pre">daeIF</span></code></a> class)</li>
<li><strong>Irreversible</strong> (internally described by <a class="reference internal" href="core.html#pyCore.daeSTN" title="pyCore.daeSTN"><code class="xref py py-class docutils literal"><span class="pre">daeSTN</span></code></a> class)</li>
</ol>
<p>Every STN consists of two or more states (<a class="reference internal" href="core.html#pyCore.daeState" title="pyCore.daeState"><code class="xref py py-class docutils literal"><span class="pre">daeState</span></code></a> class).
Each state is described by a set of equations and conditions for transitions between states.
<strong>Irreversible</strong> STNs can optionally contain a set of actions to be performed when a specified logical
condition is satisfied.
At any given moment, there is one active state.</p>
<p>For example, a flow of fluid through a pipe is described by three different regimes:</p>
<ul class="simple">
<li><em>Laminar</em>: if Reynolds number is less than 2,100</li>
<li><em>Transient</em>: if Reynolds number is greater than 2,100 and less than 10,000</li>
<li><em>Turbulent</em>: if Reynolds number is greater than 10,000</li>
</ul>
<p>From any of these three states the system can go to any other state.
This type of discontinuities is called a <strong>reversible discontinuity</strong> and constructed using the
<a class="reference internal" href="core.html#pyCore.daeModel.IF" title="pyCore.daeModel.IF"><code class="xref py py-meth docutils literal"><span class="pre">IF()</span></code></a>, <a class="reference internal" href="core.html#pyCore.daeModel.ELSE_IF" title="pyCore.daeModel.ELSE_IF"><code class="xref py py-meth docutils literal"><span class="pre">ELSE_IF()</span></code></a>, <a class="reference internal" href="core.html#pyCore.daeModel.ELSE" title="pyCore.daeModel.ELSE"><code class="xref py py-meth docutils literal"><span class="pre">ELSE()</span></code></a>
and <a class="reference internal" href="core.html#pyCore.daeModel.END_IF" title="pyCore.daeModel.END_IF"><code class="xref py py-meth docutils literal"><span class="pre">END_IF()</span></code></a> functions:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">IF</span><span class="p">(</span><span class="n">Re</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">2100</span><span class="p">)</span>                    <span class="c1"># Laminar flow</span>
<span class="c1">#... (equations go here)</span>

<span class="n">ELSE_IF</span><span class="p">(</span><span class="n">Re</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">2100</span> <span class="o">&amp;</span> <span class="n">Re</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">)</span> <span class="c1"># Transient flow</span>
<span class="c1">#... (equations go here)</span>

<span class="n">ELSE</span><span class="p">()</span>                              <span class="c1"># Turbulent flow</span>
<span class="c1">#... (equations go here)</span>

<span class="n">END_IF</span><span class="p">()</span>
</pre></div>
</div>
<p>The comparison operators operate on <a class="reference internal" href="core.html#pyCore.adouble" title="pyCore.adouble"><code class="xref py py-class docutils literal"><span class="pre">adouble</span></code></a> objects and floating point values.
Units consistency is strictly checked and expressions including plain numbers values
are allowed only if a variable or parameter is dimensionless.
The following expressions are valid:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Notation:</span>
<span class="c1">#  - T is a variable with units: K</span>
<span class="c1">#  - m is a variable with units: kg</span>
<span class="c1">#  - p is a dimensionless parameter</span>

<span class="c1"># T &lt; 0.5 K</span>
<span class="n">T</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">K</span><span class="p">)</span>

<span class="c1"># (T &gt;= 300 K) or (m &lt; 1 kg)</span>
<span class="p">(</span><span class="n">T</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">300</span> <span class="o">*</span> <span class="n">K</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">kg</span><span class="p">))</span>

<span class="c1"># p &lt;= 25.3 (use of the Constant function not necessary)</span>
<span class="n">p</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mf">25.3</span>
</pre></div>
</div>
<p><strong>Reversible discontinuities</strong> can be <strong>symmetrical</strong> and <strong>non-symmetrical</strong>. The above example is <strong>symmetrical</strong>.
<strong>Non-symmetrical</strong> STNs are used to describe the concept of hysteresis.</p>
<p>Discontinuities can also be <strong>irreversible</strong>.
For instance, a CPU and its power dissipation can operate in three operating modes:</p>
<ul class="simple">
<li><strong>Normal</strong> mode<ul>
<li>switch to <strong>Power saving</strong> mode if CPU load is below 5%</li>
<li>switch to <strong>Fried</strong> mode if the temperature is above 110 degrees</li>
</ul>
</li>
<li><strong>Power saving</strong> mode<ul>
<li>switch to <strong>Normal</strong> mode if CPU load is above 5%</li>
<li>switch to <strong>Fried</strong> mode if the temperature is above 110 degrees</li>
</ul>
</li>
<li><strong>Fried</strong> mode<ul>
<li>Damn, no escape from here... go to the nearest shop and buy a new one!
Or, donate some money to DAE Tools project :-)</li>
</ul>
</li>
</ul>
<p>From the <strong>Normal</strong> mode the system can either go to the <strong>Power saving</strong> mode or to the <strong>Fried</strong> mode.
The same stands for the <strong>Power saving</strong> mode: the system can either go to the <strong>Normal</strong> mode or to the <strong>Fried</strong> mode.
However, once the temperature exceeds 110 degrees the CPU dies (let&#8217;s say it is heavily overclocked) and the system
remains in this state permanently.
This type of discontinuities is called an <strong>irreversible discontinuity</strong> and can be described
using <a class="reference internal" href="core.html#pyCore.daeModel.STN" title="pyCore.daeModel.STN"><code class="xref py py-meth docutils literal"><span class="pre">STN()</span></code></a>, <a class="reference internal" href="core.html#pyCore.daeModel.STATE" title="pyCore.daeModel.STATE"><code class="xref py py-meth docutils literal"><span class="pre">STATE()</span></code></a>, <a class="reference internal" href="core.html#pyCore.daeModel.END_STN" title="pyCore.daeModel.END_STN"><code class="xref py py-meth docutils literal"><span class="pre">END_STN()</span></code></a> functions:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">STN</span><span class="p">(</span><span class="s2">&quot;CPU&quot;</span><span class="p">)</span>

<span class="n">STATE</span><span class="p">(</span><span class="s2">&quot;Normal&quot;</span><span class="p">)</span>
<span class="c1">#... (equations go here)</span>
<span class="n">ON_CONDITION</span><span class="p">(</span> <span class="n">CPULoad</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">,</span>       <span class="n">switchToStates</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="s2">&quot;CPU&quot;</span><span class="p">,</span> <span class="s2">&quot;PowerSaving&quot;</span><span class="p">)</span> <span class="p">]</span> <span class="p">)</span>
<span class="n">ON_CONDITION</span><span class="p">(</span> <span class="n">T</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">110</span><span class="o">*</span><span class="n">K</span><span class="p">),</span>  <span class="n">switchToStates</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="s2">&quot;CPU&quot;</span><span class="p">,</span> <span class="s2">&quot;Fried&quot;</span><span class="p">)</span> <span class="p">]</span> <span class="p">)</span>

<span class="n">STATE</span><span class="p">(</span><span class="s2">&quot;PowerSaving&quot;</span><span class="p">)</span>
<span class="c1">#... (equations go here)</span>
<span class="n">ON_CONDITION</span><span class="p">(</span> <span class="n">CPULoad</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mf">0.05</span><span class="p">,</span>      <span class="n">switchToStates</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="s2">&quot;CPU&quot;</span><span class="p">,</span> <span class="s2">&quot;Normal&quot;</span><span class="p">)</span> <span class="p">]</span> <span class="p">)</span>
<span class="n">ON_CONDITION</span><span class="p">(</span> <span class="n">T</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">110</span><span class="o">*</span><span class="n">K</span><span class="p">),</span>  <span class="n">switchToStates</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="s2">&quot;CPU&quot;</span><span class="p">,</span> <span class="s2">&quot;Fried&quot;</span><span class="p">)</span> <span class="p">]</span> <span class="p">)</span>

<span class="n">STATE</span><span class="p">(</span><span class="s2">&quot;Fried&quot;</span><span class="p">)</span>
<span class="c1">#... (equations go here)</span>

<span class="n">END_STN</span><span class="p">()</span>
</pre></div>
</div>
<p>The function <a class="reference internal" href="core.html#pyCore.daeModel.ON_CONDITION" title="pyCore.daeModel.ON_CONDITION"><code class="xref py py-meth docutils literal"><span class="pre">ON_CONDITION()</span></code></a> is used to define actions to be performed
when the specified condition is satisfied. In addition, the function <a class="reference internal" href="core.html#pyCore.daeModel.ON_EVENT" title="pyCore.daeModel.ON_EVENT"><code class="xref py py-meth docutils literal"><span class="pre">ON_EVENT()</span></code></a>
can be used to define actions to be performed when an event is triggered on a specified event port.
Details on how to use <a class="reference internal" href="core.html#pyCore.daeModel.ON_CONDITION" title="pyCore.daeModel.ON_CONDITION"><code class="xref py py-meth docutils literal"><span class="pre">ON_CONDITION()</span></code></a> and <a class="reference internal" href="core.html#pyCore.daeModel.ON_EVENT" title="pyCore.daeModel.ON_EVENT"><code class="xref py py-meth docutils literal"><span class="pre">ON_EVENT()</span></code></a>
functions can be found in the <a class="reference internal" href="#oncondition-actions">OnCondition actions</a> and <a class="reference internal" href="#onevent-actions">OnEvent actions</a> sections, respectively.</p>
<p>More information about state transition networks can be found in <a class="reference internal" href="core.html#pyCore.daeSTN" title="pyCore.daeSTN"><code class="xref py py-class docutils literal"><span class="pre">daeSTN</span></code></a>,
<a class="reference internal" href="core.html#pyCore.daeIF" title="pyCore.daeIF"><code class="xref py py-class docutils literal"><span class="pre">daeIF</span></code></a> and in <a class="reference internal" href="tutorials.html"><span class="doc">Tutorials</span></a>.</p>
</div>
<div class="section" id="oncondition-actions">
<h3>6.2.9. OnCondition actions<a class="headerlink" href="#oncondition-actions" title="Permalink to this headline">¶</a></h3>
<p>The function <a class="reference internal" href="core.html#pyCore.daeModel.ON_CONDITION" title="pyCore.daeModel.ON_CONDITION"><code class="xref py py-meth docutils literal"><span class="pre">ON_CONDITION()</span></code></a> is used to define actions to be performed
when a specified condition is satisfied. The available actions include:</p>
<ul class="simple">
<li>Changing the active state in specified State Transition Networks (argument <cite>switchToStates</cite>)</li>
<li>Re-assigning or re-initialising specified variables (argument <cite>setVariableValues</cite>)</li>
<li>Triggering an event on the specified event ports (argument <cite>triggerEvents</cite>)</li>
<li>Executing user-defined actions (argument <cite>userDefinedActions</cite>)</li>
</ul>
<div class="topic">
<p class="topic-title first">Nota bene</p>
<p>OnCondition actions can be added to models or to states in State Transition Networks
(<a class="reference internal" href="core.html#pyCore.daeSTN" title="pyCore.daeSTN"><code class="xref py py-class docutils literal"><span class="pre">daeSTN</span></code></a> or <a class="reference internal" href="core.html#pyCore.daeIF" title="pyCore.daeIF"><code class="xref py py-class docutils literal"><span class="pre">daeIF</span></code></a>):</p>
<ul class="simple">
<li>When added to a model they remain active throughout the simulation</li>
<li>When added to a state they become active only when the parent state becomes active</li>
</ul>
</div>
<div class="topic">
<p class="topic-title first">Nota bene</p>
<p><cite>switchToStates</cite>,  <cite>setVariableValues</cite>, <cite>triggerEvents</cite> and <cite>userDefinedActions</cite>
are empty by default. The user has to specify at least one action.</p>
</div>
<p>For instance, to execute some actions when the temperature becomes greater than 340 K the following can be used:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">DeclareEquations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="o">...</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">ON_CONDITION</span><span class="p">(</span> <span class="n">T</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">340</span><span class="o">*</span><span class="n">K</span><span class="p">),</span> <span class="n">switchToStates</span>     <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="s1">&#39;STN&#39;</span><span class="p">,</span> <span class="s1">&#39;StateName&#39;</span><span class="p">),</span> <span class="o">...</span> <span class="p">],</span>
                                              <span class="n">setVariableValues</span>  <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">newValue</span><span class="p">),</span> <span class="o">...</span> <span class="p">],</span>
                                              <span class="n">triggerEvents</span>      <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">eventPort</span><span class="p">,</span> <span class="n">eventMessage</span><span class="p">),</span> <span class="o">...</span> <span class="p">],</span>
                                              <span class="n">userDefinedActions</span> <span class="o">=</span> <span class="p">[</span> <span class="n">userDefinedAction</span><span class="p">,</span> <span class="o">...</span> <span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<p>where the first argument of the <a class="reference internal" href="core.html#pyCore.daeModel.ON_CONDITION" title="pyCore.daeModel.ON_CONDITION"><code class="xref py py-meth docutils literal"><span class="pre">ON_CONDITION()</span></code></a> function is a condition
specifying when the actions will be executed and:</p>
<ul class="simple">
<li><cite>switchToStates</cite> is a list of tuples (string &#8216;<em>STN Name</em>&#8216;, string &#8216;<em>State name to activate</em>&#8216;)</li>
<li><cite>setVariableValues</cite> is a list of tuples (<a class="reference internal" href="core.html#pyCore.daeVariable" title="pyCore.daeVariable"><code class="xref py py-class docutils literal"><span class="pre">daeVariable</span></code></a> object, <a class="reference internal" href="core.html#pyCore.adouble" title="pyCore.adouble"><code class="xref py py-class docutils literal"><span class="pre">adouble</span></code></a> object)</li>
<li><cite>triggerEvents</cite> is a list of tuples (<a class="reference internal" href="core.html#pyCore.daeEventPort" title="pyCore.daeEventPort"><code class="xref py py-class docutils literal"><span class="pre">daeEventPort</span></code></a> object, <a class="reference internal" href="core.html#pyCore.adouble" title="pyCore.adouble"><code class="xref py py-class docutils literal"><span class="pre">adouble</span></code></a> object)</li>
<li><cite>userDefinedActions</cite> is a list of user defined objects derived from the base <a class="reference internal" href="core.html#pyCore.daeAction" title="pyCore.daeAction"><code class="xref py py-class docutils literal"><span class="pre">daeAction</span></code></a> class</li>
</ul>
<p>More details on how to use <a class="reference internal" href="core.html#pyCore.daeModel.ON_CONDITION" title="pyCore.daeModel.ON_CONDITION"><code class="xref py py-meth docutils literal"><span class="pre">ON_CONDITION()</span></code></a> function can be found in <a class="reference internal" href="tutorials-all.html#tutorial13"><span class="std std-ref">Tutorial 13</span></a>.</p>
</div>
<div class="section" id="onevent-actions">
<h3>6.2.10. OnEvent actions<a class="headerlink" href="#onevent-actions" title="Permalink to this headline">¶</a></h3>
<p>The function <a class="reference internal" href="core.html#pyCore.daeModel.ON_EVENT" title="pyCore.daeModel.ON_EVENT"><code class="xref py py-meth docutils literal"><span class="pre">ON_EVENT()</span></code></a> is used to define actions to be performed
when an event is triggered on the specified event port. The same type of actions are available as
in the <a class="reference internal" href="core.html#pyCore.daeModel.ON_CONDITION" title="pyCore.daeModel.ON_CONDITION"><code class="xref py py-meth docutils literal"><span class="pre">ON_CONDITION()</span></code></a> function.</p>
<div class="topic">
<p class="topic-title first">Nota bene</p>
<p>OnEvent actions can be added to models or to states in State Transition Networks
(<a class="reference internal" href="core.html#pyCore.daeSTN" title="pyCore.daeSTN"><code class="xref py py-class docutils literal"><span class="pre">daeSTN</span></code></a> or <a class="reference internal" href="core.html#pyCore.daeIF" title="pyCore.daeIF"><code class="xref py py-class docutils literal"><span class="pre">daeIF</span></code></a>):</p>
<ul class="simple">
<li>When added to a model they remain active throughout the simulation</li>
<li>When added to a state they become active only when the parent state becomes active</li>
</ul>
</div>
<div class="topic">
<p class="topic-title first">Nota bene</p>
<p><cite>switchToStates</cite>,  <cite>setVariableValues</cite>, <cite>triggerEvents</cite> and <cite>userDefinedActions</cite>
are empty by default. The user has to specify at least one action.</p>
</div>
<p>For instance, to execute some actions when an event is triggered on an event port the following can be used:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">DeclareEquations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="o">...</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">ON_EVENT</span><span class="p">(</span> <span class="n">eventPort</span><span class="p">,</span> <span class="n">switchToStates</span>     <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="s1">&#39;STN&#39;</span><span class="p">,</span> <span class="s1">&#39;StateName&#39;</span><span class="p">),</span> <span class="o">...</span> <span class="p">],</span>
                              <span class="n">setVariableValues</span>  <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">newValue</span><span class="p">),</span> <span class="o">...</span> <span class="p">],</span>
                              <span class="n">triggerEvents</span>      <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">eventPort</span><span class="p">,</span> <span class="n">eventMessage</span><span class="p">),</span> <span class="o">...</span> <span class="p">],</span>
                              <span class="n">userDefinedActions</span> <span class="o">=</span> <span class="p">[</span> <span class="n">userDefinedAction</span><span class="p">,</span> <span class="o">...</span> <span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<p>where the first argument of the <a class="reference internal" href="core.html#pyCore.daeModel.ON_EVENT" title="pyCore.daeModel.ON_EVENT"><code class="xref py py-meth docutils literal"><span class="pre">ON_EVENT()</span></code></a> function is the
<a class="reference internal" href="core.html#pyCore.daeEventPort" title="pyCore.daeEventPort"><code class="xref py py-class docutils literal"><span class="pre">daeEventPort</span></code></a> object to be monitored for events, while the rest of the arguments
is the same as in the <a class="reference internal" href="core.html#pyCore.daeModel.ON_CONDITION" title="pyCore.daeModel.ON_CONDITION"><code class="xref py py-meth docutils literal"><span class="pre">ON_CONDITION()</span></code></a> function.</p>
<p>More details on how to use <a class="reference internal" href="core.html#pyCore.daeModel.ON_EVENT" title="pyCore.daeModel.ON_EVENT"><code class="xref py py-meth docutils literal"><span class="pre">ON_EVENT()</span></code></a> function can be found in <a class="reference internal" href="tutorials-all.html#tutorial13"><span class="std std-ref">Tutorial 13</span></a>.</p>
</div>
<div class="section" id="user-defined-actions">
<h3>6.2.11. User-defined actions<a class="headerlink" href="#user-defined-actions" title="Permalink to this headline">¶</a></h3>
<p>User-defined actions are executed in a response to a specified condition in <cite>OnCondition</cite> handlers
or in a response to an event triggered in <cite>OnEvent</cite> handlers.</p>
<p>They are created by deriving a class from the <a class="reference internal" href="core.html#pyCore.daeAction" title="pyCore.daeAction"><code class="xref py py-class docutils literal"><span class="pre">daeAction</span></code></a> base
and implementing the <code class="xref py py-meth docutils literal"><span class="pre">Execute()</span></code> function.
The <code class="xref py py-meth docutils literal"><span class="pre">Execute()</span></code> function takes no arguments. If some
information from the model is required they should be specified in the constructor.</p>
<p>User-defined actions do not return a value and should not change the values of variables
(other types of actions must be used for that purpose), but perform some user-defined operations.
The source code for a simple action that prints a message with the data sent to a specified event port is given below:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># User-defined action executed when an event is triggered on a specified event port.</span>
<span class="k">class</span> <span class="nc">simpleUserAction</span><span class="p">(</span><span class="n">daeAction</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eventPort</span><span class="p">):</span>
        <span class="n">daeAction</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Store the daeEventPort object for later use.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eventPort</span> <span class="o">=</span> <span class="n">eventPort</span>

    <span class="k">def</span> <span class="nf">Execute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># The floating point value of the data sent when the event is triggered</span>
        <span class="c1"># can be retrieved using the daeEventPort.EventData property.</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;simpleUserAction executed; input data = </span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">eventPort</span><span class="o">.</span><span class="n">EventData</span>

        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;********************************************************&#39;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;********************************************************&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title first">Notate bene</p>
<p>User-defined action objects <strong>should</strong> be instantiated in the <a class="reference internal" href="core.html#pyCore.daeModel.DeclareEquations" title="pyCore.daeModel.DeclareEquations"><code class="xref py py-meth docutils literal"><span class="pre">DeclareEquations()</span></code></a>
function if they access parameters&#8217; and variables&#8217; symbolic representations (available only there).</p>
<p>User-defined action objects <strong>must</strong> be stored in the model, otherwise they will get destroyed when
they go out of scope.</p>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">DeclareEquations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="o">...</span>

    <span class="c1"># User-defined action objects should be stored in the model, otherwise</span>
    <span class="c1"># they will get destroyed when they go out of scope.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">action</span> <span class="o">=</span> <span class="n">simpleUserAction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eventPort</span><span class="p">)</span>

    <span class="c1"># The actions executed when the event on the inlet &#39;eventPort&#39; event port is received.</span>
    <span class="c1"># daeEventPort defines the operator() which returns adouble object that can be used</span>
    <span class="c1"># at the moment when the action is executed to get the value of the event data.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ON_EVENT</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eventPort</span><span class="p">,</span> <span class="n">userDefinedActions</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">action</span><span class="p">])</span>
</pre></div>
</div>
<p>More details on how to use user-defined actions can be found in <a class="reference internal" href="tutorials-all.html#tutorial13"><span class="std std-ref">Tutorial 13</span></a>.</p>
</div>
<div class="section" id="external-functions">
<h3>6.2.12. External functions<a class="headerlink" href="#external-functions" title="Permalink to this headline">¶</a></h3>
<p>The concept of external functions in <strong>DAE Tools</strong> is used to handle and evaluate user-defined functions or
functions from external libraries. External functions can return scalar
(<a class="reference internal" href="core.html#pyCore.daeScalarExternalFunction" title="pyCore.daeScalarExternalFunction"><code class="xref py py-class docutils literal"><span class="pre">daeScalarExternalFunction</span></code></a>) or vector (<a class="reference internal" href="core.html#pyCore.daeVectorExternalFunction" title="pyCore.daeVectorExternalFunction"><code class="xref py py-class docutils literal"><span class="pre">daeVectorExternalFunction</span></code></a>) values.</p>
<div class="topic">
<p class="topic-title first">Nota bene</p>
<p>The vector external functions are not implemented at the moment.</p>
</div>
<p>External functions are created by deriving a class from the <a class="reference internal" href="core.html#pyCore.daeScalarExternalFunction" title="pyCore.daeScalarExternalFunction"><code class="xref py py-class docutils literal"><span class="pre">daeScalarExternalFunction</span></code></a> base,
specifying its arguments in the constructor and implementing the <a class="reference internal" href="core.html#pyCore.daeScalarExternalFunction.Calculate" title="pyCore.daeScalarExternalFunction.Calculate"><code class="xref py py-meth docutils literal"><span class="pre">Calculate()</span></code></a> function.
The source code for a simple <span class="math">\(F(x) = x ^ 2\)</span> external function is given below:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">F</span><span class="p">(</span><span class="n">daeScalarExternalFunction</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Name</span><span class="p">,</span> <span class="n">parentModel</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># Instantiate the scalar external function by specifying</span>
        <span class="c1"># the dictionary with arguments {&#39;name&#39; : adouble-object}</span>
        <span class="n">arguments</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">arguments</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span>  <span class="o">=</span> <span class="n">x</span>

        <span class="n">daeScalarExternalFunction</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Name</span><span class="p">,</span> <span class="n">parentModel</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="n">arguments</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Calculate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="c1"># Calculate function is used to calculate a value and a derivative of the external</span>
        <span class="c1"># function per given argument (if requested). Here, a simple function is given by:</span>
        <span class="c1">#    F(x) = x**2</span>

        <span class="c1"># Procedure:</span>
        <span class="c1"># 1. Get the arguments from the dictionary &#39;values&#39;: {&#39;arg-name&#39; : adouble-object}.</span>
        <span class="c1">#    Every adouble object has two properties: Value and Derivative that can be</span>
        <span class="c1">#    used to evaluate function or its partial derivatives per arguments</span>
        <span class="c1">#    (partial derivatives are used to fill in a Jacobian matrix necessary to solve</span>
        <span class="c1">#    a system of non-linear equations using the Newton method).</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span>

        <span class="c1"># 2. Always calculate the value of a function (the derivative is zero by default).</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">adouble</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">Value</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># 3. If a function derivative per one of its arguments is requested,</span>
        <span class="c1">#    the derivative part of that argument will be non-zero.</span>
        <span class="c1">#    In that case, investigate which derivative is requested and calculate it</span>
        <span class="c1">#    using the chain rule: f&#39;(x) = x&#39; * df(x)/dx</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">Derivative</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># A derivative per &#39;x&#39; was requested; its value is: x&#39; * 2x</span>
            <span class="n">res</span><span class="o">.</span><span class="n">Derivative</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">Derivative</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">Value</span><span class="p">)</span>

        <span class="c1"># 4. Return the result as a adouble object (contains both a value and a derivative)</span>
        <span class="k">return</span> <span class="n">res</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title first">Notate bene</p>
<p>External function objects <strong>must</strong> be instantiated in the <a class="reference internal" href="core.html#pyCore.daeModel.DeclareEquations" title="pyCore.daeModel.DeclareEquations"><code class="xref py py-meth docutils literal"><span class="pre">DeclareEquations()</span></code></a>
function since they access parameters&#8217; and variables&#8217; symbolic representations (available only there).</p>
<p>External function objects <strong>must</strong> be stored in the model, otherwise they will get destroyed when
they go out of scope.</p>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">DeclareEquations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="o">...</span>

    <span class="c1"># Create external function (it has to be created in DeclareEquations!),</span>
    <span class="c1"># specify its units (here for simplicity dimensionless) and</span>
    <span class="c1"># arguments (here only a single argument: x)</span>
    <span class="c1"># External function objects should be stored in the model, otherwise</span>
    <span class="c1"># they will get destroyed when they go out of scope.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">F</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">())</span>

    <span class="c1"># External function can now be used in daetools equations.</span>
    <span class="c1"># Its value can be obtained using the operator() (python special function __call__)</span>
    <span class="n">eq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CreateEquation</span><span class="p">(</span><span class="s2">&quot;...&quot;</span><span class="p">,</span> <span class="s2">&quot;...&quot;</span><span class="p">)</span>
    <span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="o">...</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">()</span> <span class="o">...</span>
</pre></div>
</div>
<p>A more complex example is given in the <a class="reference internal" href="tutorials-all.html#tutorial14"><span class="std std-ref">Tutorial 14</span></a>. There, the external function concept is used to interpolate
a set of values using the <code class="xref py py-class docutils literal"><span class="pre">scipy.interpolate.interp1d</span></code> object.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">extfn_interp1d</span><span class="p">(</span><span class="n">daeScalarExternalFunction</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Name</span><span class="p">,</span> <span class="n">parentModel</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">Time</span><span class="p">):</span>
        <span class="n">arguments</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">arguments</span><span class="p">[</span><span class="s2">&quot;t&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Time</span>

        <span class="c1"># Instantiate interp1d object and initialise interpolation using supplied (time,y) values.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interp</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

        <span class="c1"># During the solver iterations, the function is called very often with the same arguments.</span>
        <span class="c1"># Therefore, cache the last interpolated value to speed up a simulation.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="n">daeScalarExternalFunction</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Name</span><span class="p">,</span> <span class="n">parentModel</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="n">arguments</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Calculate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="c1"># Get the argument from the dictionary of arguments&#39; values.</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="s2">&quot;t&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">Value</span>

        <span class="c1"># Here we do not need to return a derivative for it is not a function of variables.</span>

        <span class="c1"># First check if an interpolated value was already calculated during the previous call.</span>
        <span class="c1"># If it was, return the cached value (the derivative part is always equal to zero in this case).</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">time</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">adouble</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># The time received is not in the cache and has to be interpolated.</span>
        <span class="c1"># Convert the result to float datatype since daetools can&#39;t accept</span>
        <span class="c1"># numpy.float64 types as arguments at the moment.</span>
        <span class="n">interp_value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">time</span><span class="p">))</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">adouble</span><span class="p">(</span><span class="n">interp_value</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Save it in the cache for later use.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">Value</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span>
</pre></div>
</div>
<p>The <cite>extfn_interp1d</cite> class is used here to approximate some function <em>f</em>:</p>
<div class="math">
\[y = f(t) = 2t\]</div>
<p>using its <cite>t</cite> ad <cite>y</cite> values:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">DeclareEquations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="o">...</span>

    <span class="c1"># Create scipy.interp1d interpolation external function.</span>
    <span class="c1"># Create &#39;times&#39; and &#39;values&#39; arrays to be used for interpolation:</span>
    <span class="n">times</span>  <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1000.0</span><span class="p">)</span>
    <span class="n">values</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">times</span>
    <span class="c1"># The external function accepts only a single argument: the current time in the simulation</span>
    <span class="c1"># that can be obtained using the Time() daetools function.</span>
    <span class="c1"># The external function units are seconds.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">interp1d</span> <span class="o">=</span> <span class="n">extfn_interp1d</span><span class="p">(</span><span class="s2">&quot;interp1d&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">Time</span><span class="p">())</span>
</pre></div>
</div>
<p>Alternatively, DAE Tools can utilise functions defined in shared libraries via <code class="xref py py-class docutils literal"><span class="pre">daeCTypesExternalFunction</span></code> class.
As an argument it accepts a function pointer from libraries loaded using Python <cite>ctypes</cite>.
Sample usage can be found in the <a class="reference internal" href="tutorials-all.html#tutorial14"><span class="std std-ref">Tutorial 14</span></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">DeclareEquations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="o">...</span>

    <span class="c1"># Load the library:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ext_lib</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">CDLL</span><span class="p">(</span><span class="s2">&quot;libheat_function.so&quot;</span><span class="p">)</span>

    <span class="c1"># Function arguments:</span>
    <span class="n">arguments</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">arguments</span><span class="p">[</span><span class="s1">&#39;m&#39;</span><span class="p">]</span>     <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">()</span>
    <span class="n">arguments</span><span class="p">[</span><span class="s1">&#39;cp&#39;</span><span class="p">]</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cp</span><span class="p">()</span>
    <span class="n">arguments</span><span class="p">[</span><span class="s1">&#39;dT/dt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">())</span>

    <span class="c1"># Function pointer (&#39;calculate&#39; function is used):</span>
    <span class="n">function_ptr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ext_lib</span><span class="o">.</span><span class="n">calculate</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">exfnHeat2</span> <span class="o">=</span> <span class="n">daeCTypesExternalFunction</span><span class="p">(</span><span class="s2">&quot;heat_function&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">function_ptr</span><span class="p">,</span> <span class="n">arguments</span><span class="p">)</span>
</pre></div>
</div>
<p>The <cite>calculate</cite> function is defined in the <cite>heat_function</cite> c shared library:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>

<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">Value</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">Derivative</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">adouble_c</span><span class="p">;</span>

<span class="cp">#if defined(_WIN32) || defined(WIN32) || defined(WIN64) || defined(_WIN64)</span>
<span class="cp">#define DLLEXPORT  extern &quot;C&quot; __declspec(dllexport)</span>
<span class="cp">#else</span>
<span class="cp">#define DLLEXPORT</span>
<span class="cp">#endif</span>

<span class="n">DLLEXPORT</span> <span class="n">adouble_c</span> <span class="nf">calculate</span><span class="p">(</span><span class="k">const</span> <span class="n">adouble_c</span> <span class="n">values</span><span class="p">[],</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">names</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">no_arguments</span><span class="p">);</span>

<span class="n">adouble_c</span> <span class="nf">calculate</span><span class="p">(</span><span class="k">const</span> <span class="n">adouble_c</span> <span class="n">values</span><span class="p">[],</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">names</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">no_arguments</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">adouble_c</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">result</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">adouble_c</span><span class="p">));</span>

    <span class="cm">/* Get the arguments&#39; values. */</span>
    <span class="n">adouble_c</span> <span class="n">m</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">dT_dt</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">no_arguments</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">&quot;m&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">&quot;cp&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">cp</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">&quot;dT/dt&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">dT_dt</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="cm">/* Calculate the value. */</span>
    <span class="n">result</span><span class="p">.</span><span class="n">Value</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">Value</span> <span class="o">*</span> <span class="n">cp</span><span class="p">.</span><span class="n">Value</span> <span class="o">*</span> <span class="n">dT_dt</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span>

    <span class="cm">/* Calculate the derivative. */</span>
    <span class="k">if</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">Derivative</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="cm">/* A derivative per &#39;m&#39; was requested */</span>
        <span class="n">result</span><span class="p">.</span><span class="n">Derivative</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">Derivative</span> <span class="o">*</span> <span class="p">(</span><span class="n">cp</span><span class="p">.</span><span class="n">Value</span> <span class="o">*</span> <span class="n">dT_dt</span><span class="p">.</span><span class="n">Value</span><span class="p">);</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">cp</span><span class="p">.</span><span class="n">Derivative</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="cm">/* A derivative per &#39;cp&#39; was requested */</span>
        <span class="n">result</span><span class="p">.</span><span class="n">Derivative</span> <span class="o">=</span> <span class="n">cp</span><span class="p">.</span><span class="n">Derivative</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">Value</span> <span class="o">*</span> <span class="n">dT_dt</span><span class="p">.</span><span class="n">Value</span><span class="p">);</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">dT_dt</span><span class="p">.</span><span class="n">Derivative</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="cm">/* A derivative per &#39;dT_dt&#39; was requested */</span>
        <span class="n">result</span><span class="p">.</span><span class="n">Derivative</span> <span class="o">=</span> <span class="n">dT_dt</span><span class="p">.</span><span class="n">Derivative</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">Value</span> <span class="o">*</span> <span class="n">cp</span><span class="p">.</span><span class="n">Value</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The library can be compiled using the following commands:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="c1"># GNU/Linux gcc:</span>
gcc -fPIC -shared -o libheat_function.so tutorial4_heat_function.c

<span class="c1"># macOS gcc:</span>
gcc -fPIC -dynamiclib -o libheat_function.dylib tutorial14_heat_function.c

<span class="c1"># Windows vc++:</span>
cl /LD tutorial14_heat_function.c /link /dll /out:heat_function.dll
</pre></div>
</div>
</div>
</div>
<div class="section" id="numerical-methods-for-partial-differential-equations">
<h2>6.3. Numerical Methods for Partial Differential Equations<a class="headerlink" href="#numerical-methods-for-partial-differential-equations" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-finite-difference-method">
<h3>6.3.1. The Finite Difference Method<a class="headerlink" href="#the-finite-difference-method" title="Permalink to this headline">¶</a></h3>
<p>DAE Tools support numerical simulation of partial differential equations on
structured grids using the Finite Difference Method.
Three different methods are provided:</p>
<ul class="simple">
<li>Backward Finite Difference method (eBFDM)</li>
<li>Forward Finite Difference method (eFFDM)</li>
<li>Center Finite Difference method (eCFDM)</li>
</ul>
<p>The partial derivatives of the first and second order can be specified using the functions
<a class="reference internal" href="core.html#pyCore.d" title="pyCore.d"><code class="xref py py-meth docutils literal"><span class="pre">d()</span></code></a> and <a class="reference internal" href="core.html#pyCore.d2" title="pyCore.d2"><code class="xref py py-meth docutils literal"><span class="pre">d2()</span></code></a>.</p>
<p>As an illustration, the 1D convection-diffusion-reaction equation:</p>
<div class="math">
\[\begin{split}{\partial c \over \partial t} + u {\partial c \over \partial x} - D {\partial^2 c \over \partial x^2} &amp;= s(x), \forall x \in \left( 0,L \right] \\
c(0) &amp;= 0.0\end{split}\]</div>
<p>can be specified using the Center Finite Difference Method:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">modTutorial</span><span class="p">(</span><span class="n">daeModel</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">DeclareEquations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">daeModel</span><span class="o">.</span><span class="n">DeclareEquations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Notation:</span>
        <span class="c1">#  - c is a state variable</span>
        <span class="c1">#  - x is a domain object</span>
        <span class="c1">#  - u is velocity</span>

        <span class="c1"># Declare some auxiliary functions to make equations more readable</span>
        <span class="n">c</span>       <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">dc_dt</span>   <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">dt</span><span class="p">(</span><span class="n">c</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">dc_dx</span>   <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">d</span> <span class="p">(</span><span class="n">c</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">eCFDM</span><span class="p">)</span>
        <span class="n">d2c_dx2</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">d2</span><span class="p">(</span><span class="n">c</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">eCFDM</span><span class="p">)</span>
        <span class="n">s</span>       <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">c</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

        <span class="c1"># Declare the Convection-Diffusion-Reaction equation distributed on (0, L]:</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CreateEquation</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">)</span>
        <span class="n">eq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">eOpenClosed</span><span class="p">)</span>
        <span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">dc_dt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">u</span> <span class="o">*</span> <span class="n">dc_dx</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">D</span> <span class="o">*</span> <span class="n">d2c_dx2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># Boundary conditions at x = 0:</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CreateEquation</span><span class="p">(</span><span class="s2">&quot;c(0)&quot;</span><span class="p">)</span>
        <span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">c</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.0</span>
</pre></div>
</div>
</div>
<div class="section" id="the-finite-volume-method">
<h3>6.3.2. The Finite Volume Method<a class="headerlink" href="#the-finite-volume-method" title="Permalink to this headline">¶</a></h3>
<p>DAE Tools support numerical simulation of partial differential equations on
1D structured grids using the Finite Volume Method (high-resolution upwind scheme with flux limiter).</p>
<p>Consider the 1D convection-diffusion-reaction equation:</p>
<div class="math">
\[{\partial c \over \partial t} + u {\partial c \over \partial x} - D {\partial^2 c \over \partial x^2} = s(x)\]</div>
<p>A cell-centered finite-volume discretisation yields the semi-discrete equation <a class="footnote-reference" href="#koren" id="id1">[1]</a> <a class="footnote-reference" href="#koren2" id="id2">[2]</a>:</p>
<div class="math">
\[\int_{\Omega_i} {\partial c_i \over \partial t} dx + u \left[ c_{i + {1 \over 2}} - c_{i - {1 \over 2}} \right] - D \left[ \left( \partial c \over \partial x \right)_{i + {1 \over 2}} - \left( \partial c \over \partial x \right)_{i - {1 \over 2}} \right] = \int_{\Omega_i} s_i dx\]</div>
<p>where the half-integer indices refer to cell faces <span class="math">\(\delta\Omega_{i-{1 \over 2}}\)</span> and <span class="math">\(\delta\Omega_{i+{1 \over 2}}\)</span>
between cell centers <span class="math">\(\Omega_{i-1}\)</span> and <span class="math">\(\Omega_i\)</span> as presented in the figure below:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/cell-centerred_finite-volume-discretisation-domain-x.png"><img alt="_images/cell-centerred_finite-volume-discretisation-domain-x.png" src="_images/cell-centerred_finite-volume-discretisation-domain-x.png" style="width: 200pt;" /></a>
</div>
<p>The accuracy of the above finite volume discretisation is determined by the way in which the cell-face fluxes are computed.
Applying the high-resolution upwind scheme with flux limiter <a class="footnote-reference" href="#koren" id="id3">[1]</a> <a class="footnote-reference" href="#koren2" id="id4">[2]</a> for the cell-face state <span class="math">\(c_{i+{1 \over 2}}\)</span> results
in the following equation:</p>
<div class="math">
\[{c}_{i + {1 \over 2}} = c_i  + \phi \left( r_{i + {1 \over 2}} \right) \left( c_i - c_{i-1}  \right)\]</div>
<p>where <span class="math">\(\phi\)</span> is the flux limiter function and <span class="math">\(r_{i + {1 \over 2}}\)</span> the upwind ratio of consecutive solution gradients:</p>
<div class="math">
\[r_{i + {1 \over 2}} = {{c_{i+1} - c_{i} + \epsilon} \over {c_{i} - c_{i-1} + \epsilon}}\]</div>
<p>There is a large number of flux limiters <a class="footnote-reference" href="#fluxlimiters" id="id5">[3]</a> implemented in <strong>DAE Tools</strong>:</p>
<ul>
<li><p class="first">CHARM [not 2nd order TVD] (Zhou, 1995):</p>
<p><span class="math">\(\phi(r)= \begin{cases} \frac{r\left(3r+1\right)}{\left(r+1\right)^{2}} &amp; r&gt;0, \lim_{r \rightarrow \infty} \phi(r)=3 \\ 0 &amp; otherwise \end{cases}\)</span></p>
</li>
<li><p class="first">HCUS (not 2nd order TVD) (Waterson and Deconinck, 1995):</p>
<p><span class="math">\(\phi(r) =  \frac{ 1.5 \left(r+\left| r \right| \right)}{ \left(r+2 \right)} , \lim_{r \rightarrow \infty}\phi_{hc}(r) = 3\)</span></p>
</li>
<li><p class="first">HQUICK (not 2nd order TVD) (Waterson and Deconinck, 1995):</p>
<p><span class="math">\(\phi(r) =  \frac{2 \left(r + \left|r \right| \right)}{ \left(r+3 \right)}, \lim_{r \rightarrow \infty}\phi_{hq}(r) = 4\)</span></p>
</li>
<li><p class="first">Koren (Koren, 1993):</p>
<p><span class="math">\(\phi(r) = \max \left[ 0, \min \left(2 r, \left(2 + r \right)/3, 2 \right) \right], \lim_{r \rightarrow \infty}\phi(r) = 2\)</span></p>
</li>
<li><p class="first">minmod - symmetric (Philip and Roe, 1986):</p>
<p><span class="math">\(\phi (r) = \max \left[ 0 , \min \left( 1 , r \right) \right], \lim_{r \rightarrow \infty}\phi(r) = 1\)</span></p>
</li>
<li><p class="first">monotonized central (MC) – symmetric (van Leer, 1977):</p>
<p><span class="math">\(\phi (r) = \max \left[ 0 , \min \left( 2 r, 0.5 (1+r), 2 \right) \right] , \lim_{r \rightarrow \infty}\phi(r) = 2\)</span></p>
</li>
<li><p class="first">Osher (Chatkravathy and Osher, 1983):</p>
<p><span class="math">\(\phi (r) = \max \left[ 0 , \min \left( r, \beta \right) \right], \left(1 \leq \beta \leq 2 \right), \lim_{r \rightarrow \infty}\phi (r) = \beta\)</span></p>
</li>
<li><p class="first">ospre - symmetric (Waterson and Deconinck, 1995):</p>
<p><span class="math">\(\phi (r) = \frac{1.5 \left(r^2 + r  \right) }{\left(r^2 + r +1 \right)} , \lim_{r \rightarrow \infty}\phi (r) = 1.5\)</span></p>
</li>
<li><p class="first">smart (not 2nd order TVD) (Gaskell and Lau, 1988):</p>
<p><span class="math">\(\phi(r) = \max \left[ 0, \min \left(2 r, \left(0.25 + 0.75 r \right), 4 \right)  \right], \lim_{r \rightarrow \infty}\phi(r) = 4\)</span></p>
</li>
<li><p class="first">superbee – symmetric (Roe, 1986):</p>
<p><span class="math">\(\phi (r) = \max \left[ 0, \min \left( 2 r , 1 \right), \min \left( r, 2 \right) \right] , \lim_{r \rightarrow \infty}\phi (r) = 2\)</span></p>
</li>
<li><p class="first">Sweby – symmetric (Sweby, 1984):</p>
<p><span class="math">\(\phi (r) = \max \left[ 0 , \min \left( \beta r, 1 \right), \min \left( r, \beta \right) \right],  \left(1 \leq \beta \leq 2 \right), \lim_{r \rightarrow \infty}\phi (r) = \beta\)</span></p>
</li>
<li><p class="first">UMIST (Lien and Leschziner, 1994):</p>
<p><span class="math">\(\phi(r) = \max \left[ 0, \min \left(2 r, \left(0.25 + 0.75 r \right),  \left(0.75 + 0.25 r \right), 2 \right)  \right] , \lim_{r \rightarrow \infty}\phi(r) = 2\)</span></p>
</li>
<li><p class="first">van Albada 1 - symmetric (van Albada, et al., 1982):</p>
<p><span class="math">\(\phi (r) = \frac{r^2 + r}{r^2 + 1 } , \lim_{r \rightarrow \infty}\phi (r) = 1\)</span></p>
</li>
<li><p class="first">van Albada 2 : alternative form (not 2nd order TVD; Kermani, 2003)</p>
<p><span class="math">\(\phi (r) = \frac{2 r}{r^2 + 1}, \lim_{r \rightarrow \infty}\phi(r) = 0\)</span></p>
</li>
<li><p class="first">van Leer - symmetric (van Leer, 1974):</p>
<p><span class="math">\(\phi (r) = \frac{r + \left| r \right| }{1 +  \left| r \right| } , \lim_{r \rightarrow \infty}\phi (r) = 2\)</span></p>
</li>
</ul>
<p>For the diffusive flux, the gradient <span class="math">\(\left( \partial c \over \partial x \right)_{i + {1 \over 2}}\)</span>
is evaluated using the standard second-order accurate central difference formula:</p>
<div class="math">
\[\left( \partial c \over \partial x \right)_{i + {1 \over 2}} = {{c_{i+1} - c_i} \over h}\]</div>
<p>except at the inflow and outflow boundaries where:</p>
<div class="math">
\[\begin{split}\left( \partial c \over \partial x \right)_{{1 \over 2}} &amp;= {{-8c_{1 \over 2} + 9c_1 - c_2} \over 3h} \\
\left( \partial c \over \partial x \right)_{n + {1 \over 2}} &amp;= {{8c_{n + {1 \over 2}} - 9c_n + c_{n-1}} \over 3h}\end{split}\]</div>
<p>The above convection-diffusion-reaction equation can be specified using the <a class="reference internal" href="hr_upwind_scheme.html#daetools.pyDAE.hr_upwind_scheme.daeHRUpwindSchemeEquation" title="daetools.pyDAE.hr_upwind_scheme.daeHRUpwindSchemeEquation"><code class="xref py py-class docutils literal"><span class="pre">daeHRUpwindSchemeEquation</span></code></a> class
with the following functions:</p>
<ul>
<li><p class="first">Accumulation term in the cell-centered finite-volume discretisation: <a class="reference internal" href="hr_upwind_scheme.html#daetools.pyDAE.hr_upwind_scheme.daeHRUpwindSchemeEquation.dc_dt" title="daetools.pyDAE.hr_upwind_scheme.daeHRUpwindSchemeEquation.dc_dt"><code class="xref py py-meth docutils literal"><span class="pre">dc_dt()</span></code></a>:</p>
<p><span class="math">\(dc\_dt(i) = \int_{\Omega_i} {\partial c_i \over \partial t} dx\)</span></p>
</li>
<li><p class="first">Convection term in the cell-centered finite-volume discretisation: <a class="reference internal" href="hr_upwind_scheme.html#daetools.pyDAE.hr_upwind_scheme.daeHRUpwindSchemeEquation.dc_dx" title="daetools.pyDAE.hr_upwind_scheme.daeHRUpwindSchemeEquation.dc_dx"><code class="xref py py-meth docutils literal"><span class="pre">dc_dx()</span></code></a>
(may contain the <span class="math">\(\mathbf{S} = {1 \over u} \int_{\Omega_i} s(x) dx\)</span> integral for the consistent discretisation
of the convection and the source terms):</p>
<p><span class="math">\(dc\_dx(i) = c_{i + {1 \over 2}} - c_{i - {1 \over 2}}\)</span></p>
<p>or (if the source integral <span class="math">\(\mathbf{S}\)</span> has been specified):</p>
<p><span class="math">\(dc\_dx(i) = \left( c_{i + {1 \over 2}} - \mathbf{S}_{i + {1 \over 2}} \right) - \left( c_{i - {1 \over 2}} - \mathbf{S}_{i - {1 \over 2}} \right)\)</span></p>
</li>
<li><p class="first">Diffusion term in the cell-centered finite-volume discretisation: <a class="reference internal" href="hr_upwind_scheme.html#daetools.pyDAE.hr_upwind_scheme.daeHRUpwindSchemeEquation.d2c_dx2" title="daetools.pyDAE.hr_upwind_scheme.daeHRUpwindSchemeEquation.d2c_dx2"><code class="xref py py-meth docutils literal"><span class="pre">d2c_dx2()</span></code></a>:</p>
<p><span class="math">\(d2c\_dx2(i) = \left( \partial c \over \partial x \right)_{i + {1 \over 2}} - \left( \partial c \over \partial x \right)_{i - {1 \over 2}}\)</span></p>
</li>
<li><p class="first">Source term in the cell-centered finite-volume discretisation: <a class="reference internal" href="hr_upwind_scheme.html#daetools.pyDAE.hr_upwind_scheme.daeHRUpwindSchemeEquation.source" title="daetools.pyDAE.hr_upwind_scheme.daeHRUpwindSchemeEquation.source"><code class="xref py py-meth docutils literal"><span class="pre">source()</span></code></a>:</p>
<p><span class="math">\(source(i) = \int_{\Omega_i} s_i dx\)</span></p>
</li>
</ul>
<p>as given in the example below:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">modTutorial</span><span class="p">(</span><span class="n">daeModel</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Name</span><span class="p">,</span> <span class="n">Parent</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">Description</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="n">daeModel</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Name</span><span class="p">,</span> <span class="n">Parent</span><span class="p">,</span> <span class="n">Description</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DeclareEquations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">daeModel</span><span class="o">.</span><span class="n">DeclareEquations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">xp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">Points</span>
        <span class="n">Nx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">NumberOfPoints</span>

        <span class="n">c</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="c1"># 1. Declare the HR upwind scheme object:</span>
        <span class="c1">#     - c is a state variable</span>
        <span class="c1">#     - x is a domain object</span>
        <span class="c1">#     - Phi_Koren is a flux limiter function</span>
        <span class="n">hr</span> <span class="o">=</span> <span class="n">daeHRUpwindSchemeEquation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">daeHRUpwindSchemeEquation</span><span class="o">.</span><span class="n">Phi_Koren</span><span class="p">,</span> <span class="mf">1e-10</span><span class="p">)</span>

        <span class="c1"># 2. Define the source term function</span>
        <span class="k">def</span> <span class="nf">s</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

        <span class="c1"># 3. Declare the Convection-Diffusion-Reaction equation distributed on (0, L]:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CreateEquation</span><span class="p">(</span><span class="s2">&quot;c(</span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">hr</span><span class="o">.</span><span class="n">dc_dt</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">u</span> <span class="o">*</span> <span class="n">hr</span><span class="o">.</span><span class="n">dc_dx</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">-</span> <span class="n">D</span> <span class="o">*</span> <span class="n">hr</span><span class="o">.</span><span class="n">d2c_dx2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">-</span> <span class="n">hr</span><span class="o">.</span><span class="n">source</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>

        <span class="c1"># Boundary conditions at x=0:</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CreateEquation</span><span class="p">(</span><span class="s2">&quot;c(0)&quot;</span><span class="p">)</span>
        <span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">c</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="o">...</span>
</pre></div>
</div>
<p>It is desired that the discretisation of the source term is consistent with that of the advection operator.
For this purpose, if the source term integral: <span class="math">\(S(x) = {1 \over u} \int_{\Omega_i} s(x) dx\)</span> can be
calculated analytically, the convection term can be rewritten as:</p>
<div class="math">
\[{\partial c \over \partial t} + u {\partial (c-\mathbf{S}) \over \partial x} - D {\partial^2 c \over \partial x^2} = 0\]</div>
<p>and the semi-discrete equation becomes:</p>
<div class="math">
\[\int_{\Omega_i} {\partial c_i \over \partial t} dx + u \left[ \left( c_{i + {1 \over 2}} - \mathbf{S}_{i + {1 \over 2}} \right) - \left( c_{i - {1 \over 2}} - \mathbf{S}_{i - {1 \over 2}} \right) \right] - D \left[ \left( \partial c_i \over \partial x \right)_{i + {1 \over 2}} - \left( \partial c_i \over \partial x \right)_{i - {1 \over 2}} \right] = 0\]</div>
<p>The example above now becomes:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">modTutorial</span><span class="p">(</span><span class="n">daeModel</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Name</span><span class="p">,</span> <span class="n">Parent</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">Description</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="n">daeModel</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Name</span><span class="p">,</span> <span class="n">Parent</span><span class="p">,</span> <span class="n">Description</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DeclareEquations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">daeModel</span><span class="o">.</span><span class="n">DeclareEquations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">xp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">Points</span>
        <span class="n">Nx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">NumberOfPoints</span>

        <span class="n">c</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="c1"># 1. Declare the HR upwind scheme object:</span>
        <span class="c1">#     - c is a state variable</span>
        <span class="c1">#     - x is a domain object</span>
        <span class="c1">#     - u is velocity</span>
        <span class="c1">#     - Phi_Koren is a flux limiter function</span>
        <span class="n">hr</span> <span class="o">=</span> <span class="n">daeHRUpwindSchemeEquation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">daeHRUpwindSchemeEquation</span><span class="o">.</span><span class="n">Phi_Koren</span><span class="p">,</span> <span class="mf">1e-10</span><span class="p">)</span>

        <span class="c1"># 2. Consistent discretisation of convection and source terms:</span>
        <span class="c1">#    Calculate an analytical integral of the source term S = 1/u * Integral(s(x)*dx)</span>
        <span class="k">def</span> <span class="nf">S</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">C1</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">return</span> <span class="n">c</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">C1</span>

        <span class="c1"># 3. Declare the Convection-Diffusion-Reaction equation distributed on (0, L]</span>
        <span class="c1">#    (with the S integral in the convection term):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CreateEquation</span><span class="p">(</span><span class="s2">&quot;c(</span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">hr</span><span class="o">.</span><span class="n">dc_dt</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">u</span> <span class="o">*</span> <span class="n">hr</span><span class="o">.</span><span class="n">dc_dx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span> <span class="o">-</span> <span class="n">D</span> <span class="o">*</span> <span class="n">hr</span><span class="o">.</span><span class="n">d2c_dx2</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="c1"># Boundary Conditions:</span>
        <span class="n">eq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CreateEquation</span><span class="p">(</span><span class="s2">&quot;c(0)&quot;</span><span class="p">)</span>
        <span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">c</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="o">...</span>
</pre></div>
</div>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="koren" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id3">2</a>)</em> B. Koren. A robust upwind discretisation method for advection, diffusion and source terms.
In: Vreugdenhil CB, Koren B, editors. Numerical Methods for Advection–Diffusion Problems.
Braunschweig: Vieweg; 1993. <a class="reference external" href="http://isbnsearch.org/isbn/3528076453">ISBN-10:3528076453</a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="koren2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id4">2</a>)</em> B. Koren. A robust upwind discretization method for advection, diffusion and source terms.
Department of Numerical Mathematics. Report NM-R9308 (1993).
<a class="reference external" href="http://oai.cwi.nl/oai/asset/5293/05293D.pdf">PDF</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="fluxlimiters" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[3]</a></td><td>Flux-limiter functions on <a class="reference external" href="https://en.wikipedia.org/wiki/Flux_limiter">Wikipedia</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="the-finite-element-method">
<h3>6.3.3. The Finite Element Method<a class="headerlink" href="#the-finite-element-method" title="Permalink to this headline">¶</a></h3>
<p>DAE Tools support numerical simulation of partial differential equations on unstructured grids using
the Finite Element method. The main idea is to utilise available state-of-the-art Finite Element
libraries (i.e. <a class="reference external" href="http://dealii.org">deal.II</a>) for low-level tasks such as mesh loading, management of finite element
spaces, degrees of freedom, assembly of the system stiffness and mass matrices and the system load vector,
setting the boundary conditions etc..
After the assembly phase in an external library the matrices are used to generate a set of equations
in the following form:</p>
<div class="math">
\[\left[ M_{ij} \right] \left\{ {dx_j} \over {dt} \right\} + \left[ A_{ij} \right] \left\{ x_j \right\} = \left\{ F_i \right\}\]</div>
<p>where <span class="math">\(x_j\)</span> is a state variable, <span class="math">\(M_{ij}\)</span> and <span class="math">\(A_{ij}\)</span> are mass and stiffness matrices
and <span class="math">\(F_i\)</span> is the load vector. This system is in a general case a DAE system, although it can also be
a linear or a non-linear (if the mass matrix is zero).
The generated set of equations are solved together with the rest of equations in the model.</p>
<p>The unique feature of this approach is a capability to use <strong>DAE Tools</strong> objects (parameters and variables)
as a native data type in deal.II functions to specify boundary conditions, time varying coefficients and
source terms. This way, the non-linear finite element systems are automatically supported and the equations
resulting from the finite element discretisation are fully integrated with the rest of the model equations.
Moreover, multiple FE systems can be created and coupled together.</p>
<p>The information required (from the modeller&#8217;s perspective):</p>
<ul class="simple">
<li>Mesh file with the specified boundary indicators (integers)</li>
<li>Variables (degrees of freedom in deal.II) and their Finite Element spaces</li>
<li>Quadrature formulas for elements and their faces</li>
<li>The weak form of the problem which contains expressions for the cells&#8217; and boundary faces&#8217; contributions
to the system mass and stiffness matrix and the load vector.</li>
</ul>
<p>The weak form expressions are specified using the <strong>DAE Tools</strong> API that wraps deal.II
concepts used to assembly the matrices/vectors. The weak forms in daetools
contain expressions as they would appear in typical nested for loops.
In deal.II a typical cell assembly loop (in C++) would look like
(i.e. a very simple example given in step-7):</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="n">FEValues</span><span class="o">&lt;</span><span class="n">dim</span><span class="o">&gt;</span>             <span class="n">fe_values</span><span class="p">(...);</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">local_dof_indices</span><span class="p">;</span>

<span class="k">typename</span> <span class="n">DoFHandler</span><span class="o">&lt;</span><span class="n">dim</span><span class="o">&gt;::</span><span class="n">active_cell_iterator</span> <span class="n">cell</span> <span class="o">=</span> <span class="n">dof_handler</span><span class="p">.</span><span class="n">begin_active</span><span class="p">(),</span>
                                               <span class="n">endc</span> <span class="o">=</span> <span class="n">dof_handler</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
<span class="k">for</span><span class="p">(;</span> <span class="n">cell</span> <span class="o">!=</span> <span class="n">endc</span><span class="p">;</span> <span class="o">++</span><span class="n">cell</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">fe_values</span><span class="p">.</span><span class="n">reinit</span><span class="p">(</span><span class="n">cell</span><span class="p">);</span>
    <span class="n">cell</span><span class="o">-&gt;</span><span class="n">get_dof_indices</span><span class="p">(</span><span class="n">local_dof_indices</span><span class="p">);</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">q_point</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">q_point</span> <span class="o">&lt;</span> <span class="n">n_q_points</span><span class="p">;</span> <span class="o">++</span><span class="n">q_point</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dofs_per_cell</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">dofs_per_cell</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">cell_matrix</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">+=</span> <span class="p">((</span><span class="n">fe_values</span><span class="p">.</span><span class="n">shape_grad</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">q_point</span><span class="p">)</span> <span class="o">*</span>
                                      <span class="n">fe_values</span><span class="p">.</span><span class="n">shape_grad</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">q_point</span><span class="p">)</span>
                                      <span class="o">+</span>
                                      <span class="n">fe_values</span><span class="p">.</span><span class="n">shape_value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">q_point</span><span class="p">)</span> <span class="o">*</span>
                                      <span class="n">fe_values</span><span class="p">.</span><span class="n">shape_value</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">q_point</span><span class="p">))</span> <span class="o">*</span>
                                    <span class="n">fe_values</span><span class="p">.</span><span class="n">JxW</span><span class="p">(</span><span class="n">q_point</span><span class="p">));</span>
            <span class="p">}</span>

            <span class="n">cell_rhs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+=</span> <span class="p">(</span><span class="n">fe_values</span><span class="p">.</span><span class="n">shape_value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">q_point</span><span class="p">)</span> <span class="o">*</span>
                            <span class="n">rhs_values</span> <span class="p">[</span><span class="n">q_point</span><span class="p">]</span> <span class="o">*</span> <span class="n">fe_values</span><span class="p">.</span><span class="n">JxW</span><span class="p">(</span><span class="n">q_point</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>An equivalent problem in <strong>DAE Tools</strong> creates an execution context used in a generic loop to evaluate the cell/face contributions:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="n">FEValues</span><span class="o">&lt;</span><span class="n">dim</span><span class="o">&gt;</span>             <span class="n">fe_values</span><span class="p">(...);</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">local_dof_indices</span><span class="p">;</span>

<span class="c1">// Create evaluation context objects where the expressions will be evaluated:</span>
<span class="n">feCellContext</span><span class="o">&lt;</span><span class="n">dim</span><span class="o">&gt;</span> <span class="n">cellContext</span><span class="p">(</span><span class="n">fe_values</span><span class="p">,</span> <span class="n">local_dof_indices</span><span class="p">,</span> <span class="p">...);</span>

<span class="k">typename</span> <span class="n">DoFHandler</span><span class="o">&lt;</span><span class="n">dim</span><span class="o">&gt;::</span><span class="n">active_cell_iterator</span> <span class="n">cell</span> <span class="o">=</span> <span class="n">dof_handler</span><span class="p">.</span><span class="n">begin_active</span><span class="p">(),</span>
                                               <span class="n">endc</span> <span class="o">=</span> <span class="n">dof_handler</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
<span class="k">for</span><span class="p">(;</span> <span class="n">cell</span> <span class="o">!=</span> <span class="n">endc</span><span class="p">;</span> <span class="o">++</span><span class="n">cell</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Update the evaluation context with the current cell.</span>
    <span class="c1">// It will call fe_values.reinit(cell), cell-&gt;get_dof_indices(local_dof_indices) etc.</span>
    <span class="n">update</span><span class="p">(</span><span class="n">cellContext</span><span class="p">,</span> <span class="n">cell</span><span class="p">);</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">q_point</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">q_point</span> <span class="o">&lt;</span> <span class="n">n_q_points</span><span class="p">;</span> <span class="o">++</span><span class="n">q_point</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// update cellContext with the current quadrature point index</span>

        <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dofs_per_cell</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// update cellContext with the current i loop dof index</span>

            <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">dofs_per_cell</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">// update cellContext with the current j loop dof index</span>

                <span class="n">cell_matrix</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">+=</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">cell_contribution_to_stiffness_matrix</span><span class="p">,</span> <span class="n">cellContext</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="c1">// update cellContext with the current i, j, q indices</span>

            <span class="n">cell_rhs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+=</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">cell_contribution_to_load_vector</span><span class="p">,</span> <span class="n">cellContext</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Apart from specifying the weak formulation using the single expressions evaluated in a generic loop as shown above,
tuples of expressions representing independent terms evaluated in the q, i and j loops can be also used.
This is useful for complex weak form expressions involving non-linear terms (i.e. dof approximations)
and results in simpler expressions and a faster evaluation. The usage of separate items for different
loop iterations is illustrated below:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="n">FEValues</span><span class="o">&lt;</span><span class="n">dim</span><span class="o">&gt;</span>             <span class="n">fe_values</span><span class="p">(...);</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">local_dof_indices</span><span class="p">;</span>

<span class="c1">// Create evaluation context objects where the expressions will be evaluated:</span>
<span class="n">feCellContext</span><span class="o">&lt;</span><span class="n">dim</span><span class="o">&gt;</span> <span class="n">cellContext</span><span class="p">(</span><span class="n">fe_values</span><span class="p">,</span> <span class="n">local_dof_indices</span><span class="p">,</span> <span class="p">...);</span>

<span class="k">typename</span> <span class="n">DoFHandler</span><span class="o">&lt;</span><span class="n">dim</span><span class="o">&gt;::</span><span class="n">active_cell_iterator</span> <span class="n">cell</span> <span class="o">=</span> <span class="n">dof_handler</span><span class="p">.</span><span class="n">begin_active</span><span class="p">(),</span>
                                               <span class="n">endc</span> <span class="o">=</span> <span class="n">dof_handler</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
<span class="k">for</span><span class="p">(;</span> <span class="n">cell</span> <span class="o">!=</span> <span class="n">endc</span><span class="p">;</span> <span class="o">++</span><span class="n">cell</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Update the evaluation context with the current cell.</span>
    <span class="c1">// It will call fe_values.reinit(cell), cell-&gt;get_dof_indices(local_dof_indices) etc.</span>
    <span class="n">update</span><span class="p">(</span><span class="n">cellContext</span><span class="p">,</span> <span class="n">cell</span><span class="p">);</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">q_point</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">q_point</span> <span class="o">&lt;</span> <span class="n">n_q_points</span><span class="p">;</span> <span class="o">++</span><span class="n">q_point</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Temporary storage</span>
        <span class="n">Vector</span><span class="o">&lt;</span><span class="n">adouble</span><span class="o">&gt;</span>     <span class="n">cell_rhs_temp</span><span class="p">(</span><span class="n">dofs_per_cell</span><span class="p">);</span>
        <span class="n">FullMatrix</span><span class="o">&lt;</span><span class="n">adouble</span><span class="o">&gt;</span> <span class="n">cell_matrix_temp</span><span class="p">(</span><span class="n">dofs_per_cell</span><span class="p">,</span> <span class="n">dofs_per_cell</span><span class="p">);</span>

        <span class="c1">// update cellContext with the current quadrature point index</span>

        <span class="n">q_loop_term</span> <span class="o">=</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">q_loop_expression</span><span class="p">,</span> <span class="n">cellContext</span><span class="p">);</span>

        <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dofs_per_cell</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// update cellContext with the current i loop dof index</span>

            <span class="n">i_loop_term</span> <span class="o">=</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">i_loop_expression</span><span class="p">,</span> <span class="n">cellContext</span><span class="p">);</span>

            <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">dofs_per_cell</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">// update cellContext with the current j loop dof index</span>

                <span class="n">j_loop_term</span> <span class="o">=</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">j_loop_expression</span><span class="p">,</span> <span class="n">cellContext</span><span class="p">);</span>

                <span class="n">cell_matrix_temp</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="o">+=</span> <span class="n">i_loop_term</span> <span class="o">*</span> <span class="n">j_loop_term</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">cell_rhs_temp</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+=</span> <span class="n">i_loop_term</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">cell_rhs_temp</span>    <span class="o">*=</span> <span class="n">q_loop_term</span><span class="p">;</span>
        <span class="n">cell_matrix_temp</span> <span class="o">*=</span> <span class="n">q_loop_term</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Add the temporary data to the cell matrix/vector</span>
    <span class="n">cell_rhs</span>    <span class="o">+=</span> <span class="n">cell_rhs_temp</span><span class="p">;</span>
    <span class="n">cell_matrix</span> <span class="o">+=</span> <span class="n">cell_matrix_temp</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Obviously, the generic loops can be used to solve many FE problems but not all.
However, they can support a large number of problems at the moment.
In the future they will be expanded to support a broader class of problems.</p>
<p>Equations produced by the Finite Element matrix assembly can be extremely long/complex.
Under the hood, they will be simplified as much as possible. Some examples are given below.</p>
<ul>
<li><p class="first">From <a class="reference internal" href="tutorials-all.html#tutorial-dealii-2"><span class="std std-ref">Tutorial deal.II 2</span></a>:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/tutorial_deal.ii-2-sample_expression.png"><img alt="_images/tutorial_deal.ii-2-sample_expression.png" src="_images/tutorial_deal.ii-2-sample_expression.png" style="width: 400pt;" /></a>
</div>
</li>
<li><p class="first">From <a class="reference internal" href="tutorials-all.html#tutorial-dealii-3"><span class="std std-ref">Tutorial deal.II 3</span></a>:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/tutorial_deal.ii-3-sample_expression.png"><img alt="_images/tutorial_deal.ii-3-sample_expression.png" src="_images/tutorial_deal.ii-3-sample_expression.png" style="width: 600pt;" /></a>
</div>
</li>
<li><p class="first">From <a class="reference internal" href="tutorials-all.html#tutorial-dealii-7"><span class="std std-ref">Tutorial deal.II 7</span></a>:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/tutorial_deal.ii-7-sample_expression.png"><img alt="_images/tutorial_deal.ii-7-sample_expression.png" src="_images/tutorial_deal.ii-7-sample_expression.png" style="width: 400pt;" /></a>
</div>
</li>
</ul>
<p><strong>DAE Tools</strong> provide four main classes for Finite Element models using deal.II library:</p>
<ol class="arabic">
<li><p class="first"><a class="reference internal" href="finite_element.html#pyDealII.dealiiFiniteElementDOF_1D" title="pyDealII.dealiiFiniteElementDOF_1D"><code class="xref py py-class docutils literal"><span class="pre">dealiiFiniteElementDOF_1D</span></code></a>, <a class="reference internal" href="finite_element.html#pyDealII.dealiiFiniteElementDOF_2D" title="pyDealII.dealiiFiniteElementDOF_2D"><code class="xref py py-class docutils literal"><span class="pre">dealiiFiniteElementDOF_2D</span></code></a> and
<a class="reference internal" href="finite_element.html#pyDealII.dealiiFiniteElementDOF_3D" title="pyDealII.dealiiFiniteElementDOF_3D"><code class="xref py py-class docutils literal"><span class="pre">dealiiFiniteElementDOF_3D</span></code></a></p>
<p>In deal.II it represents a degree of freedom distributed on a finite element domain.
In <strong>DAE Tools</strong> it represents a variable distributed on a finite element domain.</p>
</li>
<li><p class="first"><a class="reference internal" href="finite_element.html#pyDealII.dealiiFiniteElementSystem_1D" title="pyDealII.dealiiFiniteElementSystem_1D"><code class="xref py py-class docutils literal"><span class="pre">dealiiFiniteElementSystem_1D</span></code></a>, <a class="reference internal" href="finite_element.html#pyDealII.dealiiFiniteElementSystem_2D" title="pyDealII.dealiiFiniteElementSystem_2D"><code class="xref py py-class docutils literal"><span class="pre">dealiiFiniteElementSystem_2D</span></code></a> and
<a class="reference internal" href="finite_element.html#pyDealII.dealiiFiniteElementSystem_3D" title="pyDealII.dealiiFiniteElementSystem_3D"><code class="xref py py-class docutils literal"><span class="pre">dealiiFiniteElementSystem_3D</span></code></a> (implements <code class="xref py py-class docutils literal"><span class="pre">daeFiniteElementObject</span></code>)</p>
<p>It is a wrapper around deal.II <code class="docutils literal"><span class="pre">FESystem&lt;dim&gt;</span></code> class and handles all finite element related details.
It uses information about the mesh, quadrature and face quadrature formulas, degrees of freedom
and the FE weak formulation to assemble the system&#8217;s mass matrix (Mij), stiffness matrix (Aij)
and the load vector (Fi).</p>
</li>
<li><p class="first"><a class="reference internal" href="finite_element.html#pyDealII.dealiiFiniteElementWeakForm_1D" title="pyDealII.dealiiFiniteElementWeakForm_1D"><code class="xref py py-class docutils literal"><span class="pre">dealiiFiniteElementWeakForm_1D</span></code></a>, <a class="reference internal" href="finite_element.html#pyDealII.dealiiFiniteElementWeakForm_2D" title="pyDealII.dealiiFiniteElementWeakForm_2D"><code class="xref py py-class docutils literal"><span class="pre">dealiiFiniteElementWeakForm_2D</span></code></a> and
<a class="reference internal" href="finite_element.html#pyDealII.dealiiFiniteElementWeakForm_3D" title="pyDealII.dealiiFiniteElementWeakForm_3D"><code class="xref py py-class docutils literal"><span class="pre">dealiiFiniteElementWeakForm_3D</span></code></a></p>
<p>Contains weak form expressions for the contribution of FE cells to the system/stiffness matrices,
the load vector, boundary conditions and (optionally) surface/volume integrals (as an output).</p>
</li>
<li><p class="first"><a class="reference internal" href="finite_element.html#pyCore.daeFiniteElementModel" title="pyCore.daeFiniteElementModel"><code class="xref py py-class docutils literal"><span class="pre">daeFiniteElementModel</span></code></a></p>
<p><cite>daeModel</cite>-derived class that use system matrices/vectors from the <code class="xref py py-class docutils literal"><span class="pre">dealiiFiniteElementSystem_nD</span></code>
object to generate a system of equations.</p>
</li>
</ol>
<p>A typical use-case scenario consists of the following steps:</p>
<ol class="arabic">
<li><p class="first">The starting point is a definition of the <code class="xref py py-class docutils literal"><span class="pre">dealiiFiniteElementSystem_nD</span></code> class
(where <cite>nD</cite> can be <cite>1D</cite>, <cite>2D</cite> or <cite>3D</cite>).
That includes specification of:</p>
<ul class="simple">
<li>Mesh file in one of the formats supported by deal.II (<a class="reference external" href="http://www.dealii.org/developer/doxygen/deal.II/classGridIn.html">GridIn</a>)</li>
<li>Degrees of freedom (as a python list of <code class="xref py py-class docutils literal"><span class="pre">dealiiFiniteElementDOF_nD</span></code> objects).
Every dof has a name which will be also used to declare <strong>DAE Tools</strong> variable with the same name,
description, finite element space <a class="reference external" href="http://www.dealii.org/developer/doxygen/deal.II/group__fe.html">FE</a> (<cite>deal.II FiniteElement&lt;dim&gt;</cite> instance) and the multiplicity</li>
<li><a class="reference external" href="http://www.dealii.org/developer/doxygen/deal.II/group__Quadrature.html">Quadrature</a> formulas for elements and their faces</li>
</ul>
</li>
<li><p class="first">Creation of <a class="reference internal" href="finite_element.html#pyCore.daeFiniteElementModel" title="pyCore.daeFiniteElementModel"><code class="xref py py-class docutils literal"><span class="pre">daeFiniteElementModel</span></code></a> object (similarly to the ordinary <strong>DAE Tools</strong> model)
with the finite element system object as the last argument.</p>
</li>
<li><p class="first">Definition of the weak form of the problem using the following functions (a version exist for 1D, 2D and 3D):</p>
<ul class="simple">
<li><a class="reference internal" href="finite_element.html#pyDealII.phi_1D" title="pyDealII.phi_1D"><code class="xref py py-meth docutils literal"><span class="pre">phi_1D()</span></code></a>: corresponds to <cite>shape_value</cite> in deal.II</li>
<li><a class="reference internal" href="finite_element.html#pyDealII.dphi_1D" title="pyDealII.dphi_1D"><code class="xref py py-meth docutils literal"><span class="pre">dphi_1D()</span></code></a>: corresponds to <cite>shape_grad</cite> in deal.II</li>
<li><a class="reference internal" href="finite_element.html#pyDealII.d2phi_1D" title="pyDealII.d2phi_1D"><code class="xref py py-meth docutils literal"><span class="pre">d2phi_1D()</span></code></a>: corresponds to <cite>shape_hessian</cite> in deal.II</li>
<li><a class="reference internal" href="finite_element.html#pyDealII.phi_vector_1D" title="pyDealII.phi_vector_1D"><code class="xref py py-meth docutils literal"><span class="pre">phi_vector_1D()</span></code></a>: corresponds to <cite>shape_value</cite> of vector dofs in deal.II</li>
<li><a class="reference internal" href="finite_element.html#pyDealII.dphi_vector_1D" title="pyDealII.dphi_vector_1D"><code class="xref py py-meth docutils literal"><span class="pre">dphi_vector_1D()</span></code></a>: corresponds to <cite>shape_grad</cite> of vector dofs in deal.II</li>
<li><a class="reference internal" href="finite_element.html#pyDealII.d2phi_vector_1D" title="pyDealII.d2phi_vector_1D"><code class="xref py py-meth docutils literal"><span class="pre">d2phi_vector_1D()</span></code></a>: corresponds to <cite>shape_hessian</cite> of vector dofs in deal.II</li>
<li><a class="reference internal" href="finite_element.html#pyDealII.div_phi_1D" title="pyDealII.div_phi_1D"><code class="xref py py-meth docutils literal"><span class="pre">div_phi_1D()</span></code></a>: corresponds to divergence in deal.II</li>
<li><a class="reference internal" href="finite_element.html#pyDealII.JxW_1D" title="pyDealII.JxW_1D"><code class="xref py py-meth docutils literal"><span class="pre">JxW_1D()</span></code></a>: corresponds to the mapped quadrature weight in deal.II</li>
<li><a class="reference internal" href="finite_element.html#pyDealII.xyz_1D" title="pyDealII.xyz_1D"><code class="xref py py-meth docutils literal"><span class="pre">xyz_1D()</span></code></a>: returns the point for the specified quadrature point in deal.II</li>
<li><a class="reference internal" href="finite_element.html#pyDealII.normal_1D" title="pyDealII.normal_1D"><code class="xref py py-meth docutils literal"><span class="pre">normal_1D()</span></code></a>: corresponds to the <cite>normal_vector</cite> in deal.II</li>
<li><a class="reference internal" href="finite_element.html#pyDealII.function_value_1D" title="pyDealII.function_value_1D"><code class="xref py py-meth docutils literal"><span class="pre">function_value_1D()</span></code></a>: wraps <cite>Function&lt;dim&gt;</cite> object that returns a value</li>
<li><a class="reference internal" href="finite_element.html#pyDealII.function_gradient_1D" title="pyDealII.function_gradient_1D"><code class="xref py py-meth docutils literal"><span class="pre">function_gradient_1D()</span></code></a>: wraps <cite>Function&lt;dim&gt;</cite> object that returns a gradient</li>
<li><a class="reference internal" href="finite_element.html#pyDealII.function_adouble_value_1D" title="pyDealII.function_adouble_value_1D"><code class="xref py py-meth docutils literal"><span class="pre">function_adouble_value_1D()</span></code></a>: wraps <cite>Function&lt;dim,adouble&gt;</cite> object that returns adouble value</li>
<li><a class="reference internal" href="finite_element.html#pyDealII.function_adouble_gradient_1D" title="pyDealII.function_adouble_gradient_1D"><code class="xref py py-meth docutils literal"><span class="pre">function_adouble_gradient_1D()</span></code></a>: wraps <cite>Function&lt;dim,adouble&gt;</cite> object that returns adouble gradient</li>
<li><a class="reference internal" href="finite_element.html#pyDealII.dof_1D" title="pyDealII.dof_1D"><code class="xref py py-meth docutils literal"><span class="pre">dof_1D()</span></code></a>: returns daetools variable at the given index (adouble object)</li>
<li><a class="reference internal" href="finite_element.html#pyDealII.dof_approximation_1D" title="pyDealII.dof_approximation_1D"><code class="xref py py-meth docutils literal"><span class="pre">dof_approximation_1D()</span></code></a>: returns FE approximation of a quantity as a daetools variable (adouble object)</li>
<li><a class="reference internal" href="finite_element.html#pyDealII.dof_gradient_approximation_1D" title="pyDealII.dof_gradient_approximation_1D"><code class="xref py py-meth docutils literal"><span class="pre">dof_gradient_approximation_1D()</span></code></a>: returns FE gradient approximation of a quantity as a daetools variable (adouble object)</li>
<li><a class="reference internal" href="finite_element.html#pyDealII.dof_hessian_approximation_1D" title="pyDealII.dof_hessian_approximation_1D"><code class="xref py py-meth docutils literal"><span class="pre">dof_hessian_approximation_1D()</span></code></a>: returns FE hessian approximation of a quantity as a daetools variable (adouble object)</li>
<li><a class="reference internal" href="finite_element.html#pyDealII.vector_dof_approximation_1D" title="pyDealII.vector_dof_approximation_1D"><code class="xref py py-meth docutils literal"><span class="pre">vector_dof_approximation_1D()</span></code></a>: returns FE approximation of a vector quantity as a daetools variable (adouble object)</li>
<li><a class="reference internal" href="finite_element.html#pyDealII.vector_dof_gradient_approximation_1D" title="pyDealII.vector_dof_gradient_approximation_1D"><code class="xref py py-meth docutils literal"><span class="pre">vector_dof_gradient_approximation_1D()</span></code></a>: returns FE approximation of a vector quantity as a daetools variable (adouble object)</li>
<li><a class="reference internal" href="finite_element.html#pyDealII.adouble_1D" title="pyDealII.adouble_1D"><code class="xref py py-meth docutils literal"><span class="pre">adouble_1D()</span></code></a>: wraps any daetools expression to be used in matrix assembly</li>
<li><a class="reference internal" href="finite_element.html#pyDealII.tensor1_1D" title="pyDealII.tensor1_1D"><code class="xref py py-meth docutils literal"><span class="pre">tensor1_1D()</span></code></a>: wraps deal.II <cite>Tensor&lt;rank=1&gt;</cite></li>
<li><a class="reference internal" href="finite_element.html#pyDealII.tensor2_1D" title="pyDealII.tensor2_1D"><code class="xref py py-meth docutils literal"><span class="pre">tensor2_1D()</span></code></a>: wraps deal.II <cite>Tensor&lt;rank=2&gt;</cite></li>
<li><a class="reference internal" href="finite_element.html#pyDealII.tensor3_1D" title="pyDealII.tensor3_1D"><code class="xref py py-meth docutils literal"><span class="pre">tensor3_1D()</span></code></a>: wraps deal.II <cite>Tensor&lt;rank=3&gt;</cite></li>
<li><a class="reference internal" href="finite_element.html#pyDealII.adouble_tensor1_1D" title="pyDealII.adouble_tensor1_1D"><code class="xref py py-meth docutils literal"><span class="pre">adouble_tensor1_1D()</span></code></a>: wraps deal.II <cite>Tensor&lt;rank=1,adouble&gt;</cite></li>
<li><a class="reference internal" href="finite_element.html#pyDealII.adouble_tensor2_1D" title="pyDealII.adouble_tensor2_1D"><code class="xref py py-meth docutils literal"><span class="pre">adouble_tensor2_1D()</span></code></a>: wraps deal.II <cite>Tensor&lt;rank=2,adouble&gt;</cite></li>
<li><a class="reference internal" href="finite_element.html#pyDealII.adouble_tensor3_1D" title="pyDealII.adouble_tensor3_1D"><code class="xref py py-meth docutils literal"><span class="pre">adouble_tensor3_1D()</span></code></a>: wraps deal.II <cite>Tensor&lt;rank=3,adouble&gt;</cite></li>
</ul>
<p>and constants: <code class="xref py py-const docutils literal"><span class="pre">fe_i</span></code>, <code class="xref py py-const docutils literal"><span class="pre">fe_j</span></code> and <code class="xref py py-const docutils literal"><span class="pre">fe_q</span></code> used to access
the current indexes in the DOF and quadrature points loops.</p>
</li>
</ol>
<p>The weak form contains the following contributions:</p>
<ul class="simple">
<li><cite>Aij</cite> - cell contribution to the system stiffness matrix</li>
<li><cite>Mij</cite> - cell contribution to the system mass matrix</li>
<li><cite>Fi</cite> - cell contribution to the system load vector</li>
<li><cite>boundaryFaceAij</cite> - boundary face contribution to the system stiffness matrix</li>
<li><cite>boundaryFaceFi</cite> - boundary face contribution to the load vector</li>
<li><cite>innerCellFaceAij</cite> - inner cell face contribution to the system stiffness matrix</li>
<li><cite>innerCellFaceFi</cite> - inner cell face contribution to the load vector</li>
<li><cite>functionsDirichletBC</cite> - Dirichlet boundary conditions</li>
<li><cite>surfaceIntegrals</cite> - surface integrals</li>
<li><cite>volumeIntegrals</cite> - volume  integrals</li>
</ul>
<p>Example for the Helmholtz problem (step-7 tutorial from deal.II).
The strong form of the Helmholtz equation is given by (with Neumann boundary conditions):</p>
<div class="math">
\[\begin{split}-\Delta u + u &amp;= f  \; in \; \Omega \\
{\mathbf n}\cdot \nabla u &amp;= g  \; on \; \delta \Omega\end{split}\]</div>
<p>The weak form of the above equation is:</p>
<div class="math">
\[{(\nabla u, \nabla v)}_\Omega + {(u,v)}_\Omega = {(f,v)}_\Omega + {(g,v)}_{\delta \Omega}\]</div>
<p>Cell contributions to the stiffness matrix and the load vector are:</p>
<div class="math">
\[\begin{split}A_{ij} &amp;= \left(\nabla \varphi_i, \nabla \varphi_j\right) +\left(\varphi_i, \varphi_j\right) \\
F_i &amp;= \left(f,\varphi_i\right) + \left(g, \varphi_i\right)_{\delta \Omega}\end{split}\]</div>
<p>The c++ implementation in deal.II is given in the step-7 example and in the previous c++ listing.
In <strong>DAE Tools</strong> the above equation is specified in the following way
(<span class="math">\(\delta \Omega\)</span> boundary is marked with id = 0 and for simplicity, <span class="math">\(f\)</span> and <span class="math">\(g\)</span>
are assumed constant):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">modTutorial</span><span class="p">(</span><span class="n">daeModel</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Name</span><span class="p">,</span> <span class="n">Parent</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">Description</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="n">daeModel</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Name</span><span class="p">,</span> <span class="n">Parent</span><span class="p">,</span> <span class="n">Description</span><span class="p">)</span>

        <span class="n">dofs</span> <span class="o">=</span> <span class="p">[</span><span class="n">dealiiFiniteElementDOF_2D</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;u&#39;</span><span class="p">,</span>
                                          <span class="n">description</span><span class="o">=</span><span class="s1">&#39;u description&#39;</span><span class="p">,</span>
                                          <span class="n">fe</span> <span class="o">=</span> <span class="n">FE_Q_2D</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                                          <span class="n">multiplicity</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fe_system</span> <span class="o">=</span> <span class="n">dealiiFiniteElementSystem_2D</span><span class="p">(</span><span class="n">meshFilename</span>    <span class="o">=</span> <span class="s1">&#39;...&#39;</span><span class="p">,</span>        <span class="c1"># path to the .msh file</span>
                                                      <span class="n">quadrature</span>      <span class="o">=</span> <span class="n">QGauss_2D</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="c1"># quadrature formula</span>
                                                      <span class="n">faceQuadrature</span>  <span class="o">=</span> <span class="n">QGauss_1D</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="c1"># face quadrature formula</span>
                                                      <span class="n">dofs</span>            <span class="o">=</span> <span class="n">dofs</span><span class="p">)</span>         <span class="c1"># degrees of freedom</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fe_model</span> <span class="o">=</span> <span class="n">daeFiniteElementModel</span><span class="p">(</span><span class="s1">&#39;Helmholtz&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Helholtz problem&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fe_system</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DeclareEquations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">daeModel</span><span class="o">.</span><span class="n">DeclareEquations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Create some auxiliary objects for readability</span>
        <span class="n">phi_i</span>  <span class="o">=</span> <span class="n">phi_2D</span> <span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="n">fe_i</span><span class="p">,</span> <span class="n">fe_q</span><span class="p">)</span>
        <span class="n">phi_j</span>  <span class="o">=</span> <span class="n">phi_2D</span> <span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="n">fe_j</span><span class="p">,</span> <span class="n">fe_q</span><span class="p">)</span>
        <span class="n">dphi_i</span> <span class="o">=</span> <span class="n">dphi_2D</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="n">fe_i</span><span class="p">,</span> <span class="n">fe_q</span><span class="p">)</span>
        <span class="n">dphi_j</span> <span class="o">=</span> <span class="n">dphi_2D</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">,</span> <span class="n">fe_j</span><span class="p">,</span> <span class="n">fe_q</span><span class="p">)</span>
        <span class="n">JxW</span>    <span class="o">=</span> <span class="n">JxW_2D</span><span class="p">(</span><span class="n">fe_q</span><span class="p">)</span>
        <span class="n">f</span>      <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">g</span>      <span class="o">=</span> <span class="mf">1.0</span>

        <span class="n">weakForm</span> <span class="o">=</span> <span class="n">dealiiFiniteElementWeakForm_2D</span><span class="p">(</span><span class="n">Aij</span> <span class="o">=</span> <span class="p">(</span><span class="n">dphi_i</span><span class="o">*</span><span class="n">dphi_j</span> <span class="o">+</span> <span class="n">phi_i</span><span class="o">*</span><span class="n">phi_j</span><span class="p">)</span> <span class="o">*</span> <span class="n">JxW</span><span class="p">,</span>
                                                  <span class="n">Mij</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
                                                  <span class="n">Fi</span>  <span class="o">=</span> <span class="n">phi_i</span> <span class="o">*</span> <span class="n">f</span> <span class="o">*</span> <span class="n">JxW</span><span class="p">,</span>
                                                  <span class="n">boundaryFaceFi</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span> <span class="p">:</span> <span class="n">phi_i</span> <span class="o">*</span> <span class="n">g</span> <span class="o">*</span> <span class="n">JxW</span><span class="p">}</span> <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fe_system</span><span class="o">.</span><span class="n">WeakForm</span> <span class="o">=</span> <span class="n">weakForm</span>
</pre></div>
</div>
<p>In <strong>DAE Tools</strong> v1.7.1 an additional way of specifying the weak formulation has been introduced. Now, weak form contributions
can also be python lists containing <code class="xref py py-class docutils literal"><span class="pre">feExpression</span></code> objects or tuples of <code class="xref py py-class docutils literal"><span class="pre">feExpression</span></code> objects.
Tuples can contain two or three items.
Matrix contributions contain three items representing q-loop, i-loop and j-loop expressions in the deal.ii matrix assembly.
Load vector contributions contain two items representing q-loop and i-loop expressions in the deal.ii vector assembly.
This way the expressions produced by the finite element system assembly can be much simpler and the simulations faster.
The new way of specifying weak formulations is useful mostly for specification of non-linear terms
(i.e. those including scalar or vector DOF approximations).</p>
<p>For instance, the convection term in the heat convection-diffusion equation (tutorial_dealii_7.py) can be specified in a
more efficient way:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">modTutorial</span><span class="p">(</span><span class="n">daeModel</span><span class="p">):</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="nf">DeclareEquations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>

        <span class="c1"># Contributions from the Stokes equation:</span>
        <span class="n">Aij_u_gradient</span>     <span class="o">=</span> <span class="o">...</span>
        <span class="n">Aij_p_gradient</span>     <span class="o">=</span> <span class="o">...</span>
        <span class="c1"># Using the new way (q-loop, i-loop tuple for the load vector contributions):</span>
        <span class="n">Fi_buoyancy</span>        <span class="o">=</span> <span class="p">(</span><span class="n">T_dof</span><span class="p">,</span> <span class="o">-</span><span class="n">rho</span> <span class="o">*</span> <span class="n">beta</span> <span class="o">*</span> <span class="p">(</span><span class="n">gravity</span> <span class="o">*</span> <span class="n">phi_vector_u_i</span><span class="p">)</span> <span class="o">*</span> <span class="n">JxW</span><span class="p">)</span>

        <span class="c1"># Contributions from the continuity equation:</span>
        <span class="n">Aij_continuity</span>     <span class="o">=</span> <span class="o">...</span>

        <span class="c1"># Contributions from the heat convection-diffusion equation:</span>
        <span class="n">Mij_T_accumulation</span> <span class="o">=</span> <span class="o">...</span>
        <span class="c1"># Using the new way (q-loop, i-loop, j-loop tuple for matrix contributions):</span>
        <span class="n">Aij_T_convection</span>   <span class="o">=</span> <span class="p">(</span><span class="n">u_dof</span><span class="p">,</span> <span class="n">phi_T_i</span><span class="p">,</span> <span class="n">dphi_T_j</span> <span class="o">*</span> <span class="n">JxW</span><span class="p">)</span>
        <span class="n">Aij_T_diffusion</span>    <span class="o">=</span> <span class="o">...</span>
        <span class="n">Fi_T_source</span>        <span class="o">=</span> <span class="o">...</span>

        <span class="c1"># Total contributions (using the new way - python lists of expressions or tuples):</span>
        <span class="n">Mij</span> <span class="o">=</span> <span class="p">[</span><span class="n">Mij_T_accumulation</span><span class="p">]</span>
        <span class="n">Aij</span> <span class="o">=</span> <span class="p">[</span><span class="n">Aij_u_gradient</span> <span class="o">+</span> <span class="n">Aij_p_gradient</span> <span class="o">+</span> <span class="n">Aij_continuity</span> <span class="o">+</span> <span class="n">Aij_T_diffusion</span><span class="p">,</span>  <span class="n">Aij_T_convection</span><span class="p">]</span>
        <span class="n">Fi</span>  <span class="o">=</span> <span class="p">[</span><span class="n">Fi_T_source</span><span class="p">,</span> <span class="n">Fi_buoyancy</span><span class="p">]</span>

        <span class="n">weakForm</span> <span class="o">=</span> <span class="n">dealiiFiniteElementWeakForm_2D</span><span class="p">(</span><span class="n">Aij</span> <span class="o">=</span> <span class="n">Aij</span><span class="p">,</span>
                                                  <span class="n">Mij</span> <span class="o">=</span> <span class="n">Mij</span><span class="p">,</span>
                                                  <span class="n">Fi</span>  <span class="o">=</span> <span class="n">Fi</span><span class="p">)</span>
</pre></div>
</div>
<p>Using the old way the vector DOF approximation (<span class="math">\(u_{dof}\)</span>) is evaluated
<span class="math">\(N_{quadrature\,points} \cdot N_{dofs\,per\,cell} \cdot N_{dofs\,per\,cell}\)</span> times
while only <span class="math">\(N_{quadrature\,points}\)</span> evaluations are required.
A vector dof approximation is an expensive operation calculated in the following way:</p>
<div class="math">
\[u_{dof} = \sum\limits_{j=1}^{N_{dofs\,per\,cell}} \phi^u(j,q) \cdot u(j)\]</div>
<p>where <span class="math">\(\phi^u(j,q)\)</span> is a rank=1 tensor.
Reduction in the number of evaluations by <span class="math">\(N_{dofs\,per\,cell}^2\)</span> leads to
the huge amounts of memory and computation time saved.</p>
<p>More information about the finite element method in <strong>DAE Tools</strong> can be found in the API reference
and in <a class="reference internal" href="tutorials-fe.html"><span class="doc">Finite Element Tutorials</span></a> (in particular <a class="reference internal" href="tutorials-all.html#tutorial-dealii-1"><span class="std std-ref">Tutorial deal.II 1</span></a>).</p>
</div>
</div>
<div class="section" id="configuration">
<h2>6.4. Configuration<a class="headerlink" href="#configuration" title="Permalink to this headline">¶</a></h2>
<p>Various options related to <strong>DAE Tools</strong> simulation can be set in the <cite>daetools.cfg</cite> configuration file (in JSON format).
The configuration file can be obtained using the global function <a class="reference internal" href="core.html#pyCore.daeGetConfig" title="pyCore.daeGetConfig"><code class="xref py py-meth docutils literal"><span class="pre">daeGetConfig()</span></code></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">cfg</span> <span class="o">=</span> <span class="n">daeGetConfig</span><span class="p">()</span>
</pre></div>
</div>
<p>which returns the <a class="reference internal" href="core.html#pyCore.daeConfig" title="pyCore.daeConfig"><code class="xref py py-class docutils literal"><span class="pre">daeConfig</span></code></a> object.
The configuration file is first searched in the <cite>HOME</cite> directory, the application folder and finally in the default location.
It also can be specified manually using the function <a class="reference internal" href="core.html#pyCore.daeSetConfigFile" title="pyCore.daeSetConfigFile"><code class="xref py py-meth docutils literal"><span class="pre">daeSetConfigFile()</span></code></a>.
However, this has to be done before the <strong>DAE Tools</strong> objects are created.
The current configuration file name can be retrieved using the <a class="reference internal" href="core.html#pyCore.daeConfig.ConfigFileName" title="pyCore.daeConfig.ConfigFileName"><code class="xref py py-attr docutils literal"><span class="pre">ConfigFileName</span></code></a> attribute.
The options can also be programmatically changed using the <cite>Get</cite>/<cite>Set</cite> functions i.e.
<a class="reference internal" href="core.html#pyCore.daeConfig.GetBoolean" title="pyCore.daeConfig.GetBoolean"><code class="xref py py-meth docutils literal"><span class="pre">GetBoolean()</span></code></a>/<a class="reference internal" href="core.html#pyCore.daeConfig.SetBoolean" title="pyCore.daeConfig.SetBoolean"><code class="xref py py-meth docutils literal"><span class="pre">SetBoolean()</span></code></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">cfg</span> <span class="o">=</span> <span class="n">daeGetConfig</span><span class="p">()</span>
<span class="n">checkUnitsConsistency</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">.</span><span class="n">GetBoolean</span><span class="p">(</span><span class="s2">&quot;daetools.core.checkUnitsConsistency&quot;</span><span class="p">)</span>
<span class="n">cfg</span><span class="o">.</span><span class="n">SetBoolean</span><span class="p">(</span><span class="s2">&quot;daetools.core.checkUnitsConsistency&quot;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Supported data types are: <cite>Boolean</cite>, <cite>Integer</cite>, <cite>Float</cite> and <cite>String</cite>.
The whole configuration file with all options can be printed using:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">cfg</span> <span class="o">=</span> <span class="n">daeGetConfig</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">cfg</span><span class="p">)</span>
</pre></div>
</div>
<p>The sample configuration file is given below:</p>
<div class="highlight-json"><div class="highlight"><pre><span></span><span class="p">{</span>
   <span class="nt">&quot;daetools&quot;</span><span class="p">:</span>
   <span class="p">{</span>
       <span class="nt">&quot;core&quot;</span><span class="p">:</span>
       <span class="p">{</span>
           <span class="nt">&quot;checkForInfiniteNumbers&quot;</span>          <span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
           <span class="nt">&quot;eventTolerance&quot;</span>                   <span class="p">:</span> <span class="mf">1E-7</span><span class="p">,</span>
           <span class="nt">&quot;logIndent&quot;</span>                        <span class="p">:</span> <span class="s2">&quot;    &quot;</span><span class="p">,</span>
           <span class="nt">&quot;pythonIndent&quot;</span>                     <span class="p">:</span> <span class="s2">&quot;    &quot;</span><span class="p">,</span>
           <span class="nt">&quot;checkUnitsConsistency&quot;</span>            <span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
           <span class="nt">&quot;resetLAMatrixAfterDiscontinuity&quot;</span>  <span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
           <span class="nt">&quot;printInfo&quot;</span>                        <span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
           <span class="nt">&quot;nodes&quot;</span><span class="p">:</span>
           <span class="p">{</span>
               <span class="nt">&quot;useNodeMemoryPools&quot;</span>           <span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
               <span class="nt">&quot;deleteNodesThreshold&quot;</span>         <span class="p">:</span> <span class="mi">1000000</span>
           <span class="p">},</span>
           <span class="nt">&quot;equations&quot;</span><span class="p">:</span>
           <span class="p">{</span>
               <span class="nt">&quot;simplifyExpressions&quot;</span>   <span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
               <span class="nt">&quot;evaluationMode&quot;</span>        <span class="p">:</span> <span class="s2">&quot;computeStack_OpenMP&quot;</span><span class="p">,</span>
               <span class="nt">&quot;evaluationTree_OpenMP&quot;</span> <span class="p">:</span> <span class="p">{</span><span class="nt">&quot;numThreads&quot;</span> <span class="p">:</span> <span class="mi">0</span><span class="p">},</span>
               <span class="nt">&quot;computeStack_OpenMP&quot;</span>   <span class="p">:</span> <span class="p">{</span><span class="nt">&quot;numThreads&quot;</span> <span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
           <span class="p">}</span>
       <span class="p">},</span>
       <span class="nt">&quot;activity&quot;</span><span class="p">:</span>
       <span class="p">{</span>
           <span class="nt">&quot;printHeader&quot;</span>                       <span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
           <span class="nt">&quot;printStats&quot;</span>                        <span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
           <span class="nt">&quot;timeHorizon&quot;</span>                       <span class="p">:</span> <span class="mf">100.0</span><span class="p">,</span>
           <span class="nt">&quot;reportingInterval&quot;</span>                 <span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
           <span class="nt">&quot;reportTimeDerivatives&quot;</span>             <span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
           <span class="nt">&quot;reportSensitivities&quot;</span>               <span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
           <span class="nt">&quot;stopAtModelDiscontinuity&quot;</span>          <span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
           <span class="nt">&quot;reportDataAroundDiscontinuities&quot;</span>   <span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
           <span class="nt">&quot;objFunctionAbsoluteTolerance&quot;</span>      <span class="p">:</span> <span class="mf">1E-8</span><span class="p">,</span>
           <span class="nt">&quot;constraintsAbsoluteTolerance&quot;</span>      <span class="p">:</span> <span class="mf">1E-8</span><span class="p">,</span>
           <span class="nt">&quot;measuredVariableAbsoluteTolerance&quot;</span> <span class="p">:</span> <span class="mf">1E-8</span>
       <span class="p">},</span>
       <span class="nt">&quot;datareporting&quot;</span><span class="p">:</span>
       <span class="p">{</span>
           <span class="nt">&quot;tcpipDataReceiverAddress&quot;</span>  <span class="p">:</span> <span class="s2">&quot;127.0.0.1&quot;</span><span class="p">,</span>
           <span class="nt">&quot;tcpipDataReceiverPort&quot;</span>     <span class="p">:</span> <span class="mi">50000</span><span class="p">,</span>
           <span class="nt">&quot;tcpipNumberOfRetries&quot;</span>      <span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
           <span class="nt">&quot;tcpipRetryAfterMilliSecs&quot;</span>  <span class="p">:</span> <span class="mi">1000</span>
       <span class="p">},</span>
       <span class="nt">&quot;logging&quot;</span><span class="p">:</span>
       <span class="p">{</span>
           <span class="nt">&quot;tcpipLogAddress&quot;</span> <span class="p">:</span> <span class="s2">&quot;127.0.0.1&quot;</span><span class="p">,</span>
           <span class="nt">&quot;tcpipLogPort&quot;</span>    <span class="p">:</span> <span class="mi">51000</span>
       <span class="p">},</span>
       <span class="nt">&quot;minlpsolver&quot;</span><span class="p">:</span>
       <span class="p">{</span>
           <span class="nt">&quot;printInfo&quot;</span><span class="p">:</span> <span class="kc">false</span>
       <span class="p">},</span>
       <span class="nt">&quot;IDAS&quot;</span><span class="p">:</span>
       <span class="p">{</span>
           <span class="nt">&quot;relativeTolerance&quot;</span>             <span class="p">:</span> <span class="mf">1E-5</span><span class="p">,</span>
           <span class="nt">&quot;integrationMode&quot;</span>               <span class="p">:</span> <span class="s2">&quot;Normal&quot;</span><span class="p">,</span>
           <span class="nt">&quot;reportDataInOneStepMode&quot;</span>       <span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
           <span class="nt">&quot;nextTimeAfterReinitialization&quot;</span> <span class="p">:</span> <span class="mf">1E-7</span><span class="p">,</span>
           <span class="nt">&quot;printInfo&quot;</span>                     <span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
           <span class="nt">&quot;numberOfSTNRebuildsDuringInitialization&quot;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span>
           <span class="nt">&quot;SensitivitySolutionMethod&quot;</span>     <span class="p">:</span> <span class="s2">&quot;Staggered&quot;</span><span class="p">,</span>
           <span class="nt">&quot;SensErrCon&quot;</span>                    <span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
           <span class="nt">&quot;maxNonlinIters&quot;</span>                <span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
           <span class="nt">&quot;sensRelativeTolerance&quot;</span>         <span class="p">:</span> <span class="mf">1E-5</span><span class="p">,</span>
           <span class="nt">&quot;sensAbsoluteTolerance&quot;</span>         <span class="p">:</span> <span class="mf">1E-5</span><span class="p">,</span>
           <span class="nt">&quot;MaxOrd&quot;</span>            <span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
           <span class="nt">&quot;MaxNumSteps&quot;</span>       <span class="p">:</span> <span class="mi">1000</span><span class="p">,</span>
           <span class="nt">&quot;InitStep&quot;</span>          <span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
           <span class="nt">&quot;MaxStep&quot;</span>           <span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
           <span class="nt">&quot;MaxErrTestFails&quot;</span>   <span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
           <span class="nt">&quot;MaxNonlinIters&quot;</span>    <span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
           <span class="nt">&quot;MaxConvFails&quot;</span>      <span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
           <span class="nt">&quot;NonlinConvCoef&quot;</span>    <span class="p">:</span> <span class="mf">0.33</span><span class="p">,</span>
           <span class="nt">&quot;SuppressAlg&quot;</span>       <span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
           <span class="nt">&quot;NoInactiveRootWarn&quot;</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
           <span class="nt">&quot;NonlinConvCoefIC&quot;</span>  <span class="p">:</span> <span class="mf">0.0033</span><span class="p">,</span>
           <span class="nt">&quot;MaxNumStepsIC&quot;</span>     <span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
           <span class="nt">&quot;MaxNumJacsIC&quot;</span>      <span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
           <span class="nt">&quot;MaxNumItersIC&quot;</span>     <span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
           <span class="nt">&quot;LineSearchOffIC&quot;</span>   <span class="p">:</span> <span class="kc">false</span>
       <span class="p">},</span>
       <span class="nt">&quot;superlu&quot;</span><span class="p">:</span>
       <span class="p">{</span>
           <span class="nt">&quot;factorizationMethod&quot;</span>      <span class="p">:</span> <span class="s2">&quot;SamePattern_SameRowPerm&quot;</span><span class="p">,</span>
           <span class="nt">&quot;useUserSuppliedWorkSpace&quot;</span> <span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
           <span class="nt">&quot;workspaceSizeMultiplier&quot;</span>  <span class="p">:</span> <span class="mf">3.0</span><span class="p">,</span>
           <span class="nt">&quot;workspaceMemoryIncrement&quot;</span> <span class="p">:</span> <span class="mf">1.5</span>
       <span class="p">},</span>
       <span class="nt">&quot;superlu_mt&quot;</span><span class="p">:</span>
       <span class="p">{</span>
           <span class="nt">&quot;numThreads&quot;</span> <span class="p">:</span> <span class="mi">0</span>
       <span class="p">},</span>
       <span class="nt">&quot;intel_pardiso&quot;</span><span class="p">:</span>
       <span class="p">{</span>
           <span class="nt">&quot;numThreads&quot;</span> <span class="p">:</span> <span class="mi">0</span>
       <span class="p">},</span>
       <span class="nt">&quot;BONMIN&quot;</span><span class="p">:</span>
       <span class="p">{</span>
           <span class="nt">&quot;IPOPT&quot;</span><span class="p">:</span>
           <span class="p">{</span>
               <span class="nt">&quot;print_level&quot;</span>          <span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
               <span class="nt">&quot;tol&quot;</span>                  <span class="p">:</span> <span class="mf">1E-5</span><span class="p">,</span>
               <span class="nt">&quot;linear_solver&quot;</span>        <span class="p">:</span> <span class="s2">&quot;mumps&quot;</span><span class="p">,</span>
               <span class="nt">&quot;hessianApproximation&quot;</span> <span class="p">:</span> <span class="s2">&quot;limited-memory&quot;</span><span class="p">,</span>
               <span class="nt">&quot;mu_strategy&quot;</span>          <span class="p">:</span> <span class="s2">&quot;adaptive&quot;</span>
           <span class="p">}</span>
       <span class="p">},</span>
       <span class="nt">&quot;NLOPT&quot;</span><span class="p">:</span>
       <span class="p">{</span>
           <span class="nt">&quot;printInfo&quot;</span>  <span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
           <span class="nt">&quot;xtol_rel&quot;</span>   <span class="p">:</span> <span class="mf">1E-6</span><span class="p">,</span>
           <span class="nt">&quot;xtol_abs&quot;</span>   <span class="p">:</span> <span class="mf">1E-6</span><span class="p">,</span>
           <span class="nt">&quot;ftol_rel&quot;</span>   <span class="p">:</span> <span class="mf">1E-6</span><span class="p">,</span>
           <span class="nt">&quot;ftol_abs&quot;</span>   <span class="p">:</span> <span class="mf">1E-6</span><span class="p">,</span>
           <span class="nt">&quot;constr_tol&quot;</span> <span class="p">:</span> <span class="mf">1E-6</span>
       <span class="p">},</span>
       <span class="nt">&quot;deal_II&quot;</span><span class="p">:</span>
       <span class="p">{</span>
           <span class="nt">&quot;printInfo&quot;</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
           <span class="nt">&quot;assembly&quot;</span><span class="p">:</span>
           <span class="p">{</span>
               <span class="nt">&quot;parallelAssembly&quot;</span> <span class="p">:</span> <span class="s2">&quot;OpenMP&quot;</span><span class="p">,</span>
               <span class="nt">&quot;numThreads&quot;</span>       <span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
               <span class="nt">&quot;queueSize&quot;</span>        <span class="p">:</span> <span class="mi">32</span>
           <span class="p">}</span>
       <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="units-and-quantities">
<h2>6.5. Units and quantities<a class="headerlink" href="#units-and-quantities" title="Permalink to this headline">¶</a></h2>
<p>There are three classes in the framework: <a class="reference internal" href="units.html#pyUnits.base_unit" title="pyUnits.base_unit"><code class="xref py py-class docutils literal"><span class="pre">base_unit</span></code></a>, <a class="reference internal" href="units.html#pyUnits.unit" title="pyUnits.unit"><code class="xref py py-class docutils literal"><span class="pre">unit</span></code></a> and
<a class="reference internal" href="units.html#pyUnits.quantity" title="pyUnits.quantity"><code class="xref py py-class docutils literal"><span class="pre">quantity</span></code></a>.
The <a class="reference internal" href="units.html#pyUnits.base_unit" title="pyUnits.base_unit"><code class="xref py py-class docutils literal"><span class="pre">base_unit</span></code></a> class handles seven SI base dimensions: <cite>length</cite>, <cite>mass</cite>, <cite>time</cite>,
<cite>electric current</cite>, <cite>temperature</cite>, <cite>amount of substance</cite>, and <cite>luminous intensity</cite>
(<cite>m</cite>, <cite>kg</cite>, <cite>s</cite>, <cite>A</cite>, <cite>K</cite>, <cite>mol</cite>, <cite>cd</cite>).
The <a class="reference internal" href="units.html#pyUnits.unit" title="pyUnits.unit"><code class="xref py py-class docutils literal"><span class="pre">unit</span></code></a> class operates on base units defined using the base seven dimensions.
The <a class="reference internal" href="units.html#pyUnits.quantity" title="pyUnits.quantity"><code class="xref py py-class docutils literal"><span class="pre">quantity</span></code></a> class defines a numerical value in terms of a unit of measurement
(it contains the value and its units).</p>
<p>There is a large pool of <cite>base units</cite> and <cite>units</cite> defined (all base and derived SI units) in the
<a class="reference internal" href="units.html#module-pyUnits" title="pyUnits"><code class="xref py py-class docutils literal"><span class="pre">pyUnits</span></code></a> module:</p>
<ul class="simple">
<li>m</li>
<li>s</li>
<li>cd</li>
<li>A</li>
<li>mol</li>
<li>kg</li>
<li>g</li>
<li>t</li>
<li>K</li>
<li>rad</li>
<li>sr</li>
<li>min</li>
<li>hour</li>
<li>day</li>
<li>l</li>
<li>dl</li>
<li>ml</li>
<li>N</li>
<li>J</li>
<li>W</li>
<li>V</li>
<li>C</li>
<li>F</li>
<li>Ohm</li>
<li>T</li>
<li>H</li>
<li>S</li>
<li>Wb</li>
<li>Pa</li>
<li>P</li>
<li>St</li>
<li>Bq</li>
<li>Gy</li>
<li>Sv</li>
<li>lx</li>
<li>lm</li>
<li>kat</li>
<li>knot</li>
<li>bar</li>
<li>b</li>
<li>Ci</li>
<li>R</li>
<li>rd</li>
<li>rem</li>
</ul>
<p>and all above with 20 SI prefixes:</p>
<ul class="simple">
<li>yotta = 1E+24 (symbol Y)</li>
<li>zetta = 1E+21 (symbol Z)</li>
<li>exa   = 1E+18 (symbol E)</li>
<li>peta  = 1E+15 (symbol P)</li>
<li>tera  = 1E+12 (symbol T)</li>
<li>giga  = 1E+9 (symbol G)</li>
<li>mega  = 1E+6 (symbol M)</li>
<li>kilo  = 1E+3 (symbol k)</li>
<li>hecto = 1E+2 (symbol h)</li>
<li>deka  = 1E+1 (symbol da)</li>
<li>deci  = 1E-1 (symbol d)</li>
<li>centi = 1E-2 (symbol c)</li>
<li>milli = 1E-3 (symbol m)</li>
<li>micro = 1E-6 (symbol u)</li>
<li>nano  = 1E-9 (symbol n)</li>
<li>pico  = 1E-12 (symbol p)</li>
<li>femto = 1E-15 (symbol f)</li>
<li>atto  = 1E-18 (symbol a)</li>
<li>zepto = 1E-21 (symbol z)</li>
<li>yocto = 1E-24 (symbol y)</li>
</ul>
<p>for instance: kmol (kilo mol), MW (mega Watt), ug (micro gram) etc.</p>
<p>New units can be defined in the following way:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">rho</span> <span class="o">=</span> <span class="n">unit</span><span class="p">({</span><span class="s2">&quot;kg&quot;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;dm&quot;</span><span class="p">:</span><span class="o">-</span><span class="mi">3</span><span class="p">})</span>
</pre></div>
</div>
<p>The constructor accepts a dictionary of <cite>base_unit : exponent</cite> items as its argument.
The above defines a new density unit <span class="math">\(\frac{kg}{dm^3}\)</span>.</p>
<p>The unit class defines mathematical operators <cite>*</cite>, <cite>/</cite> and <cite>**</cite> to allow creation of derived units.
Thus, the density unit can be also defined in the following way:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">mass</span>   <span class="o">=</span> <span class="n">unit</span><span class="p">({</span><span class="s2">&quot;kg&quot;</span> <span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
<span class="n">volume</span> <span class="o">=</span> <span class="n">unit</span><span class="p">({</span><span class="s2">&quot;dm&quot;</span> <span class="p">:</span> <span class="mi">3</span><span class="p">})</span>
<span class="n">rho</span> <span class="o">=</span> <span class="n">mass</span> <span class="o">/</span> <span class="n">volume</span>
</pre></div>
</div>
<p>Quantities are created by multiplying a value with unit objects:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">heat</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">J</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="units.html#pyUnits.quantity" title="pyUnits.quantity"><code class="xref py py-class docutils literal"><span class="pre">quantity</span></code></a> class defines all mathematical operators (<cite>+, -, *, / and **</cite>) and mathematical functions.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">heat</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">J</span>
<span class="n">time</span> <span class="o">=</span> <span class="mi">12</span> <span class="o">*</span> <span class="n">s</span>
<span class="n">power</span> <span class="o">=</span> <span class="n">heat</span> <span class="o">/</span> <span class="n">time</span>
</pre></div>
</div>
<p>Units-consistency of equations and logical conditions is strictly enforced (although it can be switched off, if required).
For instance, the operation below is not allowed:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">power</span> <span class="o">=</span> <span class="n">heat</span> <span class="o">+</span> <span class="n">time</span>
</pre></div>
</div>
<p>since their units are not consistent (<cite>J + s</cite>).</p>
</div>
<div class="section" id="logging">
<h2>6.6. Logging<a class="headerlink" href="#logging" title="Permalink to this headline">¶</a></h2>
<p>Log objects define an API for sending messages from a simulation to the user.
Currently three implementations exist: <a class="reference internal" href="log.html#pyCore.daeStdOutLog" title="pyCore.daeStdOutLog"><code class="xref py py-class docutils literal"><span class="pre">daeStdOutLog</span></code></a> (prints messages to the standard c++ output),
<a class="reference internal" href="log.html#daetools.pyDAE.logs.daePythonStdOutLog" title="daetools.pyDAE.logs.daePythonStdOutLog"><code class="xref py py-class docutils literal"><span class="pre">daePythonStdOutLog</span></code></a> (prints messages using Python <code class="xref py py-func docutils literal"><span class="pre">print()</span></code> function),
<a class="reference internal" href="log.html#pyCore.daeFileLog" title="pyCore.daeFileLog"><code class="xref py py-class docutils literal"><span class="pre">daeFileLog</span></code></a> (stores messages into a specified text file), and <a class="reference internal" href="log.html#pyCore.daeTCPIPLog" title="pyCore.daeTCPIPLog"><code class="xref py py-class docutils literal"><span class="pre">daeTCPIPLog</span></code></a>
(sends messages via TCP/IP protocol to the <a class="reference internal" href="log.html#pyCore.daeTCPIPLogServer" title="pyCore.daeTCPIPLogServer"><code class="xref py py-class docutils literal"><span class="pre">daeTCPIPLogServer</span></code></a>).</p>
<p>The messages are sent using <a class="reference internal" href="log.html#pyCore.daeLog_t.Message" title="pyCore.daeLog_t.Message"><code class="xref py py-meth docutils literal"><span class="pre">Message()</span></code></a> function.</p>
</div>
<div class="section" id="dae-solvers">
<h2>6.7. DAE Solvers<a class="headerlink" href="#dae-solvers" title="Permalink to this headline">¶</a></h2>
<p>Currently, only <a class="reference external" href="https://computation.llnl.gov/casc/sundials/main.html">Sundials IDAS</a>
solver is supported for the numerical solution of DAE systems and for calculation of sensitivities.</p>
<p>DAE solvers have some user-tunable options such as <cite>relative</cite> and <cite>absolute tolerances</cite> used to control
the accuracy of the integration process.
In <strong>DAE Tools</strong>, scalar relative and a vector of absolute tolerances are used.
Every variable has the default absolute tolerances set in the associated variable type.
These default values can be changed during the initialisation of the system (in <a class="reference internal" href="activity.html#pyActivity.daeSimulation.SetUpVariables" title="pyActivity.daeSimulation.SetUpVariables"><code class="xref py py-meth docutils literal"><span class="pre">SetUpVariables()</span></code></a>)
using the <a class="reference internal" href="core.html#pyCore.daeVariable.SetAbsoluteTolerances" title="pyCore.daeVariable.SetAbsoluteTolerances"><code class="xref py py-meth docutils literal"><span class="pre">SetAbsoluteTolerances()</span></code></a> function.
On the other hand, the scalar relative tolerance can be set using the <code class="xref py py-attr docutils literal"><span class="pre">RelativeTolerance</span></code> attribute
or in the <cite>daetools.cfg</cite> configuration file. The default value is <span class="math">\(10^{-5}\)</span>.</p>
<p>The DAE solver statistic can be obtained after every call to one of <a class="reference internal" href="activity.html#pyActivity.daeSimulation.Integrate" title="pyActivity.daeSimulation.Integrate"><code class="xref py py-meth docutils literal"><span class="pre">Integrate()</span></code></a>
functions using the <a class="reference internal" href="dae_solver.html#pyIDAS.daeIDAS.IntegratorStats" title="pyIDAS.daeIDAS.IntegratorStats"><code class="xref py py-attr docutils literal"><span class="pre">IntegratorStats</span></code></a> attribute.
It contains statistics returned by <code class="xref py py-func docutils literal"><span class="pre">IDAGetIntegratorStats()</span></code> and <code class="xref py py-func docutils literal"><span class="pre">IDAGetNonlinSolvStats()</span></code>
Sundials IDAS functions.
<a class="reference internal" href="dae_solver.html#pyIDAS.daeIDAS.IntegratorStats" title="pyIDAS.daeIDAS.IntegratorStats"><code class="xref py py-attr docutils literal"><span class="pre">IntegratorStats</span></code></a> attribute is a dictionary with the following data:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">stats</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ActualInitStep&#39;</span><span class="p">:</span> <span class="mf">0.00104</span><span class="p">,</span>
         <span class="s1">&#39;CurrentOrder&#39;</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">,</span>
         <span class="s1">&#39;CurrentStep&#39;</span><span class="p">:</span> <span class="mf">89.01075</span><span class="p">,</span>
         <span class="s1">&#39;CurrentTime&#39;</span><span class="p">:</span> <span class="mf">1000.0</span><span class="p">,</span>
         <span class="s1">&#39;LastOrder&#39;</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">,</span>
         <span class="s1">&#39;LastStep&#39;</span><span class="p">:</span> <span class="mf">44.50537</span><span class="p">,</span>
         <span class="s1">&#39;NumErrTestFails&#39;</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">,</span>
         <span class="s1">&#39;NumLinSolvSetups&#39;</span><span class="p">:</span> <span class="mf">22.0</span><span class="p">,</span>
         <span class="s1">&#39;NumNonlinSolvConvFails&#39;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
         <span class="s1">&#39;NumNonlinSolvIters&#39;</span><span class="p">:</span> <span class="mf">128.0</span><span class="p">,</span>
         <span class="s1">&#39;NumResEvals&#39;</span><span class="p">:</span> <span class="mf">130.0</span><span class="p">,</span>
         <span class="s1">&#39;NumSteps&#39;</span><span class="p">:</span> <span class="mf">91.0</span><span class="p">}</span>
</pre></div>
</div>
<p><a class="reference internal" href="dae_solver.html#pyIDAS.daeIDAS" title="pyIDAS.daeIDAS"><code class="xref py py-class docutils literal"><span class="pre">daeIDAS</span></code></a> class contains the following functions:</p>
<ul class="simple">
<li><a class="reference internal" href="dae_solver.html#pyIDAS.daeIDAS.OnCalculateResiduals" title="pyIDAS.daeIDAS.OnCalculateResiduals"><code class="xref py py-meth docutils literal"><span class="pre">OnCalculateResiduals()</span></code></a> (called after every evaluation of residuals)</li>
<li><a class="reference internal" href="dae_solver.html#pyIDAS.daeIDAS.OnCalculateJacobian" title="pyIDAS.daeIDAS.OnCalculateJacobian"><code class="xref py py-meth docutils literal"><span class="pre">OnCalculateJacobian()</span></code></a> (called after every evaluation of Jacobian matrix)</li>
<li><a class="reference internal" href="dae_solver.html#pyIDAS.daeIDAS.OnCalculateConditions" title="pyIDAS.daeIDAS.OnCalculateConditions"><code class="xref py py-meth docutils literal"><span class="pre">OnCalculateConditions()</span></code></a> (called after every evaluation of logical conditions used in discontinuous equations)</li>
<li><a class="reference internal" href="dae_solver.html#pyIDAS.daeIDAS.OnCalculateSensitivityResiduals" title="pyIDAS.daeIDAS.OnCalculateSensitivityResiduals"><code class="xref py py-meth docutils literal"><span class="pre">OnCalculateSensitivityResiduals()</span></code></a> (called after every evaluation of sensitivity residuals)</li>
</ul>
<p>The current iteration variable values, time derivatives, residuals, Jacobian matrix and sensitivity residuals
can be accessed using the following properties:</p>
<ul class="simple">
<li><a class="reference internal" href="dae_solver.html#pyIDAS.daeIDAS.Values" title="pyIDAS.daeIDAS.Values"><code class="xref py py-attr docutils literal"><span class="pre">Values</span></code></a> (<code class="xref py py-class docutils literal"><span class="pre">daeRawDataArray</span></code> object that wraps the IDAS vector data structure)</li>
<li><a class="reference internal" href="dae_solver.html#pyIDAS.daeIDAS.TimeDerivatives" title="pyIDAS.daeIDAS.TimeDerivatives"><code class="xref py py-attr docutils literal"><span class="pre">TimeDerivatives</span></code></a> (<code class="xref py py-class docutils literal"><span class="pre">daeRawDataArray</span></code> object)</li>
<li><a class="reference internal" href="dae_solver.html#pyIDAS.daeIDAS.Residuals" title="pyIDAS.daeIDAS.Residuals"><code class="xref py py-attr docutils literal"><span class="pre">Residuals</span></code></a> (<code class="xref py py-class docutils literal"><span class="pre">daeRawDataArray</span></code> object)</li>
<li><a class="reference internal" href="dae_solver.html#pyIDAS.daeIDAS.Jacobian" title="pyIDAS.daeIDAS.Jacobian"><code class="xref py py-attr docutils literal"><span class="pre">Jacobian</span></code></a> (<code class="xref py py-class docutils literal"><span class="pre">daeDenseMatrix</span></code> object)</li>
<li><a class="reference internal" href="dae_solver.html#pyIDAS.daeIDAS.SensitivityResiduals" title="pyIDAS.daeIDAS.SensitivityResiduals"><code class="xref py py-attr docutils literal"><span class="pre">SensitivityResiduals</span></code></a> (<code class="xref py py-class docutils literal"><span class="pre">daeDenseMatrix</span></code> object)</li>
</ul>
<p>User-defined functions can be attached to <a class="reference internal" href="dae_solver.html#pyIDAS.daeIDAS" title="pyIDAS.daeIDAS"><code class="xref py py-class docutils literal"><span class="pre">daeIDAS</span></code></a> objects. For instance:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">log</span>          <span class="o">=</span> <span class="n">daePythonStdOutLog</span><span class="p">()</span>
<span class="n">daesolver</span>    <span class="o">=</span> <span class="n">daeIDAS</span><span class="p">()</span>
<span class="n">datareporter</span> <span class="o">=</span> <span class="n">daeTCPIPDataReporter</span><span class="p">()</span>
<span class="n">simulation</span>   <span class="o">=</span> <span class="n">simTutorial</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">OnCalculateResiduals</span><span class="p">():</span>
    <span class="c1"># In general, this function is a member of daeIDAS class.</span>
    <span class="c1"># However, non-member functions can also be attached and the global daesolver object used.</span>
    <span class="n">y</span>   <span class="o">=</span> <span class="n">daesolver</span><span class="o">.</span><span class="n">Values</span>
    <span class="n">yt</span>  <span class="o">=</span> <span class="n">daesolver</span><span class="o">.</span><span class="n">TimeDerivatives</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">daesolver</span><span class="o">.</span><span class="n">Residuals</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;y: </span><span class="si">% s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">y</span><span class="o">.</span><span class="n">Values</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;yt: </span><span class="si">% s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">yt</span><span class="o">.</span><span class="n">Values</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;residuals: </span><span class="si">% s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">res</span><span class="o">.</span><span class="n">Values</span><span class="p">)</span>

<span class="n">daesolver</span><span class="o">.</span><span class="n">OnCalculateResiduals</span> <span class="o">=</span> <span class="n">OnCalculateResiduals</span>
</pre></div>
</div>
</div>
<div class="section" id="linear-equation-solvers">
<h2>6.8. Linear Equation Solvers<a class="headerlink" href="#linear-equation-solvers" title="Permalink to this headline">¶</a></h2>
<p><strong>DAE Tools</strong> support direct dense and sparse matrix linear equation (LA) solvers (sequential and multi-threaded versions).
In addition to the built-in Sundials dense linear solver, several third party libraries are interfaced:
<a class="reference external" href="http://crd.lbl.gov/~xiaoye/SuperLU/index.html">SuperLU/SuperLU_MT</a>,
<a class="reference external" href="http://www.pardiso-project.org">Pardiso</a>,
<a class="reference external" href="http://software.intel.com/en-us/intel-mkl">Intel Pardiso</a>,
<a class="reference external" href="http://trilinos.sandia.gov/packages/amesos/">Trilinos Amesos</a> (KLU, Umfpack, SuperLU, Lapack),
and <a class="reference external" href="http://trilinos.sandia.gov/packages/aztecoo">Trilinos AztecOO</a> (with built-in, Ifpack or ML preconditioners):</p>
<ul class="simple">
<li>Trilinos (Amesos, AztecOO):
<code class="xref py py-class docutils literal"><span class="pre">pyTrilinos</span></code> class from <code class="xref py py-mod docutils literal"><span class="pre">daetools.solvers.trilinos</span></code> module.</li>
<li>SuperLU:
<code class="xref py py-class docutils literal"><span class="pre">pySuperLU</span></code> class from <code class="xref py py-mod docutils literal"><span class="pre">daetools.solvers.superlu</span></code> module.</li>
<li>SuperLU_MT:
<code class="xref py py-class docutils literal"><span class="pre">pySuperLU_MT</span></code> class from <code class="xref py py-mod docutils literal"><span class="pre">daetools.solvers.superlu_mt</span></code> module.</li>
<li>Pardiso:
<code class="xref py py-class docutils literal"><span class="pre">pyPardiso</span></code> class from <code class="xref py py-mod docutils literal"><span class="pre">daetools.solvers.pardiso</span></code> module.</li>
<li>Intel Pardiso:
<code class="xref py py-class docutils literal"><span class="pre">pyIntelPardiso</span></code> class from <code class="xref py py-mod docutils literal"><span class="pre">daetools.solvers.intel_pardiso</span></code> module.</li>
</ul>
<p>Modules are imported in the following way:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># 1. Import Trilinos solver:</span>
<span class="c1">#    - direct: Amesos_KLU, Amesos_Superlu, Amesos_Umfpack, Amesos_Lapack</span>
<span class="c1">#    - iterative: AztecOO, AztecOO_Ifpack, AztecOO_ML</span>
<span class="c1">#    The list of available solvers can be obtained using the function</span>
<span class="c1">#    pyTrilinos.daeTrilinosSupportedSolvers().</span>
<span class="kn">from</span> <span class="nn">daetools.solvers.trilinos</span> <span class="kn">import</span> <span class="n">pyTrilinos</span>

<span class="c1"># a) Amesos SuperLU solver</span>
<span class="n">lasolver</span> <span class="o">=</span> <span class="n">pyTrilinos</span><span class="o">.</span><span class="n">daeCreateTrilinosSolver</span><span class="p">(</span><span class="s2">&quot;Amesos_Superlu&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

<span class="c1"># b) AztecOO built-in preconditioners are specified through AZ_precond option</span>
<span class="n">lasolver</span> <span class="o">=</span> <span class="n">pyTrilinos</span><span class="o">.</span><span class="n">daeCreateTrilinosSolver</span><span class="p">(</span><span class="s2">&quot;AztecOO&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

<span class="c1"># c) Ifpack preconditioner can be one of: [ILU, ILUT, PointRelaxation, BlockRelaxation, IC, ICT]</span>
<span class="n">lasolver</span> <span class="o">=</span> <span class="n">pyTrilinos</span><span class="o">.</span><span class="n">daeCreateTrilinosSolver</span><span class="p">(</span><span class="s2">&quot;AztecOO_Ifpack&quot;</span><span class="p">,</span> <span class="s2">&quot;PointRelaxation&quot;</span><span class="p">)</span>

<span class="c1"># d) ML preconditioner can be one of: [SA, DD, DD-ML, DD-ML-LU, maxwell, NSSA]</span>
<span class="n">lasolver</span> <span class="o">=</span> <span class="n">pyTrilinos</span><span class="o">.</span><span class="n">daeCreateTrilinosSolver</span><span class="p">(</span><span class="s2">&quot;AztecOO_ML&quot;</span><span class="p">,</span> <span class="s2">&quot;maxwell&quot;</span><span class="p">)</span>

<span class="c1"># 2. Import SuperLU solver:</span>
<span class="kn">from</span> <span class="nn">daetools.solvers.superlu</span> <span class="kn">import</span> <span class="n">pySuperLU</span>
<span class="n">lasolver</span> <span class="o">=</span> <span class="n">pySuperLU</span><span class="o">.</span><span class="n">daeCreateSuperLUSolver</span><span class="p">()</span>

<span class="c1"># 3. Import SuperLU_MT solver:</span>
<span class="kn">from</span> <span class="nn">daetools.solvers.superlu_mt</span> <span class="kn">import</span> <span class="n">pySuperLU_MT</span>
<span class="n">lasolver</span> <span class="o">=</span> <span class="n">pySuperLU_MT</span><span class="o">.</span><span class="n">daeCreateSuperLUSolver</span><span class="p">()</span>

<span class="c1"># 4. Import Pardiso solver:</span>
<span class="kn">from</span> <span class="nn">daetools.solvers.pardiso</span> <span class="kn">import</span> <span class="n">pyPardiso</span>
<span class="n">lasolver</span> <span class="o">=</span> <span class="n">pyPardiso</span><span class="o">.</span><span class="n">daeCreatePardisoSolver</span><span class="p">()</span>

<span class="c1"># 5. Import Intel Pardiso solver:</span>
<span class="kn">from</span> <span class="nn">daetools.solvers.intel_pardiso</span> <span class="kn">import</span> <span class="n">pyIntelPardiso</span>
<span class="n">lasolver</span> <span class="o">=</span> <span class="n">pyIntelPardiso</span><span class="o">.</span><span class="n">daeCreateIntelPardisoSolver</span><span class="p">()</span>
</pre></div>
</div>
<p>Once loaded, the linear solver object must be set in the DAE Solver:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">daesolver</span><span class="o">.</span><span class="n">SetLASolver</span><span class="p">(</span><span class="n">lasolver</span><span class="p">)</span>
</pre></div>
</div>
<p>The incidence matrix of the DAE system can be saved in the text-only .xpm format:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">lasolver</span><span class="o">.</span><span class="n">SaveAsXPM</span><span class="p">(</span><span class="s1">&#39;path to .xpm&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="data-reporting">
<h2>6.9. Data Reporting<a class="headerlink" href="#data-reporting" title="Permalink to this headline">¶</a></h2>
<p>Simulation results are obtained using the data reporter and data receiver concepts.
Data reporter defines a functionality used by a simulation object to report the simulation results.
Data receiver defines a functionality/data structures for accessing the simulation results.</p>
<p>By default, parameters and variables are <strong>not</strong> reported to a data reporter.
Individual parameters/variables can be selected/deselected using the <a class="reference internal" href="core.html#pyCore.daeVariable.ReportingOn" title="pyCore.daeVariable.ReportingOn"><code class="xref py py-attr docutils literal"><span class="pre">ReportingOn</span></code></a> boolean property,
while all variables from a model and all child-models can be reported using the <a class="reference internal" href="core.html#pyCore.daeModel.SetReportingOn" title="pyCore.daeModel.SetReportingOn"><code class="xref py py-meth docutils literal"><span class="pre">SetReportingOn()</span></code></a> function.
In addition, time derivatives for all enabled variables can be reported using the <a class="reference internal" href="activity.html#pyActivity.daeSimulation.ReportTimeDerivatives" title="pyActivity.daeSimulation.ReportTimeDerivatives"><code class="xref py py-attr docutils literal"><span class="pre">ReportTimeDerivatives</span></code></a>
property. If sensitivity analysis is enabled, the sensitivities for all enabled variables can be reported using the
<a class="reference internal" href="activity.html#pyActivity.daeSimulation.ReportSensitivities" title="pyActivity.daeSimulation.ReportSensitivities"><code class="xref py py-attr docutils literal"><span class="pre">ReportSensitivities</span></code></a> property.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Enable reporting of all variables</span>
<span class="n">simulation</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">SetReportingOn</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># Enable reporting of time derivatives for all reported variables</span>
<span class="n">simulation</span><span class="o">.</span><span class="n">ReportTimeDerivatives</span> <span class="o">=</span> <span class="bp">True</span>

<span class="c1"># Enable reporting of sensitivities for all reported variables</span>
<span class="n">simulation</span><span class="o">.</span><span class="n">ReportSensitivities</span> <span class="o">=</span> <span class="bp">True</span>
</pre></div>
</div>
<p>There is a large number of available data reporters in <strong>DAE Tools</strong>:</p>
<ul class="simple">
<li>Data reporters that export results to a specified file format:<ul>
<li>Matlab .mat file (<a class="reference internal" href="data_reporting.html#daetools.pyDAE.data_reporters.daeMatlabMATFileDataReporter" title="daetools.pyDAE.data_reporters.daeMatlabMATFileDataReporter"><code class="xref py py-class docutils literal"><span class="pre">daeMatlabMATFileDataReporter</span></code></a>)</li>
<li>Excell .xls file (<a class="reference internal" href="data_reporting.html#daetools.pyDAE.data_reporters.daeExcelFileDataReporter" title="daetools.pyDAE.data_reporters.daeExcelFileDataReporter"><code class="xref py py-class docutils literal"><span class="pre">daeExcelFileDataReporter</span></code></a>)</li>
<li>VTK file (<code class="xref py py-class docutils literal"><span class="pre">daeVTKFileDataReporter</span></code>)</li>
<li>HDF5 file (<a class="reference internal" href="data_reporting.html#daetools.pyDAE.data_reporters.daeHDF5FileDataReporter" title="daetools.pyDAE.data_reporters.daeHDF5FileDataReporter"><code class="xref py py-class docutils literal"><span class="pre">daeHDF5FileDataReporter</span></code></a>)</li>
<li>CSV file (<code class="xref py py-class docutils literal"><span class="pre">daeCSVFileDataReporter</span></code>)</li>
<li>XML file (<a class="reference internal" href="data_reporting.html#daetools.pyDAE.data_reporters.daeXMLFileDataReporter" title="daetools.pyDAE.data_reporters.daeXMLFileDataReporter"><code class="xref py py-class docutils literal"><span class="pre">daeXMLFileDataReporter</span></code></a>)</li>
<li>JSON format (<a class="reference internal" href="data_reporting.html#daetools.pyDAE.data_reporters.daeJSONFileDataReporter" title="daetools.pyDAE.data_reporters.daeJSONFileDataReporter"><code class="xref py py-class docutils literal"><span class="pre">daeJSONFileDataReporter</span></code></a>)</li>
<li>Python pickle (<a class="reference internal" href="data_reporting.html#daetools.pyDAE.data_reporters.daePickleDataReporter" title="daetools.pyDAE.data_reporters.daePickleDataReporter"><code class="xref py py-class docutils literal"><span class="pre">daePickleDataReporter</span></code></a>)
which can be opened in DAE Plotter or unpickled directly</li>
</ul>
</li>
<li>Simple data reporters<ul>
<li>Data reporter that only stores results internally but does nothing with the data
(<a class="reference internal" href="data_reporting.html#pyDataReporting.daeNoOpDataReporter" title="pyDataReporting.daeNoOpDataReporter"><code class="xref py py-class docutils literal"><span class="pre">daeNoOpDataReporter</span></code></a>)</li>
<li>Data reporter that does not store and does not process the results;
useful when the results are not needed (<a class="reference internal" href="data_reporting.html#pyDataReporting.daeBlackHoleDataReporter" title="pyDataReporting.daeBlackHoleDataReporter"><code class="xref py py-class docutils literal"><span class="pre">daeBlackHoleDataReporter</span></code></a>)</li>
</ul>
</li>
<li>Other types of data reporters<ul>
<li>Pandas dataset (<a class="reference internal" href="data_reporting.html#daetools.pyDAE.data_reporters.daePandasDataReporter" title="daetools.pyDAE.data_reporters.daePandasDataReporter"><code class="xref py py-class docutils literal"><span class="pre">daePandasDataReporter</span></code></a>)</li>
<li>Quick matplotlib plots (<a class="reference internal" href="data_reporting.html#daetools.pyDAE.data_reporters.daePlotDataReporter" title="daetools.pyDAE.data_reporters.daePlotDataReporter"><code class="xref py py-class docutils literal"><span class="pre">daePlotDataReporter</span></code></a>)</li>
<li>A container that delegates all calls to the contained data reporters; can contain
one or more data reporters; useful to produce results in more than one format
(<a class="reference internal" href="data_reporting.html#pyDataReporting.daeDelegateDataReporter" title="pyDataReporting.daeDelegateDataReporter"><code class="xref py py-class docutils literal"><span class="pre">daeDelegateDataReporter</span></code></a>)</li>
</ul>
</li>
<li>Base-classes that can be used for development of custom data reporters:<ul>
<li><a class="reference internal" href="data_reporting.html#pyDataReporting.daeDataReporterLocal" title="pyDataReporting.daeDataReporterLocal"><code class="xref py py-class docutils literal"><span class="pre">daeDataReporterLocal</span></code></a>
(stores results internally; can be used for any type of processing)</li>
<li><a class="reference internal" href="data_reporting.html#pyDataReporting.daeDataReporterFile" title="pyDataReporting.daeDataReporterFile"><code class="xref py py-class docutils literal"><span class="pre">daeDataReporterFile</span></code></a>
(saves the results into a file in the <a class="reference internal" href="data_reporting.html#pyDataReporting.daeDataReporterFile.WriteDataToFile" title="pyDataReporting.daeDataReporterFile.WriteDataToFile"><code class="xref py py-meth docutils literal"><span class="pre">WriteDataToFile()</span></code></a> virtual member function)</li>
</ul>
</li>
</ul>
<p>The best starting point in creating custom data reporters is <a class="reference internal" href="data_reporting.html#pyDataReporting.daeDataReporterLocal" title="pyDataReporting.daeDataReporterLocal"><code class="xref py py-class docutils literal"><span class="pre">daeDataReporterLocal</span></code></a> class.
It internally does all the processing and offers to users the <a class="reference internal" href="data_reporting.html#pyDataReporting.daeDataReporterLocal.Process" title="pyDataReporting.daeDataReporterLocal.Process"><code class="xref py py-attr docutils literal"><span class="pre">Process</span></code></a>
property (<a class="reference internal" href="data_reporting.html#pyDataReporting.daeDataReceiverProcess" title="pyDataReporting.daeDataReceiverProcess"><code class="xref py py-class docutils literal"><span class="pre">daeDataReceiverProcess</span></code></a> instance) which contains all domains, parameters and variables in the simulation.</p>
<p>The following functions have to be implemented (overloaded):</p>
<ul class="simple">
<li><code class="xref py py-meth docutils literal"><span class="pre">Connect()</span></code>:
Connects the data reporter. In the case when the local data reporter is used
it may contain a file name, for instance.</li>
<li><code class="xref py py-meth docutils literal"><span class="pre">Disconnect()</span></code>:
Disconnects the data reporter.</li>
<li><code class="xref py py-meth docutils literal"><span class="pre">IsConnected()</span></code>:
Checks if the data reporter is connected or not.</li>
</ul>
<p>All functions must return <cite>True</cite> if successful or <cite>False</cite> otherwise.</p>
<p>An empty custom data reporter is presented below:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyDataReporter</span><span class="p">(</span><span class="n">daeDataReporterLocal</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">daeDataReporterLocal</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ConnectString</span><span class="p">,</span> <span class="n">ProcessName</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">Disconnect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">IsConnected</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="o">...</span>
        <span class="k">return</span> <span class="bp">True</span>
</pre></div>
</div>
<p>To write the results into a file the <a class="reference internal" href="data_reporting.html#pyDataReporting.daeDataReporterFile" title="pyDataReporting.daeDataReporterFile"><code class="xref py py-class docutils literal"><span class="pre">daeDataReporterFile</span></code></a> base class can be used.
It writes the data into a file in the <a class="reference internal" href="data_reporting.html#pyDataReporting.daeDataReporterFile.WriteDataToFile" title="pyDataReporting.daeDataReporterFile.WriteDataToFile"><code class="xref py py-meth docutils literal"><span class="pre">WriteDataToFile()</span></code></a> function
called in the <code class="xref py py-meth docutils literal"><span class="pre">Disconnect()</span></code> function.
The only function that needs to be overloaded is <a class="reference internal" href="data_reporting.html#pyDataReporting.daeDataReporterFile.WriteDataToFile" title="pyDataReporting.daeDataReporterFile.WriteDataToFile"><code class="xref py py-meth docutils literal"><span class="pre">WriteDataToFile()</span></code></a>
while the base class handles all other operations.</p>
<p><a class="reference internal" href="data_reporting.html#pyDataReporting.daeDataReceiverProcess" title="pyDataReporting.daeDataReceiverProcess"><code class="xref py py-class docutils literal"><span class="pre">daeDataReceiverProcess</span></code></a> class contains the following properties that can be used
to obtain the results data from a data reporter:</p>
<ul class="simple">
<li><a class="reference internal" href="data_reporting.html#pyDataReporting.daeDataReceiverProcess.Domains" title="pyDataReporting.daeDataReceiverProcess.Domains"><code class="xref py py-attr docutils literal"><span class="pre">Domains</span></code></a> (list of <a class="reference internal" href="data_reporting.html#pyDataReporting.daeDataReceiverDomain" title="pyDataReporting.daeDataReceiverDomain"><code class="xref py py-class docutils literal"><span class="pre">daeDataReceiverDomain</span></code></a> objects)</li>
<li><a class="reference internal" href="data_reporting.html#pyDataReporting.daeDataReceiverProcess.Variables" title="pyDataReporting.daeDataReceiverProcess.Variables"><code class="xref py py-attr docutils literal"><span class="pre">Variables</span></code></a> (list of <a class="reference internal" href="data_reporting.html#pyDataReporting.daeDataReceiverVariable" title="pyDataReporting.daeDataReceiverVariable"><code class="xref py py-class docutils literal"><span class="pre">daeDataReceiverVariable</span></code></a> objects)</li>
<li><a class="reference internal" href="data_reporting.html#pyDataReporting.daeDataReceiverProcess.dictDomains" title="pyDataReporting.daeDataReceiverProcess.dictDomains"><code class="xref py py-attr docutils literal"><span class="pre">dictDomains</span></code></a> (dictionary {&#8220;domain_name&#8221; : <a class="reference internal" href="data_reporting.html#pyDataReporting.daeDataReceiverDomain" title="pyDataReporting.daeDataReceiverDomain"><code class="xref py py-class docutils literal"><span class="pre">daeDataReceiverDomain</span></code></a> object})</li>
<li><a class="reference internal" href="data_reporting.html#pyDataReporting.daeDataReceiverProcess.dictVariables" title="pyDataReporting.daeDataReceiverProcess.dictVariables"><code class="xref py py-attr docutils literal"><span class="pre">dictVariables</span></code></a> (dictionary {&#8220;variable_name&#8221; : <a class="reference internal" href="data_reporting.html#pyDataReporting.daeDataReceiverVariable" title="pyDataReporting.daeDataReceiverVariable"><code class="xref py py-class docutils literal"><span class="pre">daeDataReceiverVariable</span></code></a> object})</li>
<li><a class="reference internal" href="data_reporting.html#pyDataReporting.daeDataReceiverProcess.dictVariableValues" title="pyDataReporting.daeDataReceiverProcess.dictVariableValues"><code class="xref py py-attr docutils literal"><span class="pre">dictVariableValues</span></code></a> (dictionary {&#8220;variable_name&#8221; : (ndarray_values, ndarray_time_points, domain_names, units)})
where <cite>ndarray_values</cite> is numpy array with values at every time point, <cite>ndarray_time_points</cite> is numpy array of time points,
<cite>domains</cite> is a list of domain points for every domain on which the variable is distributed, and <cite>units</cite> is string with the units.</li>
</ul>
<p>The example below shows how to save the results to the Matlab .mat file:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyDataReporter</span><span class="p">(</span><span class="n">daeDataReporterFile</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">daeDataReporterFile</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WriteDataToFile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mdict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Process</span><span class="o">.</span><span class="n">Variables</span><span class="p">:</span>
            <span class="n">mdict</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">Name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">Values</span>

        <span class="kn">import</span> <span class="nn">scipy.io</span>
        <span class="n">scipy</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">savemat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ConnectString</span><span class="p">,</span>
                         <span class="n">mdict</span><span class="p">,</span>
                         <span class="n">appendmat</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                         <span class="n">format</span><span class="o">=</span><span class="s1">&#39;5&#39;</span><span class="p">,</span>
                         <span class="n">long_field_names</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                         <span class="n">do_compression</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                         <span class="n">oned_as</span><span class="o">=</span><span class="s1">&#39;row&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The filename is provided as the first argument (<cite>connectString</cite>) of the
<code class="xref py py-meth docutils literal"><span class="pre">Connect()</span></code> function.</p>
<p>Only one data receiver is implemented: <a class="reference internal" href="data_reporting.html#pyDataReporting.daeTCPIPDataReceiver" title="pyDataReporting.daeTCPIPDataReceiver"><code class="xref py py-class docutils literal"><span class="pre">daeTCPIPDataReceiver</span></code></a>.
It is used by the <strong>DAE Plotter</strong> application to receive the results.</p>
<div class="section" id="dae-plotter-application">
<h3>6.9.1. DAE Plotter Application<a class="headerlink" href="#dae-plotter-application" title="Permalink to this headline">¶</a></h3>
<p>The simulation results can be plotted using the <strong>DAE Tools Plotter</strong> application.
It can be started using one of the following commands:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="c1"># Platform independent:</span>
python -m daetools.dae_plotter.plotter

<span class="c1"># GNU/Linux and macOS:</span>
daeplotter

<span class="c1"># Windows:</span>
daeplotter.bat
</pre></div>
</div>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/Screenshot-DAEPlotter.png"><img alt="_images/Screenshot-DAEPlotter.png" src="_images/Screenshot-DAEPlotter.png" style="width: 250pt;" /></a>
</div>
<p>It supports the following types of plots:</p>
<ul class="simple">
<li>2D plot (using matplotlib)</li>
<li>3D plot (Mayavi)</li>
<li>Animated 2D plot (using matplotlib)</li>
<li>Auto-update 2D plot (using matplotlib)</li>
<li>User-defined 2D plot (using the user-supplied source code)</li>
<li><em>Variable 1</em> vs. <em>Variable 2</em> 2D plot (using matplotlib)</li>
<li>2D plot of user-provided data (using matplotlib)</li>
<li>2D plot using the .vtk file</li>
</ul>
<p>After choosing a desired type, a <strong>Choose variable</strong>
dialog appears where a variable to be plotted can be selected and information about domains
specified - some domains should be fixed while leaving another free by selecting <cite>*</cite> from the list
(to create a 2D plot one domain must remain free, while for a 3D plot two domains):</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/Screenshot-ChooseVariable.png"><img alt="_images/Screenshot-ChooseVariable.png" src="_images/Screenshot-ChooseVariable.png" style="width: 350pt;" /></a>
</div>
<p>2D plots can be saved as templates (.pt files) which store the information in <cite>JSON</cite> format.</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="s2">&quot;curves&quot;</span><span class="o">:</span> <span class="p">[</span>
      <span class="p">[</span>
      <span class="s2">&quot;tutorial4.T&quot;</span><span class="p">,</span>
      <span class="p">[</span>
          <span class="o">-</span><span class="mi">1</span>
      <span class="p">],</span>
      <span class="p">[</span>
          <span class="s2">&quot;*&quot;</span>
      <span class="p">],</span>
      <span class="s2">&quot;tutorial4.T(*)&quot;</span><span class="p">,</span>
      <span class="p">{</span>
          <span class="s2">&quot;color&quot;</span><span class="o">:</span> <span class="s2">&quot;black&quot;</span><span class="p">,</span>
          <span class="s2">&quot;linestyle&quot;</span><span class="o">:</span> <span class="s2">&quot;-&quot;</span><span class="p">,</span>
          <span class="s2">&quot;linewidth&quot;</span><span class="o">:</span> <span class="mf">0.5</span><span class="p">,</span>
          <span class="s2">&quot;marker&quot;</span><span class="o">:</span> <span class="s2">&quot;o&quot;</span><span class="p">,</span>
          <span class="s2">&quot;markeredgecolor&quot;</span><span class="o">:</span> <span class="s2">&quot;black&quot;</span><span class="p">,</span>
          <span class="s2">&quot;markerfacecolor&quot;</span><span class="o">:</span> <span class="s2">&quot;black&quot;</span><span class="p">,</span>
          <span class="s2">&quot;markersize&quot;</span><span class="o">:</span> <span class="mi">6</span>
      <span class="p">}</span>
      <span class="p">]</span>
  <span class="p">],</span>
  <span class="s2">&quot;gridOn&quot;</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="s2">&quot;legendOn&quot;</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="s2">&quot;plotTitle&quot;</span><span class="o">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
  <span class="s2">&quot;updateInterval&quot;</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="s2">&quot;windowTitle&quot;</span><span class="o">:</span> <span class="s2">&quot;tutorial4.T(*)&quot;</span><span class="p">,</span>
  <span class="s2">&quot;xlabel&quot;</span><span class="o">:</span> <span class="s2">&quot;Time (s)&quot;</span><span class="p">,</span>
  <span class="s2">&quot;xmax&quot;</span><span class="o">:</span> <span class="mf">525.0</span><span class="p">,</span>
  <span class="s2">&quot;xmax_policy&quot;</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="s2">&quot;xmin&quot;</span><span class="o">:</span> <span class="o">-</span><span class="mf">25.0</span><span class="p">,</span>
  <span class="s2">&quot;xmin_policy&quot;</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="s2">&quot;xscale&quot;</span><span class="o">:</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
  <span class="s2">&quot;xtransform&quot;</span><span class="o">:</span> <span class="mf">1.0</span><span class="p">,</span>
  <span class="s2">&quot;ylabel&quot;</span><span class="o">:</span> <span class="s2">&quot;T (K)&quot;</span><span class="p">,</span>
  <span class="s2">&quot;ymax&quot;</span><span class="o">:</span> <span class="mf">361.74772465755922</span><span class="p">,</span>
  <span class="s2">&quot;ymax_policy&quot;</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="s2">&quot;ymin&quot;</span><span class="o">:</span> <span class="mf">279.2499308975365</span><span class="p">,</span>
  <span class="s2">&quot;ymin_policy&quot;</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="s2">&quot;yscale&quot;</span><span class="o">:</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
  <span class="s2">&quot;ytransform&quot;</span><span class="o">:</span> <span class="mf">1.0</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="executing-simulations">
<h2>6.10. Executing simulations<a class="headerlink" href="#executing-simulations" title="Permalink to this headline">¶</a></h2>
<div class="section" id="initialising-domains-and-parameters">
<h3>6.10.1. Initialising domains and parameters<a class="headerlink" href="#initialising-domains-and-parameters" title="Permalink to this headline">¶</a></h3>
<p>Domains and parameters are initialised in the <a class="reference internal" href="activity.html#pyActivity.daeSimulation.SetUpParametersAndDomains" title="pyActivity.daeSimulation.SetUpParametersAndDomains"><code class="xref py py-meth docutils literal"><span class="pre">SetUpParametersAndDomains()</span></code></a> function.
In the case of deep model hierarchies domains and parameters having identical names can be initialised using the propagation technique and
<a class="reference internal" href="core.html#pyCore.daeModel.PropagateDomain" title="pyCore.daeModel.PropagateDomain"><code class="xref py py-meth docutils literal"><span class="pre">PropagateDomain()</span></code></a> and <a class="reference internal" href="core.html#pyCore.daeModel.PropagateParameter" title="pyCore.daeModel.PropagateParameter"><code class="xref py py-meth docutils literal"><span class="pre">PropagateParameter()</span></code></a> functions. These functions traverse down all
models in the hierarchy (starting with the calling model) and copy the properties of the given domain/parameter to all domains/properties
with the same name.</p>
</div>
<div class="section" id="initialising-variables-initial-conditions-degrees-of-freedom">
<h3>6.10.2. Initialising variables (initial conditions, degrees of freedom)<a class="headerlink" href="#initialising-variables-initial-conditions-degrees-of-freedom" title="Permalink to this headline">¶</a></h3>
<p>All information related to variables are set in the <a class="reference internal" href="activity.html#pyActivity.daeSimulation.SetUpVariables" title="pyActivity.daeSimulation.SetUpVariables"><code class="xref py py-meth docutils literal"><span class="pre">SetUpVariables()</span></code></a> function.
Here, operations such as setting initial conditions, initial guesses, absolute tolerances and fixing degrees of freedom can be performed.</p>
<p>There are two initial condition modes supported by the Sundials IDAS solver (<a class="reference internal" href="core.html#pyCore.daeeInitialConditionMode" title="pyCore.daeeInitialConditionMode"><code class="xref py py-data docutils literal"><span class="pre">daeeInitialConditionMode</span></code></a>):</p>
<ul>
<li><p class="first"><a class="reference internal" href="core.html#pyCore.daeeInitialConditionMode.eAlgebraicValuesProvided" title="pyCore.daeeInitialConditionMode.eAlgebraicValuesProvided"><code class="xref py py-data docutils literal"><span class="pre">eAlgebraicValuesProvided</span></code></a> (the default)</p>
<p>Initial conditions are set using the <a class="reference internal" href="core.html#pyCore.daeVariable.SetInitialCondition" title="pyCore.daeVariable.SetInitialCondition"><code class="xref py py-meth docutils literal"><span class="pre">SetInitialCondition()</span></code></a> function.</p>
</li>
<li><p class="first"><a class="reference internal" href="core.html#pyCore.daeeInitialConditionMode.eQuasiSteadyState" title="pyCore.daeeInitialConditionMode.eQuasiSteadyState"><code class="xref py py-data docutils literal"><span class="pre">eQuasiSteadyState</span></code></a></p>
<p>DAE solver assumes all derivatives to initially be zero (thus the name <em>Quasi Steady State</em>).</p>
</li>
</ul>
<p>The initial condition mode can be set using the <a class="reference internal" href="activity.html#pyActivity.daeSimulation.InitialConditionMode" title="pyActivity.daeSimulation.InitialConditionMode"><code class="xref py py-attr docutils literal"><span class="pre">InitialConditionMode</span></code></a> property
(during the initialisation of the system in the <a class="reference internal" href="activity.html#pyActivity.daeSimulation.SetUpVariables" title="pyActivity.daeSimulation.SetUpVariables"><code class="xref py py-meth docutils literal"><span class="pre">SetUpVariables()</span></code></a> function).</p>
<p>The initial conditions for Finite Element models are set in a different way (due to a nature of the block matrices used).
Here, the function <code class="xref py py-meth docutils literal"><span class="pre">setFEInitialConditions()</span></code> is used. It accepts the following arguments:</p>
<ul class="simple">
<li><cite>FEmodel</cite> is an instance of <a class="reference internal" href="finite_element.html#pyCore.daeFiniteElementModel" title="pyCore.daeFiniteElementModel"><code class="xref py py-class docutils literal"><span class="pre">daeFiniteElementModel</span></code></a> class</li>
<li><cite>FEsystem</cite> is an instance of <a class="reference internal" href="finite_element.html#pyCore.daeFiniteElementObject_t" title="pyCore.daeFiniteElementObject_t"><code class="xref py py-class docutils literal"><span class="pre">daeFiniteElementObject_t</span></code></a> class
(i.e. <a class="reference internal" href="finite_element.html#pyDealII.dealiiFiniteElementSystem_2D" title="pyDealII.dealiiFiniteElementSystem_2D"><code class="xref py py-class docutils literal"><span class="pre">dealiiFiniteElementSystem_2D</span></code></a>)</li>
<li><cite>dofName</cite> is a string with the dof name</li>
<li><cite>ic</cite> can be a float value or a callable that returns a float value for the given arguments:
<cite>index_in_the_domain</cite> and <cite>overall_index</cite></li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">SetUpVariables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">setFEInitialConditions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">fe_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">fe_system</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="mf">300.0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="developing-schedules-operating-procedures">
<h3>6.10.3. Developing schedules (operating procedures)<a class="headerlink" href="#developing-schedules-operating-procedures" title="Permalink to this headline">¶</a></h3>
<p>The model specified in the simulation constructor is integrated in time in the <a class="reference internal" href="activity.html#pyActivity.daeSimulation.Run" title="pyActivity.daeSimulation.Run"><code class="xref py py-meth docutils literal"><span class="pre">Run()</span></code></a> function.
The default implementation iterates over the specified time horizon (<a class="reference internal" href="activity.html#pyActivity.daeSimulation.TimeHorizon" title="pyActivity.daeSimulation.TimeHorizon"><code class="xref py py-attr docutils literal"><span class="pre">TimeHorizon</span></code></a> property),
integrates for time intervals specified using the <a class="reference internal" href="activity.html#pyActivity.daeSimulation.ReportingInterval" title="pyActivity.daeSimulation.ReportingInterval"><code class="xref py py-attr docutils literal"><span class="pre">ReportingInterval</span></code></a> property and reports the data.
If a discontinuity occurs during the current integration interval, the precise discontinuity time is determined,
model integrated until the discontinuity time point, data reported, the DAE system reinitialised and integration resumed.</p>
<p>The user-defined schedule can be implemented by overloading the <a class="reference internal" href="activity.html#pyActivity.daeSimulation.Run" title="pyActivity.daeSimulation.Run"><code class="xref py py-meth docutils literal"><span class="pre">Run()</span></code></a> function. Here, a custom
schedule can be specified using the following functions from the <a class="reference internal" href="activity.html#pyActivity.daeSimulation" title="pyActivity.daeSimulation"><code class="xref py py-class docutils literal"><span class="pre">daeSimulation</span></code></a> class:</p>
<ul class="simple">
<li><a class="reference internal" href="activity.html#pyActivity.daeSimulation.Integrate" title="pyActivity.daeSimulation.Integrate"><code class="xref py py-meth docutils literal"><span class="pre">Integrate()</span></code></a> integrates the system until the given time horizon is reached and reports the data
after every reporting interval. If the <cite>stopCriterion</cite> argument is set to <cite>eStopAtModelDiscontinuity</cite> the simulation will be stopped
at every discontinuity occurrence and if the <cite>reportDataAroundDiscontinuities</cite> argument is set to <cite>True</cite> the data reported
at the discontinuity and after the system is reinitialised. The default value for <cite>reportDataAroundDiscontinuities</cite> is <cite>True</cite>.
The condition that triggered the discontinuity can be retrieved using the <a class="reference internal" href="activity.html#pyActivity.daeSimulation.LastSatisfiedCondition" title="pyActivity.daeSimulation.LastSatisfiedCondition"><code class="xref py py-attr docutils literal"><span class="pre">LastSatisfiedCondition</span></code></a>
property which returns the <a class="reference internal" href="core.html#pyCore.daeCondition" title="pyCore.daeCondition"><code class="xref py py-class docutils literal"><span class="pre">daeCondition</span></code></a> object.</li>
<li><a class="reference internal" href="activity.html#pyActivity.daeSimulation.IntegrateForTimeInterval" title="pyActivity.daeSimulation.IntegrateForTimeInterval"><code class="xref py py-meth docutils literal"><span class="pre">IntegrateForTimeInterval()</span></code></a> integrates the system for the given time interval (in seconds).
Its behaviour can be controlled using the <cite>stopCriterion</cite> and <cite>reportDataAroundDiscontinuities</cite> arguments in the same way as in the
<a class="reference internal" href="activity.html#pyActivity.daeSimulation.Integrate" title="pyActivity.daeSimulation.Integrate"><code class="xref py py-meth docutils literal"><span class="pre">Integrate()</span></code></a> function.</li>
<li><a class="reference internal" href="activity.html#pyActivity.daeSimulation.IntegrateUntilTime" title="pyActivity.daeSimulation.IntegrateUntilTime"><code class="xref py py-meth docutils literal"><span class="pre">IntegrateUntilTime()</span></code></a> integrates the system until the specified time is reached (in seconds).
Its behaviour can be controlled using the <cite>stopCriterion</cite> and <cite>reportDataAroundDiscontinuities</cite> arguments in the same way as in the
<a class="reference internal" href="activity.html#pyActivity.daeSimulation.Integrate" title="pyActivity.daeSimulation.Integrate"><code class="xref py py-meth docutils literal"><span class="pre">Integrate()</span></code></a> function.</li>
<li><a class="reference internal" href="activity.html#pyActivity.daeSimulation.IntegrateForOneStep" title="pyActivity.daeSimulation.IntegrateForOneStep"><code class="xref py py-meth docutils literal"><span class="pre">IntegrateForOneStep()</span></code></a> integrates the system for a single time step (DAE solver dependent)
Its behaviour can be controlled using the <cite>stopCriterion</cite> and <cite>reportDataAroundDiscontinuities</cite> arguments in the same way as in the
<a class="reference internal" href="activity.html#pyActivity.daeSimulation.Integrate" title="pyActivity.daeSimulation.Integrate"><code class="xref py py-meth docutils literal"><span class="pre">Integrate()</span></code></a> function.</li>
<li><a class="reference internal" href="activity.html#pyActivity.daeSimulation.ReportData" title="pyActivity.daeSimulation.ReportData"><code class="xref py py-meth docutils literal"><span class="pre">ReportData()</span></code></a> reports the data at the current time in simulation.</li>
<li>The functions <code class="xref py py-meth docutils literal"><span class="pre">ReSetInitialCondition()</span></code> and <code class="xref py py-meth docutils literal"><span class="pre">ReAssignValue()</span></code>
can be used to re-set the initial conditions and re-assign the values of degrees of freedom. These calls <strong>must</strong> be followed
by a call to the <code class="xref py py-meth docutils literal"><span class="pre">ReInitialize()</span></code> function to reinitialise the system after the variable values
have been modified.</li>
</ul>
<p>The functionality of the default <a class="reference internal" href="activity.html#pyActivity.daeSimulation.Run" title="pyActivity.daeSimulation.Run"><code class="xref py py-meth docutils literal"><span class="pre">Run()</span></code></a> function is roughly identical to the following python code:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">Run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># Python implementation of daeSimulation::Run() C++ function.</span>

    <span class="kn">import</span> <span class="nn">math</span>
    <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">CurrentTime</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">TimeHorizon</span><span class="p">:</span>
        <span class="c1"># Get the time step (based on the TimeHorizon and the ReportingInterval).</span>
        <span class="c1"># Do not allow to get past the TimeHorizon.</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">NextReportingTime</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">TimeHorizon</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TimeHorizon</span>

        <span class="c1"># If the flag is set - a user tries to pause the simulation, therefore return.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ActivityAction</span> <span class="o">==</span> <span class="n">ePauseActivity</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">Message</span><span class="p">(</span><span class="s2">&quot;Activity paused by the user&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># If a discontinuity is found, loop until the end of the integration period.</span>
        <span class="c1"># The data will be reported around discontinuities!</span>
        <span class="k">while</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">CurrentTime</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">Message</span><span class="p">(</span><span class="s2">&quot;Integrating from [</span><span class="si">%f</span><span class="s2">] to [</span><span class="si">%f</span><span class="s2">] ...&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CurrentTime</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">IntegrateUntilTime</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">eStopAtModelDiscontinuity</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>

        <span class="c1"># After the integration period, report the data.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ReportData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CurrentTime</span><span class="p">)</span>

        <span class="c1"># Set the simulation progress.</span>
        <span class="n">newProgress</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">100.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">CurrentTime</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">TimeHorizon</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">newProgress</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">Progress</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">Progress</span> <span class="o">=</span> <span class="n">newProgress</span>
</pre></div>
</div>
<p>A very simple schedule can be found in the <a class="reference internal" href="tutorials-all.html#tutorial7"><span class="std std-ref">Tutorial 7</span></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># The schedule:</span>
<span class="c1">#  1. Re-assign the value of Qin to 500W. After re-assigning DOFs or re-setting initial conditions</span>
<span class="c1">#     the function daeSimulation.Reinitialize() has to be called to reinitialise the DAE system.</span>
<span class="c1">#     Run the simulation for 100s using the function daeSimulation.IntegrateForTimeInterval()</span>
<span class="c1">#     and report the data using the function daeSimulation.ReportData().</span>
<span class="c1">#  2. Re-assign the value of Qin to 750W and re-initialise the system.</span>
<span class="c1">#     Use the function daeSimulation.IntegrateUntilTime() to run until the time reaches 200s</span>
<span class="c1">#     and report the data.</span>
<span class="c1">#  3. Re-assign the variable Qin to 1000W and re-initialise the system.</span>
<span class="c1">#     Use the function daeSimulation.IntegrateForOneStep() to integrate in OneStep mode for 100s</span>
<span class="c1">#     and report the data at every time step.</span>
<span class="c1">#  4. Re-assign the variable Qin to 1500W, re-set T to 300K and re-initialise the system.</span>
<span class="c1">#     Run the simulation until the TimeHorizon is reached using the function</span>
<span class="c1">#     daeSimulation.Integrate() and report the data.</span>
<span class="k">def</span> <span class="nf">Run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># 1. Set Qin=500W and integrate for 100s</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">Qin</span><span class="o">.</span><span class="n">ReAssignValue</span><span class="p">(</span><span class="mi">500</span> <span class="o">*</span> <span class="n">W</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Reinitialize</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ReportData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CurrentTime</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">Message</span><span class="p">(</span><span class="s2">&quot;OP: Integrating for 100 seconds ... &quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">IntegrateForTimeInterval</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">eDoNotStopAtDiscontinuity</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ReportData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CurrentTime</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">SetProgress</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mf">100.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">CurrentTime</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">TimeHorizon</span><span class="p">))</span>

    <span class="c1"># 2. Set Qin=750W and integrate until time = 200s</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">Qin</span><span class="o">.</span><span class="n">ReAssignValue</span><span class="p">(</span><span class="mi">750</span> <span class="o">*</span> <span class="n">W</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Reinitialize</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ReportData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CurrentTime</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">Message</span><span class="p">(</span><span class="s2">&quot;OP: Integrating until time = 200 seconds ... &quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">IntegrateUntilTime</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="n">eDoNotStopAtDiscontinuity</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ReportData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CurrentTime</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">SetProgress</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mf">100.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">CurrentTime</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">TimeHorizon</span><span class="p">))</span>

    <span class="c1"># 3. Set Qin=1000W and integrate in OneStep mode for 100 seconds.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">Qin</span><span class="o">.</span><span class="n">ReAssignValue</span><span class="p">(</span><span class="mi">1000</span> <span class="o">*</span> <span class="n">W</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Reinitialize</span><span class="p">()</span>
    <span class="n">t_end</span> <span class="o">=</span> <span class="n">time</span> <span class="o">+</span> <span class="mf">100.0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">Message</span><span class="p">(</span><span class="s2">&quot;OP: Integrating in one step mode:&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">time</span> <span class="o">&lt;</span> <span class="n">t_end</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;    Integrated from </span><span class="si">%.10f</span><span class="s2"> to &quot;</span> <span class="o">%</span> <span class="n">time</span>
        <span class="n">time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">IntegrateForOneStep</span><span class="p">(</span><span class="n">eDoNotStopAtDiscontinuity</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ReportData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CurrentTime</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%.10f</span><span class="s2"> ... &quot;</span> <span class="o">%</span> <span class="n">time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">Message</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># 4. Set Qin=1500W and integrate until the specified TimeHorizon is reached</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">Qin</span><span class="o">.</span><span class="n">ReAssignValue</span><span class="p">(</span><span class="mi">1500</span> <span class="o">*</span> <span class="n">W</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">ReSetInitialCondition</span><span class="p">(</span><span class="mi">300</span> <span class="o">*</span> <span class="n">K</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Reinitialize</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ReportData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CurrentTime</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">SetProgress</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mf">100.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">CurrentTime</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">TimeHorizon</span><span class="p">))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">Message</span><span class="p">(</span><span class="s2">&quot;OP: Integrating from &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">time</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; to the time horizon (&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">TimeHorizon</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;) ... &quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Integrate</span><span class="p">(</span><span class="n">eDoNotStopAtDiscontinuity</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ReportData</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CurrentTime</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">SetProgress</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mf">100.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">CurrentTime</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">TimeHorizon</span><span class="p">))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">Message</span><span class="p">(</span><span class="s2">&quot;OP: Finished&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>In addition, the <a class="reference internal" href="tutorials-all.html#tutorial-adv-1"><span class="std std-ref">Advanced Tutorial 1</span></a> illustrates interactive schedules where the <cite>pyQt</cite> graphical user interface (GUI)
is utilised to manipulate the model variables and integrate the system in time:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/tutorial_adv_1-screenshot.png"><img alt="_images/tutorial_adv_1-screenshot.png" src="_images/tutorial_adv_1-screenshot.png" style="width: 400pt;" /></a>
</div>
</div>
<div class="section" id="exploring-models-using-the-gui-simulation-explorer">
<h3>6.10.4. Exploring models using the GUI (Simulation Explorer)<a class="headerlink" href="#exploring-models-using-the-gui-simulation-explorer" title="Permalink to this headline">¶</a></h3>
<p>The model structure and the domains/parameters/variables data can be interactively explored and updated using the <cite>Simulation Explorer</cite> GUI.
The <cite>Simulation Explorer</cite> can be started using the following code:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="c1"># Create and initialize the simulation and the auxiliary objects and</span>
<span class="c1"># determine the consistent initial conditions using the SolveInitial function.</span>
<span class="o">...</span>
<span class="n">simulation</span><span class="o">.</span><span class="n">SolveInitial</span><span class="p">()</span>

<span class="c1"># Show the simulation explorer GUI</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">daeCreateQtApplication</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span>
<span class="n">se</span> <span class="o">=</span> <span class="n">daeSimulationExplorer</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">simulation</span><span class="p">)</span>
<span class="n">se</span><span class="o">.</span><span class="n">exec_</span><span class="p">()</span>
</pre></div>
</div>
<p>or from the <cite>DAE Toools Simulator</cite> <strong>Start/Show simulation explorer ad run...</strong> button:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/Simulator-StartSimulationExplorer.png"><img alt="_images/Simulator-StartSimulationExplorer.png" src="_images/Simulator-StartSimulationExplorer.png" style="width: 400pt;" /></a>
</div>
<p>Screenshots of the running <cite>Simulation Explorer</cite>:</p>
<div class="figure align-center" id="id17">
<a class="reference internal image-reference" href="_images/SimulationExplorer1.png"><img alt="_images/SimulationExplorer1.png" src="_images/SimulationExplorer1.png" style="width: 400pt;" /></a>
<p class="caption"><span class="caption-number">Fig. 6.3 </span><span class="caption-text">Runtime simulation options</span></p>
</div>
<div class="figure align-center" id="id18">
<a class="reference internal image-reference" href="_images/SimulationExplorer2.png"><img alt="_images/SimulationExplorer2.png" src="_images/SimulationExplorer2.png" style="width: 400pt;" /></a>
<p class="caption"><span class="caption-number">Fig. 6.4 </span><span class="caption-text">Parameters values</span></p>
</div>
<div class="figure align-center" id="id19">
<a class="reference internal image-reference" href="_images/SimulationExplorer3.png"><img alt="_images/SimulationExplorer3.png" src="_images/SimulationExplorer3.png" style="width: 400pt;" /></a>
<p class="caption"><span class="caption-number">Fig. 6.5 </span><span class="caption-text">Initial conditions</span></p>
</div>
<div class="figure align-center" id="id20">
<a class="reference internal image-reference" href="_images/SimulationExplorer4.png"><img alt="_images/SimulationExplorer4.png" src="_images/SimulationExplorer4.png" style="width: 400pt;" /></a>
<p class="caption"><span class="caption-number">Fig. 6.6 </span><span class="caption-text">Degrees of freedom</span></p>
</div>
</div>
</div>
<div class="section" id="parallel-computation">
<h2>6.11. Parallel computation<a class="headerlink" href="#parallel-computation" title="Permalink to this headline">¶</a></h2>
<p>Within the DAE Tools only the shared-memory parallel programming model is supported.
Simulation on message-passing systems is available through the OpenCS code generator (section <a class="reference internal" href="#code-generation"><span class="std std-ref">Generating code for other modelling languages</span></a>).
The following parts of the code support parallelisation.</p>
<div class="section" id="evaluation-of-equations">
<h3>6.11.1. Evaluation of equations<a class="headerlink" href="#evaluation-of-equations" title="Permalink to this headline">¶</a></h3>
<p>Equations residuals, Jacobian matrix and sensitivity residuals can be evaluated in parallel
using two methods:</p>
<ol class="arabic">
<li><p class="first">The Evaluation Tree approach (default)</p>
<p>Equations are transformed using the operator overloading technique into a tree-like
data structure called an Evaluation Tree.
For instance, it is already shown that the equation <span class="math">\(\frac{x[0]-x[1]} {x[2]-x[3]} + 1.2 \cdot sin(x[0]) = 0\)</span>
can be represented as:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/evaluation_tree.png"><img alt="_images/evaluation_tree.png" src="_images/evaluation_tree.png" style="width: 350pt;" /></a>
</div>
<p>Equations can be evaluated in parallel using OpenMP API.
This evaluation mode is specified in the section <cite>daetools.core.equations</cite> of daetools.cfg config file
by setting the <cite>evaluationMode</cite> option to <cite>&#8220;evaluationTree_OpenMP&#8221;</cite>.
If <cite>numThreads</cite> is 0 the default number of threads is used (the number of cores in the system).
Sequential evaluation is achieved by setting <cite>numThreads</cite> to 1.</p>
</li>
<li><p class="first">The Compute Stack approach</p>
<p>Equations are transformed using the operator overloading technique into a postfix notation
expression stacks.
Each operand/operation is described by the specially designed data structure, and every equation
is transformed into an array of these structures (a Compute Stack).
Compute Stacks are evaluated by a stack machine using a FIFO queue.
As an example, the equation above can also be represented as a Compute Stack:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/compute_stack.png"><img alt="_images/compute_stack.png" src="_images/compute_stack.png" style="width: 600pt;" /></a>
</div>
<p>Equations can be evaluated in parallel using:</p>
<ol class="loweralpha">
<li><p class="first">OpenMP API for general purpose processors and manycore devices (i.e. Xeon Phi)</p>
<p>This evaluation mode is specified in the section <cite>daetools.core.equations</cite> of daetools.cfg config file
by setting the <cite>evaluationMode</cite> option to <cite>&#8220;computeStack_OpenMP&#8221;</cite>.
If <cite>numThreads</cite> is 0 the default number of threads is used (the number of cores in the system).
Sequential evaluation is achieved by setting <cite>numThreads</cite> to 1.</p>
</li>
<li><p class="first">OpenCL framework for streaming processors (GPU, GPGA) and heterogeneous systems</p>
<p>This type is implemented in an external Python module <code class="xref py py-mod docutils literal"><span class="pre">pyEvaluator_OpenCL</span></code>.
It is up to one order of magnitude faster than the Evaluation Tree approach.
However, it does not support external functions nor thermo-physical packages.</p>
<p>It is required to install OpenCL drivers/runtime libraries.
Good starting points for different hardware vendors could be:</p>
<ul class="simple">
<li>InteL: <a class="reference external" href="https://software.intel.com/en-us/articles/opencl-drivers">https://software.intel.com/en-us/articles/opencl-drivers</a></li>
<li>AMD: <a class="reference external" href="https://support.amd.com/en-us/kb-articles/Pages/OpenCL2-Driver.aspx">https://support.amd.com/en-us/kb-articles/Pages/OpenCL2-Driver.aspx</a></li>
<li>NVidia: <a class="reference external" href="https://developer.nvidia.com/opencl">https://developer.nvidia.com/opencl</a></li>
</ul>
<p>The available OpenCL platforms and devices can be listed using
<code class="xref py py-meth docutils literal"><span class="pre">AvailableOpenCLPlatforms()</span></code> and
<code class="xref py py-meth docutils literal"><span class="pre">AvailableOpenCLDevices()</span></code> functions:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">daetools.pyDAE.evaluator_opencl</span> <span class="kn">import</span> <span class="n">pyEvaluator_OpenCL</span>

<span class="n">openclPlatforms</span> <span class="o">=</span> <span class="n">pyEvaluator_OpenCL</span><span class="o">.</span><span class="n">AvailableOpenCLPlatforms</span><span class="p">()</span>
<span class="n">openclDevices</span>   <span class="o">=</span> <span class="n">pyEvaluator_OpenCL</span><span class="o">.</span><span class="n">AvailableOpenCLDevices</span><span class="p">()</span>
</pre></div>
</div>
<p>A sample list of available OpenCL platforms and devices (from <a class="reference internal" href="tutorials-all.html#tutorial21"><span class="std std-ref">Tutorial 21</span></a>) are presented below:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>Available OpenCL platforms:
    Platform: NVIDIA CUDA
        PlatformID: 0
        Vendor:     NVIDIA Corporation
        Version:    OpenCL 1.2 CUDA 9.0.194

    Platform: Intel(R) OpenCL
        PlatformID: 1
        Vendor:     Intel(R) Corporation
        Version:    OpenCL 2.0

Available OpenCL devices:
    Device: GeForce GTX 950M
        PlatformID:      0
        DeviceID:        0
        DeviceVersion:   OpenCL 1.2 CUDA
        DriverVersion:   384.90
        OpenCLVersion:   OpenCL C 1.2
        MaxComputeUnits: 5

    Device: Intel(R) HD Graphics
        PlatformID:      1
        DeviceID:        0
        DeviceVersion:   OpenCL 2.0
        DriverVersion:   r5.0.63503
        OpenCLVersion:   OpenCL C 2.0
        MaxComputeUnits: 24

    Device: Intel(R) Core(TM) i7-6700HQ CPU @ 2.60GHz
        PlatformID:      1
        DeviceID:        1
        DeviceVersion:   OpenCL 2.0 (Build 475)
        DriverVersion:   1.2.0.475
        OpenCLVersion:   OpenCL C 2.0
        MaxComputeUnits: 8
</pre></div>
</div>
<p>External Compute Stack Evaluators are set using <code class="xref py py-meth docutils literal"><span class="pre">daeSimulation.SetComputeStackEvaluator()</span></code> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">daetools.pyDAE.evaluator_opencl</span> <span class="kn">import</span> <span class="n">pyEvaluator_OpenCL</span>

<span class="c1"># OpenCL evaluators can use a single or multiple OpenCL devices.</span>
<span class="c1">#   a) Single OpenCLdevice:</span>
<span class="n">evaluator</span> <span class="o">=</span> <span class="n">pyEvaluator_OpenCL</span><span class="o">.</span><span class="n">CreateComputeStackEvaluator</span><span class="p">(</span><span class="n">platformID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">deviceID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1">#   b) Multiple OpenCL devices (for heterogenous computing):</span>
<span class="c1">#      They require the platformID, deviceID and percentage of the total work</span>
<span class="c1">#      to be specified for each device.</span>
<span class="n">evaluator</span> <span class="o">=</span> <span class="n">pyEvaluator_OpenCL</span><span class="o">.</span><span class="n">CreateComputeStackEvaluator</span><span class="p">(</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">60</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">40</span><span class="p">)]</span> <span class="p">)</span>

<span class="n">simulation</span><span class="o">.</span><span class="n">SetComputeStackEvaluator</span><span class="p">(</span><span class="n">evaluator</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ol>
</li>
</ol>
</div>
<div class="section" id="assembly-of-finite-element-systems">
<h3>6.11.2. Assembly of Finite Element systems<a class="headerlink" href="#assembly-of-finite-element-systems" title="Permalink to this headline">¶</a></h3>
<p>Assembly of Finite Element matrices can be performed in parallel using OpenMP API.
The options are located in the daetools.cfg config file, section <cite>daetools.deal_II.assembly</cite>.
The parallel assembly can be switched on by setting the <cite>parallelAssembly</cite> option.
<cite>parallelAssembly</cite> can be <cite>Sequential</cite> or <cite>OpenMP</cite>.
If <cite>numThreads</cite> is 0 the default number of threads will be used (typically the number of cores in the system).
The <cite>queueSize</cite> specifies the size of the internal queue; when this size is reached the local data are
copied to the global matrices.</p>
</div>
<div class="section" id="solution-of-systems-of-linear-equations">
<h3>6.11.3. Solution of systems of linear equations<a class="headerlink" href="#solution-of-systems-of-linear-equations" title="Permalink to this headline">¶</a></h3>
<p>The following multi-threaded linear solvers are supported: SuperLU_MT, Pardiso and Intel Pardiso.</p>
</div>
<div class="section" id="global-sensitivity-analysis">
<h3>6.11.4. Global Sensitivity Analysis<a class="headerlink" href="#global-sensitivity-analysis" title="Permalink to this headline">¶</a></h3>
<p>Simulations can be performed using multiprocessing.Pool available in Python.</p>
</div>
</div>
<div class="section" id="dae-tools-web-services">
<h2>6.12. DAE Tools web services<a class="headerlink" href="#dae-tools-web-services" title="Permalink to this headline">¶</a></h2>
<p>Simulations can be loaded and executed using the Representational state transfer (REST) web service.
RESTful API is provided for almost complete <a class="reference internal" href="activity.html#pyActivity.daeSimulation" title="pyActivity.daeSimulation"><code class="xref py py-class docutils literal"><span class="pre">daeSimulation</span></code></a> functionality (<cite>daetools_ws</cite>)
and for all FMI v2 for co-simulation functions (<cite>daetools_fmi_ws</cite>).
The RESTful API is language-independent and can be used from any language (i.e. JavaScript, Python, C++ ...).</p>
<div class="figure align-center" id="id21">
<a class="reference internal image-reference" href="_images/daetools_web_service.png"><img alt="_images/daetools_web_service.png" src="_images/daetools_web_service.png" style="width: 500pt;" /></a>
<p class="caption"><span class="caption-number">Fig. 6.7 </span><span class="caption-text">REST web service</span></p>
</div>
<p>Web services can be started using the following commands:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="c1"># DAE Tools simulations web service.</span>
<span class="c1"># By default, starts the web service on the &quot;localhost&quot; (http://127.0.0.1:8001)</span>
python -m daetools.dae_simulator.daetools_ws
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Individual simulations as a web service.</span>
<span class="c1"># Add the simulation names to the &#39;availableSimulations&#39; dictionary and start the service.</span>
<span class="c1"># The loaderFunction is a Python callable object that returns an initialised simulation object</span>
<span class="c1"># and will be called when a client requests a simulation by name.</span>
<span class="n">availableSimulations</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">availableSimulations</span><span class="p">[</span><span class="s1">&#39;tutorial_che_1&#39;</span><span class="p">]</span>  <span class="o">=</span> <span class="n">loaderFunction</span>
<span class="n">daeSimulationWebService</span><span class="o">.</span><span class="n">runSimulationsAsWebService</span><span class="p">(</span><span class="n">availableSimulations</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="c1"># FMI v2 web service.</span>
<span class="c1"># By default, starts the web service on the &quot;localhost&quot; (http://127.0.0.1:8002)</span>
python -m daetools.dae_simulator.daetools_fmi_ws
</pre></div>
</div>
<p>JavaScript client classes are developed for both types of web services.
Classes are located in the <cite>daetools/dae_simulator</cite> folder. <cite>web_service.js</cite> contains the web
service client, <cite>daetools_ws.js</cite> contains <a class="reference internal" href="activity.html#pyActivity.daeSimulation" title="pyActivity.daeSimulation"><code class="xref py py-class docutils literal"><span class="pre">daeSimulation</span></code></a> interface and
<cite>daetools_fmi_ws.js</cite> contains FMI interface.</p>
<p>JavaScript client interface for <cite>daetools_ws</cite> simulations web service:</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">daeSimulation</span>
<span class="p">{</span>
    <span class="nx">LoadSimulation</span><span class="p">(</span><span class="nx">pythonFile</span><span class="p">,</span> <span class="nx">loadCallable</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
    <span class="nx">LoadTutorial</span><span class="p">(</span><span class="nx">tutorialName</span><span class="p">);</span>
    <span class="nx">LoadSimulationByName</span><span class="p">(</span><span class="nx">simulationName</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
    <span class="nx">AvailableSimulations</span><span class="p">();</span>
    <span class="nx">Finalize</span><span class="p">();</span>
    <span class="nx">get</span> <span class="nx">ModelInfo</span><span class="p">();</span>
    <span class="nx">get</span> <span class="nx">Name</span><span class="p">();</span>
    <span class="nx">get</span> <span class="nx">DataReporter</span><span class="p">();</span>
    <span class="nx">get</span> <span class="nx">DAESolver</span><span class="p">();</span>
    <span class="nx">get</span> <span class="nx">CurrentTime</span><span class="p">();</span>
    <span class="nx">get</span> <span class="nx">TimeHorizon</span><span class="p">();</span>
    <span class="nx">set</span> <span class="nx">TimeHorizon</span><span class="p">(</span><span class="nx">timeHorizon</span><span class="p">);</span>
    <span class="nx">get</span> <span class="nx">ReportingInterval</span><span class="p">();</span>
    <span class="nx">set</span> <span class="nx">ReportingInterval</span><span class="p">(</span><span class="nx">reportingInterval</span><span class="p">);</span>
    <span class="nx">Run</span><span class="p">();</span>
    <span class="nx">SolveInitial</span><span class="p">();</span>
    <span class="nx">Reinitialize</span><span class="p">();</span>
    <span class="nx">Reset</span><span class="p">();</span>
    <span class="nx">ReportData</span><span class="p">();</span>
    <span class="nx">Integrate</span><span class="p">(</span><span class="nx">stopAtDiscontinuity</span><span class="p">,</span> <span class="nx">reportDataAroundDiscontinuities</span><span class="p">);</span>
    <span class="nx">IntegrateForTimeInterval</span><span class="p">(</span><span class="nx">timeInterval</span><span class="p">,</span> <span class="nx">stopAtDiscontinuity</span><span class="p">,</span> <span class="nx">reportDataAroundDiscontinuities</span><span class="p">);</span>
    <span class="nx">IntegrateUntilTime</span><span class="p">(</span><span class="nx">time</span><span class="p">,</span> <span class="nx">stopAtDiscontinuity</span><span class="p">,</span> <span class="nx">reportDataAroundDiscontinuities</span><span class="p">);</span>
    <span class="nx">GetParameterValue</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
    <span class="nx">GetVariableValue</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
    <span class="nx">GetActiveState</span><span class="p">(</span><span class="nx">stnName</span><span class="p">);</span>
    <span class="nx">SetParameterValue</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
    <span class="nx">ReAssignValue</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
    <span class="nx">ReSetInitialCondition</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
    <span class="nx">SetActiveState</span><span class="p">(</span><span class="nx">stnName</span><span class="p">,</span> <span class="nx">activeState</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>JavaScript client interface for <cite>daetools_fmi_ws</cite> FMI web service:</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">daeFMI2Simulation</span>
<span class="p">{</span>
    <span class="nx">fmi2Instantiate</span><span class="p">(</span><span class="nx">instanceName</span><span class="p">,</span> <span class="nx">guid</span><span class="p">,</span> <span class="nx">resourceLocation</span><span class="p">);</span>
    <span class="nx">fmi2Terminate</span><span class="p">();</span>
    <span class="nx">fmi2FreeInstance</span><span class="p">();</span>
    <span class="nx">fmi2SetupExperiment</span><span class="p">(</span><span class="nx">toleranceDefined</span><span class="p">,</span> <span class="nx">tolerance</span><span class="p">,</span> <span class="nx">startTime</span><span class="p">,</span> <span class="nx">stopTimeDefined</span><span class="p">,</span> <span class="nx">stopTime</span><span class="p">);</span>
    <span class="nx">fmi2EnterInitializationMode</span><span class="p">();</span>
    <span class="nx">fmi2ExitInitializationMode</span><span class="p">();</span>
    <span class="nx">fmi2Reset</span><span class="p">();</span>
    <span class="nx">fmi2DoStep</span><span class="p">(</span><span class="nx">currentCommunicationPoint</span><span class="p">,</span> <span class="nx">communicationStepSize</span><span class="p">,</span> <span class="nx">noSetFMUStatePriorToCurrentPoint</span><span class="p">);</span>
    <span class="nx">fmi2CancelStep</span><span class="p">();</span>
    <span class="nx">fmi2GetReal</span><span class="p">(</span><span class="nx">valReferences</span><span class="p">);</span>
    <span class="nx">fmi2SetReal</span><span class="p">(</span><span class="nx">valReferences</span><span class="p">,</span> <span class="nx">values</span><span class="p">);</span>
    <span class="nx">fmi2GetString</span><span class="p">(</span><span class="nx">valReferences</span><span class="p">);</span>
    <span class="nx">fmi2SetString</span><span class="p">(</span><span class="nx">valReferences</span><span class="p">,</span> <span class="nx">values</span><span class="p">);</span>
    <span class="nx">fmi2GetBoolean</span><span class="p">(</span><span class="nx">valReferences</span><span class="p">);</span>
    <span class="nx">fmi2SetBoolean</span><span class="p">(</span><span class="nx">valReferences</span><span class="p">,</span> <span class="nx">values</span><span class="p">);</span>
    <span class="nx">fmi2GetInteger</span><span class="p">(</span><span class="nx">valReferences</span><span class="p">);</span>
    <span class="nx">fmi2SetInteger</span><span class="p">(</span><span class="nx">valReferences</span><span class="p">,</span> <span class="nx">values</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A sample simulation in JavaScript is given in the following listing:</p>
<div class="highlight-javascript"><div class="highlight"><pre><span></span><span class="c1">// Create the web service client.</span>
<span class="kd">var</span> <span class="nx">webService</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">daeWebService</span><span class="p">(</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="mi">8001</span><span class="p">,</span> <span class="s1">&#39;daetools_ws&#39;</span><span class="p">);</span>

<span class="c1">// Create the simulation object.</span>
<span class="kd">var</span> <span class="nx">simulation</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">daeSimulation</span><span class="p">(</span><span class="nx">webService</span><span class="p">);</span>

<span class="c1">// Load simulation by name (if it has been started as a web service):</span>
<span class="nx">simulation</span><span class="p">.</span><span class="nx">LoadSimulationByName</span><span class="p">(</span><span class="s1">&#39;simulationName&#39;</span><span class="p">,</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">args</span><span class="p">));</span>
<span class="c1">// or load one of tutorials:</span>
<span class="nx">simulation</span><span class="p">.</span><span class="nx">LoadTutorial</span><span class="p">(</span><span class="s1">&#39;tutorialName&#39;</span><span class="p">);</span>
<span class="c1">// or load simulation by specifying a path to Python file, loading function and its arguments:</span>
<span class="nx">simulation</span><span class="p">.</span><span class="nx">LoadSimulation</span><span class="p">(</span><span class="s1">&#39;pythonFile&#39;</span><span class="p">,</span> <span class="s1">&#39;loadCallable&#39;</span><span class="p">,</span> <span class="nx">args</span><span class="p">)</span>

<span class="kd">var</span> <span class="nx">reportingInterval</span> <span class="o">=</span> <span class="nx">simulation</span><span class="p">.</span><span class="nx">ReportingInterval</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">timeHorizon</span>       <span class="o">=</span> <span class="nx">simulation</span><span class="p">.</span><span class="nx">TimeHorizon</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">currentTime</span>       <span class="o">=</span> <span class="nx">simulation</span><span class="p">.</span><span class="nx">CurrentTime</span><span class="p">;</span>

<span class="c1">// Get the consistent initial conditions.</span>
<span class="nx">simulation</span><span class="p">.</span><span class="nx">SolveInitial</span><span class="p">();</span>

<span class="c1">// Integrate the system in a loop until the time horizon is reached.</span>
<span class="k">while</span><span class="p">(</span><span class="nx">currentTime</span> <span class="o">&lt;</span> <span class="nx">timeHorizon</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Get the next time (based on the TimeHorizon and the ReportingInterval).</span>
    <span class="c1">// Do not allow to get past the TimeHorizon.</span>
    <span class="kd">var</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">currentTime</span> <span class="o">+</span> <span class="nx">reportingInterval</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">t</span> <span class="o">&gt;</span> <span class="nx">timeHorizon</span><span class="p">)</span>
        <span class="nx">t</span> <span class="o">=</span> <span class="nx">timeHorizon</span><span class="p">;</span>

    <span class="c1">// If a discontinuity is found, loop until the end of the integration period.</span>
    <span class="c1">// The data will be reported around discontinuities!</span>
    <span class="k">while</span><span class="p">(</span><span class="nx">t</span> <span class="o">&gt;</span> <span class="nx">currentTime</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Integrating from &#39;</span> <span class="o">+</span> <span class="nx">currentTime</span><span class="p">.</span><span class="nx">toFixed</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; to &#39;</span> <span class="o">+</span> <span class="nx">t</span><span class="p">.</span><span class="nx">toFixed</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; ...&#39;</span><span class="p">);</span>
        <span class="nx">currentTime</span> <span class="o">=</span> <span class="nx">simulation</span><span class="p">.</span><span class="nx">IntegrateUntilTime</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// After the integration period, report the data.</span>
    <span class="nx">simulation</span><span class="p">.</span><span class="nx">ReportData</span><span class="p">()</span>

    <span class="c1">// Set the simulation progress.</span>
    <span class="kd">var</span> <span class="nx">newProgress</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">ceil</span><span class="p">(</span><span class="mf">100.0</span> <span class="o">*</span> <span class="nx">currentTime</span> <span class="o">/</span> <span class="nx">timeHorizon</span><span class="p">)</span>
    <span class="nx">setProgress</span><span class="p">(</span><span class="nx">newProgress</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Clean up.</span>
<span class="nx">simulation</span><span class="p">.</span><span class="nx">Finalize</span><span class="p">();</span>
</pre></div>
</div>
<p>Calls to the above functions translate to HTTP requests. For instance, a call to simulation.IntegrateUntilTime(100.0, true, true)
results in a HTTP request sent to the <cite>daetools_ws</cite> web service:
<cite>http://127.0.0.1:8001/daetools_ws?simulationID=ba2a694a-b591-11e7-9f58-680715e7b846&amp;function=IntegrateUntilTime&amp;time=100.0&amp;stopAtDiscontinuity=true&amp;reportDataAroundDiscontinuities=true</cite>.
The response is returned in JSON format.</p>
<p>Sample html pages with the Graphical User Interface (GUI) using JavaScript and Plotly.js library
are provided for both types of web services and presented in figure below. Web pages are located
in the <cite>daetools/dae_simulator</cite> folder:
<a class="reference external" href="http://www.daetools.com/ws/daetools_ws_test.html">daetools_ws_test.html</a> and
<a class="reference external" href="http://www.daetools.com/ws/daetools_fmi_ws_test.html">daetools_fmi_ws_test.html</a>.</p>
<div class="figure align-center" id="id22">
<a class="reference internal image-reference" href="_images/daetools_ws_html.png"><img alt="_images/daetools_ws_html.png" src="_images/daetools_ws_html.png" style="width: 500pt;" /></a>
<p class="caption"><span class="caption-number">Fig. 6.8 </span><span class="caption-text">HTML+JavaScript GUI for <cite>daetools_ws</cite> web service client</span></p>
</div>
<div class="figure align-center" id="id23">
<a class="reference internal image-reference" href="_images/daetools_ws_html_plots.png"><img alt="_images/daetools_ws_html_plots.png" src="_images/daetools_ws_html_plots.png" style="width: 500pt;" /></a>
<p class="caption"><span class="caption-number">Fig. 6.9 </span><span class="caption-text">Plots produced by HTML GUI for <cite>daetools_ws</cite> web service client using Plotly.js library</span></p>
</div>
<div class="figure align-center" id="id24">
<a class="reference internal image-reference" href="_images/daetools_fmi_ws_html.png"><img alt="_images/daetools_fmi_ws_html.png" src="_images/daetools_fmi_ws_html.png" style="width: 500pt;" /></a>
<p class="caption"><span class="caption-number">Fig. 6.10 </span><span class="caption-text">HTML+JavaScript GUI for <cite>daetools_fmi_ws</cite> web service client</span></p>
</div>
<div class="figure align-center" id="id25">
<a class="reference internal image-reference" href="_images/daetools_fmi_ws_html_plots.png"><img alt="_images/daetools_fmi_ws_html_plots.png" src="_images/daetools_fmi_ws_html_plots.png" style="width: 500pt;" /></a>
<p class="caption"><span class="caption-number">Fig. 6.11 </span><span class="caption-text">Plots produced by <cite>daetools_fmi_ws</cite> web service client using Plotly.js library</span></p>
</div>
</div>
<div class="section" id="generating-code-for-other-modelling-languages">
<span id="code-generation"></span><h2>6.13. Generating code for other modelling languages<a class="headerlink" href="#generating-code-for-other-modelling-languages" title="Permalink to this headline">¶</a></h2>
<p><strong>DAE Tools</strong> can generate code for several modelling or programming languages (Modelica, gPROMS, c99, OpenCS).
The code generation should be performed after the simulation is initialised (ideally after a call to
<a class="reference internal" href="activity.html#pyActivity.daeSimulation.SolveInitial" title="pyActivity.daeSimulation.SolveInitial"><code class="xref py py-meth docutils literal"><span class="pre">SolveInitial()</span></code></a> so that the consistent initial conditions are determined and available).</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Generate Modelica source code:</span>
<span class="kn">from</span> <span class="nn">daetools.code_generators.modelica</span> <span class="kn">import</span> <span class="n">daeCodeGenerator_Modelica</span>
<span class="n">cg</span> <span class="o">=</span> <span class="n">daeCodeGenerator_Modelica</span><span class="p">()</span>
<span class="n">cg</span><span class="o">.</span><span class="n">generateSimulation</span><span class="p">(</span><span class="n">simulation</span><span class="p">,</span> <span class="n">tmp_folder</span><span class="p">)</span>

<span class="c1"># Generate gPROMS source code:</span>
<span class="kn">from</span> <span class="nn">daetools.code_generators.gproms</span> <span class="kn">import</span> <span class="n">daeCodeGenerator_gPROMS</span>
<span class="n">cg</span> <span class="o">=</span> <span class="n">daeCodeGenerator_gPROMS</span><span class="p">()</span>
<span class="n">cg</span><span class="o">.</span><span class="n">generateSimulation</span><span class="p">(</span><span class="n">simulation</span><span class="p">,</span> <span class="n">tmp_folder</span><span class="p">)</span>

<span class="c1"># Generate OpenCS models to be simulated using MPI on 4 nodes:</span>
<span class="kn">from</span> <span class="nn">daetools.code_generators.opencs</span> <span class="kn">import</span> <span class="n">daeCodeGenerator_OpenCS</span>
<span class="n">cg</span> <span class="o">=</span> <span class="n">daeCodeGenerator_OpenCS</span><span class="p">()</span>
<span class="n">cg</span><span class="o">.</span><span class="n">generateSimulation</span><span class="p">(</span><span class="n">simulation</span><span class="p">,</span> <span class="n">tmp_folder</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="xref py py-meth docutils literal"><span class="pre">generateSimulation()</span></code> function requires an initialised simulation object
and the directory where the code will be generated.</p>
<p>The code can be also generated from the <cite>Generate code...</cite> option in the Simulation Explorer GUI:</p>
<div class="figure align-center" id="id26">
<a class="reference internal image-reference" href="_images/CodeGeneration.png"><img alt="_images/CodeGeneration.png" src="_images/CodeGeneration.png" style="width: 400pt;" /></a>
<p class="caption"><span class="caption-number">Fig. 6.12 </span><span class="caption-text">Code generation from the Simulation Explorer GUI</span></p>
</div>
<p>More details can be found in <a class="reference internal" href="tutorials-all.html#tutorial-adv-3"><span class="std std-ref">Advanced Tutorial 3</span></a> and <a class="reference internal" href="tutorials-all.html#tutorial-adv-4"><span class="std std-ref">Advanced Tutorial 4</span></a>.</p>
</div>
<div class="section" id="simulating-models-in-other-simulators-co-simulation">
<h2>6.14. Simulating models in other simulators (co-simulation)<a class="headerlink" href="#simulating-models-in-other-simulators-co-simulation" title="Permalink to this headline">¶</a></h2>
<p><strong>DAE Tools</strong> can also wrap the models developed in python for use in other software/simulators:
<cite>FMI</cite> (Functional Mock-up Interface for co-simulation), <cite>Matlab</cite>, <cite>Scilab</cite> and <cite>GNU Octave</cite> <em>MEX functions</em>,
and <cite>Simulink</cite> <em>S-functions</em>.</p>
<div class="section" id="functional-mock-up-interface-for-co-simulation-fmi">
<h3>6.14.1. Functional Mock-up Interface for co-simulation (FMI)<a class="headerlink" href="#functional-mock-up-interface-for-co-simulation-fmi" title="Permalink to this headline">¶</a></h3>
<p><strong>DAE Tools</strong> models can be used to generate .fmu files for <cite>FMI for co-simulation</cite>.</p>
<div class="topic">
<p class="topic-title first">Nota bene</p>
<p>The model inputs are defined by the inlet ports while the model outputs by the outlet ports.
In addition, assigned variables (degrees of freedom) from the top-level model are added to
the list of inputs and the rest of variables from the top-level model can be added as either
local FMI variables or as outputs.</p>
</div>
<p>Generating <cite>FMU</cite> files for use in FMI capable simulators is similar to the code-generation procedure.
The <code class="xref py py-meth docutils literal"><span class="pre">generateSimulation()</span></code> function generates a <cite>simulation name.fmu</cite> file
which is basically a zip file with the files required by the <cite>FMI standard</cite>.
Here, the <code class="xref py py-meth docutils literal"><span class="pre">generateSimulation()</span></code> function requires the following arguments:</p>
<ul class="simple">
<li><cite>simulation</cite>: initialised daeSimulation object</li>
<li><cite>directory</cite>: directory where the .fmu file will be generated</li>
<li><cite>py_simulation_file</cite>: a path to the python file with the simulation source code</li>
<li><cite>create_simulation_callable_object</cite>: the name of python callable object that returns an <em>initialized</em> <a class="reference internal" href="activity.html#pyActivity.daeSimulation" title="pyActivity.daeSimulation"><code class="xref py py-class docutils literal"><span class="pre">daeSimulation</span></code></a> object</li>
<li><cite>arguments</cite>: arguments for the above callable object; can be anything that python accepts</li>
<li><cite>additional_files</cite>: paths to the additional files to pack into a .fmu file (empty list by default)</li>
<li><cite>localsAsOutputs</cite>: if True all variables from the top-level model will be treated as model outputs, otherwise as locals</li>
<li><cite>add_xml_stylesheet</cite>: if True the xsl file <cite>daetools-fmi.xsl</cite> will be added to the modelDescription.xml file</li>
<li><cite>useWebService</cite>: if True the web service version (<cite>fmi_ws</cite>) shared library will be packed into the fmu file.
DAE Tools FMI web service can be started using: <cite>python -m daetools.dae_simulator.daetools_fmi_ws</cite>.
The fmu will attempt to start it automatically and connect during the initialisation phase.</li>
</ul>
<p>All tutorials provide <cite>run(**kwargs)</cite> function that can be used to run a simulation (using the console or Qt GUI)
and for co-simulation to return an initialised simulation object (if the <cite>initializeAndReturn</cite> argument is True).
This way the same setup can be used for different activities.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">daetools.code_generators.fmi</span> <span class="kn">import</span> <span class="n">daeCodeGenerator_FMI</span>
<span class="n">cg</span> <span class="o">=</span> <span class="n">daeCodeGenerator_FMI</span><span class="p">()</span>
<span class="n">cg</span><span class="o">.</span><span class="n">generateSimulation</span><span class="p">(</span><span class="n">simulation</span><span class="p">,</span>
                      <span class="n">directory</span>            <span class="o">=</span> <span class="n">tmp_folder</span><span class="p">,</span>
                      <span class="n">py_simulation_file</span>   <span class="o">=</span> <span class="vm">__file__</span><span class="p">,</span>
                      <span class="n">callable_object_name</span> <span class="o">=</span> <span class="s1">&#39;run&#39;</span><span class="p">,</span>
                      <span class="n">arguments</span>            <span class="o">=</span> <span class="s1">&#39;initializeAndReturn = True&#39;</span><span class="p">,</span>
                      <span class="n">additional_files</span>     <span class="o">=</span> <span class="p">[],</span>
                      <span class="n">localsAsOutputs</span>      <span class="o">=</span> <span class="bp">True</span><span class="p">,</span>
                      <span class="n">add_xml_stylesheet</span>   <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>In addition, the <cite>create_simulation_callable_object</cite> argument can be any other user-defined function
(as specified in the <a class="reference internal" href="tutorials-all.html#tutorial-adv-3"><span class="std std-ref">Advanced Tutorial 3</span></a> example):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># This function is used by daetools_mex, daetools_s and daetools_fmi_cs to load a simulation.</span>
<span class="c1"># It can have any number of arguments, but must return an initialized daeSimulation object.</span>
<span class="k">def</span> <span class="nf">create_simulation</span><span class="p">():</span>
    <span class="c1"># Create Log, Solver, DataReporter and Simulation object</span>
    <span class="n">log</span>          <span class="o">=</span> <span class="n">daePythonStdOutLog</span><span class="p">()</span>
    <span class="n">daesolver</span>    <span class="o">=</span> <span class="n">daeIDAS</span><span class="p">()</span>
    <span class="n">datareporter</span> <span class="o">=</span> <span class="n">daeNoOpDataReporter</span><span class="p">()</span>
    <span class="n">simulation</span>   <span class="o">=</span> <span class="n">simTutorial</span><span class="p">()</span>

    <span class="c1"># Enable reporting of all variables</span>
    <span class="n">simulation</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">SetReportingOn</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>

    <span class="c1"># Set the time horizon and the reporting interval</span>
    <span class="n">simulation</span><span class="o">.</span><span class="n">ReportingInterval</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">simulation</span><span class="o">.</span><span class="n">TimeHorizon</span>       <span class="o">=</span> <span class="mi">100</span>

    <span class="c1"># Initialize the simulation</span>
    <span class="n">simulation</span><span class="o">.</span><span class="n">Initialize</span><span class="p">(</span><span class="n">daesolver</span><span class="p">,</span> <span class="n">datareporter</span><span class="p">,</span> <span class="n">log</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">simulation</span>
</pre></div>
</div>
</div>
<div class="section" id="mex-functions">
<span id="id6"></span><h3>6.14.2. MEX functions<a class="headerlink" href="#mex-functions" title="Permalink to this headline">¶</a></h3>
<p>In order to simulate <strong>DAE Tools</strong> models from Matlab/Scilab/GNU Octave the wrapper code first needs to be compiled
from source. The wrapper code is located in the <cite>daetools/trunk/mex</cite> directory. The compilation procedure requires
a compiled <cite>cdaeSimulationLoader-py[Major][(Minor]</cite> library (which is a part of <strong>DAE Tools</strong> installation) located in the
<cite>daetools/solibs/Platform_Architecture</cite> directory (i.e. <cite>daetools/solibs/Windows_win32</cite>). That directory has to be
made available to the mex compiler and Matlab during runtime:</p>
<ol class="arabic simple">
<li>Set environmental variable <cite>LD_LIBRARY_PATH</cite> in Matlab (using the <cite>setenv</cite> and <cite>getenv</cite> commands)</li>
<li>Set <cite>RPATH</cite> in the mex file during the linking procedure</li>
</ol>
<p>For instance, setting the <cite>LD_LIBRARY_PATH</cite> environmental variable can be done with the following code:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>% Note the path separator <span class="o">(</span><span class="p">;</span> or :<span class="o">)</span>
% Windows
setenv<span class="o">(</span><span class="s1">&#39;LD_LIBRARY_PATH&#39;</span>, <span class="o">[</span>getenv<span class="o">(</span><span class="s1">&#39;LD_LIBRARY_PATH&#39;</span><span class="o">)</span> <span class="s1">&#39;;path to daetools/solibs directory&#39;</span><span class="o">])</span><span class="p">;</span>
% GNU/Linux
setenv<span class="o">(</span><span class="s1">&#39;LD_LIBRARY_PATH&#39;</span>, <span class="o">[</span>getenv<span class="o">(</span><span class="s1">&#39;LD_LIBRARY_PATH&#39;</span><span class="o">)</span> <span class="s1">&#39;:path to daetools/solibs directory&#39;</span><span class="o">])</span><span class="p">;</span>
</pre></div>
</div>
<p>Compilation from <cite>Matlab</cite> (for python 2.7):</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nb">cd</span> mex
mex -v -I../simulation_loader -lcdaeSimulationLoader-py27 daetools_mex.c
</pre></div>
</div>
<p>Compilation from <cite>GNU Octave</cite> (for python 2.7):</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nb">cd</span> mex
mkoctfile -v --mex -I../simulation_loader -lcdaeSimulationLoader-py27 daetools_mex.c
</pre></div>
</div>
<p>Compilation from <cite>Scilab</cite> (for python 2.7):</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nb">cd</span> mex
<span class="c1"># check the include flag: cflags = -I... and set the correct full path for simulation loader</span>
exec<span class="o">(</span><span class="s1">&#39;builder.sce&#39;</span><span class="o">)</span>
exec<span class="o">(</span><span class="s1">&#39;loader.sce&#39;</span><span class="o">)</span>
</pre></div>
</div>
<p>Now the compiled <cite>daetools_mex</cite> executable can be used to run <strong>DAE Tools</strong> simulations from <cite>Matlab</cite>:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nv">res</span> <span class="o">=</span> daetools_mex<span class="o">(</span><span class="s1">&#39;.../daetools/examples/tutorial_adv_3.py&#39;</span>, <span class="s1">&#39;create_simulation&#39;</span>, <span class="s1">&#39; &#39;</span>, <span class="m">100</span>.0, <span class="m">10</span>.0<span class="o">)</span>
</pre></div>
</div>
<p><cite>daetools_mex</cite> accepts the following arguments:</p>
<ol class="arabic simple">
<li>Path to the python file with daetools simulation (char array)</li>
<li>The name of python callable object that returns an <em>initialized</em> daeSimulation object (char array)</li>
<li>Arguments for the above callable object; can be anything that python accepts (char array)</li>
<li>Time horizon (double scalar)</li>
<li>Reporting interval (double scalar)</li>
</ol>
<p>The outputs from the <cite>daetools_mex</cite> MEX-function are:</p>
<ol class="arabic simple">
<li>Cell array (pairs: {&#8216;variable_name&#8217;, double matrix}).
The variables values are put into the caller&#8217;s workspace as well.</li>
</ol>
</div>
<div class="section" id="simulink-s-functions">
<h3>6.14.3. Simulink S-functions<a class="headerlink" href="#simulink-s-functions" title="Permalink to this headline">¶</a></h3>
<p>Again, in order to simulate <strong>DAE Tools</strong> models from Simulink the wrapper code first needs to be compiled from source.
The wrapper code is located in the <cite>daetools/trunk/mex</cite> directory. The compilation procedure requires
a compiled <cite>cdaeSimulationLoader-py[Major][(Minor]</cite> library (which is a part of <strong>DAE Tools</strong> installation) located in the
<cite>daetools/solibs/Platform_Architecture</cite> directory (i.e. <cite>daetools/solibs/Windows_win32</cite>). That directory has to be
made available to the mex compiler and Matlab during runtime as explained in the <a class="reference internal" href="#mex-functions"><span class="std std-ref">MEX functions</span></a> section.</p>
<p>Compilation from Simulink (for python 2.7):</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nb">cd</span> mex
mex -v -I../simulation_loader  -lcdaeSimulationLoader-py27 daetools_s.c
</pre></div>
</div>
<p>Running <cite>deatools_s</cite> S-functions:</p>
<ul>
<li><p class="first">Add a new S-Function (&#8216;system&#8217;) from the User-Defined Functions palette.</p>
</li>
<li><p class="first">Set its dialog box parameters:</p>
<ul>
<li><p class="first">S-Function name: daetools_s
(this is a compiled daetools_s.c file, resulting in, for instance, deatools_s.mexa64 binary)</p>
</li>
<li><p class="first">S-Function parameters: see the description below</p>
<p>example: &#8216;.../daetools/examples/tutorial_adv_3.py&#8217;, &#8216;create_simulation&#8217;, &#8216; &#8216;, 2, 2</p>
</li>
<li><p class="first">S-Function modules: leave blank</p>
</li>
</ul>
</li>
</ul>
<p>As a working example, the file <cite>test_s_function.mdl</cite> in <cite>daetools/trunk/mex</cite> directory can be used.</p>
<p><cite>deatools_s</cite> S-function parameters:</p>
<ol class="arabic simple">
<li>Path to the python file with daetools simulation (char array)</li>
<li>The name of python callable object that returns <em>initialized</em> daeSimulation object (char array)</li>
<li>Arguments for the above callable object; can be anything that python accepts (char array)</li>
<li>Number of input ports (integer, must match the number of inlet ports in daetools simulation)</li>
<li>Number of output ports (integer, must match the number of outlet ports in daetools simulation)</li>
</ol>
<p>More details can be found in <a class="reference internal" href="tutorials-all.html#tutorial-adv-3"><span class="std std-ref">Advanced Tutorial 3</span></a>.</p>
</div>
</div>
<div class="section" id="performing-sensitivity-analysis">
<h2>6.15. Performing sensitivity analysis<a class="headerlink" href="#performing-sensitivity-analysis" title="Permalink to this headline">¶</a></h2>
<p>Sensitivity analysis (SA) is the study of how the uncertainty in the output of a mathematical model or system
(numerical or otherwise) can be apportioned to different sources of uncertainty in its inputs <a class="footnote-reference" href="#saltelli2008" id="id7">[4]</a>.
Sensitivity analysis is conducted to <a class="footnote-reference" href="#saltelli2008" id="id8">[4]</a> <a class="footnote-reference" href="#panell1997" id="id9">[5]</a>:</p>
<ol class="arabic simple">
<li>Identify the most important parameters (those that contribute the most to output variability)</li>
<li>Identify insignificant parameters (can be eliminated from the model)</li>
<li>Determine if and which parameters interact with each other</li>
<li>Simplify the model (by fixing model inputs that have no effect on the output)</li>
<li>Test the robustness of a model in the presence of uncertainty</li>
<li>Detect errors in the model (by encountering unexpected relationships between inputs and outputs)</li>
<li>Reduce uncertainty through the identification of model inputs that cause significant uncertainty in the output</li>
<li>Determine the optimal regions within the parameters space (for use in optimisation studies)</li>
</ol>
<p>There is a large number of SA methods, but in general they can be grouped into the local and global methods.
The local methods involve calculation of the partial derivatives of the output with respect to an input factor.
The most important local (derivative-based) methods are:</p>
<ul class="simple">
<li>Forward sensitivity method</li>
<li>Adjoint sensitivity method</li>
</ul>
<p>The global methods can be grouped into:</p>
<ul class="simple">
<li>The screening methods (coarse sorting of the most influential inputs among a large number,
such as Morris Elementary Effects method)</li>
<li>The measures of importance (quantitative sensitivity indices)</li>
<li>The variance-based methods for deep exploration of the model behaviour (measuring the effects of inputs
on their all variation range, such as FAST, Sobol)</li>
</ul>
<p>Other methods include <em>One-at-a-time</em> (changing one-factor-at-a-time to determine the effect on the output),
<em>Regression analysis</em> and <em>Scatter plots</em> (scatter plots of the output variable against individual input variables,
after sampling the model over its input distributions).</p>
<p><strong>DAE Tools</strong> support both local and global sensitivity analysis methods. The local derivative-based method
utilises Sundials IDAS sensitivity analysis capabilities to determine the sensitivity of the results
with respect to the model parameters. At the moment, only the forward sensitivity method is available.
The global SA can be performed using the external libraries (i.e. <a class="reference external" href="http://salib.readthedocs.io">SALib</a>).</p>
<div class="section" id="local-derivative-based-sa-methods">
<h3>6.15.1. Local (derivative-based) SA methods<a class="headerlink" href="#local-derivative-based-sa-methods" title="Permalink to this headline">¶</a></h3>
<p>To enable integration of sensitivity equations the function
<a class="reference internal" href="activity.html#pyActivity.daeSimulation.Initialize" title="pyActivity.daeSimulation.Initialize"><code class="xref py py-meth docutils literal"><span class="pre">Initialize()</span></code></a> must be called with the <cite>calculateSensitivities</cite>
argument set to true:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">simulation</span><span class="o">.</span><span class="n">Initialize</span><span class="p">(</span><span class="n">daesolver</span><span class="p">,</span> <span class="n">datareporter</span><span class="p">,</span> <span class="n">log</span><span class="p">,</span> <span class="n">calculateSensitivities</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>and the model parameters specified in the <a class="reference internal" href="activity.html#pyActivity.daeSimulation.SetUpSensitivityAnalysis" title="pyActivity.daeSimulation.SetUpSensitivityAnalysis"><code class="xref py py-meth docutils literal"><span class="pre">SetUpSensitivityAnalysis()</span></code></a>
function using the <a class="reference internal" href="activity.html#pyActivity.daeSimulation.SetSensitivityParameter" title="pyActivity.daeSimulation.SetSensitivityParameter"><code class="xref py py-meth docutils literal"><span class="pre">SetSensitivityParameter()</span></code></a> method:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">SetUpSensitivityAnalysis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">SetSensitivityParameter</span><span class="p">(</span><span class="n">variable_1</span><span class="p">)</span>
    <span class="o">...</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">SetSensitivityParameter</span><span class="p">(</span><span class="n">variable_n</span><span class="p">)</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title first">Nota bene</p>
<p>The sensitivity parameters must be variables with the assigned value (degrees of freedom)!</p>
</div>
<p>Sensitivities can be reported to a data reporter like any ordinary variable by setting the boolean property
<a class="reference internal" href="activity.html#pyActivity.daeSimulation.ReportSensitivities" title="pyActivity.daeSimulation.ReportSensitivities"><code class="xref py py-attr docutils literal"><span class="pre">ReportSensitivities</span></code></a> to True. In this case, the sensitivities for the
variable <cite>var</cite> per parameter <cite>param</cite> are reported as <cite>sensitivities.d(var)_d(param)</cite>.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/SensitivitiesInDataReporter.png"><img alt="_images/SensitivitiesInDataReporter.png" src="_images/SensitivitiesInDataReporter.png" style="width: 400pt;" /></a>
</div>
<p>In addition, they can be obtained directly from the DAE solver after every call to
<a class="reference internal" href="activity.html#pyActivity.daeSimulation.Integrate" title="pyActivity.daeSimulation.Integrate"><code class="xref py py-meth docutils literal"><span class="pre">Integrate()</span></code></a> functions using the <code class="xref py py-attr docutils literal"><span class="pre">SensitivityMatrix</span></code> property.
This property returns a dense matrix as a <code class="xref py py-class docutils literal"><span class="pre">daeDenseMatrix</span></code> object.
The numpy array object can be obtained from the <code class="xref py py-class docutils literal"><span class="pre">daeDenseMatrix</span></code> using the
<code class="xref py py-attr docutils literal"><span class="pre">npyValues</span></code> property.</p>
<p>More details on local sensitivity analysis methods can be found in <a class="reference internal" href="tutorials-all.html#tutorial-sa-1"><span class="std std-ref">Sensitivity Analysis Example 1</span></a>, <a class="reference internal" href="tutorials-all.html#tutorial-sa-2"><span class="std std-ref">Sensitivity Analysis Example 2</span></a> and
<a class="reference internal" href="tutorials-all.html#tutorial-che-9"><span class="std std-ref">Chem. Eng. Example 9</span></a>.</p>
</div>
<div class="section" id="global-sa-methods">
<h3>6.15.2. Global SA methods<a class="headerlink" href="#global-sa-methods" title="Permalink to this headline">¶</a></h3>
<p>Typically, the global sensitivity analysis is conducted by <a class="footnote-reference" href="#saltelli2008" id="id10">[4]</a> <a class="footnote-reference" href="#saltelli2005" id="id11">[6]</a>:</p>
<ol class="arabic simple">
<li>Defining the model and its input parameters and output variables</li>
<li>Assigning probability density functions to each input parameter</li>
<li>Generating an input matrix through an appropriate random sampling method, evaluating the output</li>
<li>Assessing the influences or relative importance of each input parameter on the output variable</li>
</ol>
<p>An example of the global sensitivity analysis in <strong>DAE Tools</strong> is given in <a class="reference internal" href="tutorials-all.html#tutorial-sa-3"><span class="std std-ref">Sensitivity Analysis Example 3</span></a>.
This tutorial illustrates the global variance-based sensitivity analysis methods available in
<a class="reference external" href="http://salib.readthedocs.io">SALib</a> python library. Three SA methods were applied on a thermal analysis
of a batch reactor with exothermic reaction <span class="math">\(A \rightarrow B\)</span> <a class="footnote-reference" href="#saltelli2005" id="id13">[6]</a>: <cite>Morris</cite> (Elementary Effect method),
<cite>FAST</cite> and <cite>Sobol</cite> (Variance-based methods).</p>
<p>In <strong>DAE Tools</strong> the procedure includes the following steps:</p>
<ol class="arabic">
<li><p class="first">Selection of the global sensitivity method</p>
</li>
<li><p class="first">Definition of the model inputs:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">SA_problem</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s1">&#39;num_vars&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
  <span class="s1">&#39;names&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;gamma&#39;</span><span class="p">,</span> <span class="s1">&#39;psi&#39;</span><span class="p">,</span> <span class="s1">&#39;theta_a&#39;</span><span class="p">,</span> <span class="s1">&#39;theta_0&#39;</span><span class="p">],</span>
  <span class="s1">&#39;bounds&#39;</span><span class="p">:</span> <span class="p">[[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span>    <span class="c1"># B</span>
             <span class="p">[</span><span class="mi">15</span><span class="p">,</span> <span class="mi">25</span><span class="p">],</span>    <span class="c1"># gamma</span>
             <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">],</span>  <span class="c1"># psi</span>
             <span class="p">[</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="c1"># theta_a</span>
             <span class="p">[</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">]</span>  <span class="c1"># theta_0</span>
            <span class="p">]</span>
          <span class="p">}</span>
</pre></div>
</div>
</li>
<li><p class="first">Generation of samples:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">SALib.sample.saltelli</span> <span class="kn">import</span> <span class="n">sample</span>

<span class="c1"># Generate samples using a Saltelli&#39;s extension of the Sobol sequence.</span>
<span class="c1"># Sample size n=512, no. params k=5 =&gt; N=(2k+2)*n=6144 (as in the referenced article).</span>
<span class="n">param_values</span> <span class="o">=</span> <span class="n">sample</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="n">calc_second_order</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">Generation of outputs for a given input matrix (by repeated simulations of a <strong>DAE Tools</strong> model):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># theta_max is the analysed output from simulations</span>
<span class="c1"># The function simulate() performs daetools simulation for a given set of input parameters</span>
<span class="n">theta_max</span>  <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="n">theta_max</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">simulate</span><span class="p">(</span><span class="n">run_no</span>  <span class="o">=</span> <span class="n">i</span><span class="p">,</span>
                            <span class="n">n</span>       <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                            <span class="n">B</span>       <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                            <span class="n">gamma</span>   <span class="o">=</span> <span class="n">gamma</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                            <span class="n">psi</span>     <span class="o">=</span> <span class="n">psi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                            <span class="n">theta_a</span> <span class="o">=</span> <span class="n">theta_a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                            <span class="n">x_0</span>     <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
                            <span class="n">theta_0</span> <span class="o">=</span> <span class="n">theta_0</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>Calculations can also be performed in parallel:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span>
<span class="c1"># Create a pool of workers to calculate N outputs</span>
<span class="c1"># Don&#39;t forget to disable OpenMP for evaluation of residuals and derivatives!!</span>
<span class="n">pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">()</span>
<span class="n">args</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">gamma</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">psi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">theta_a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">theta_0</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
<span class="n">theta_max</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">simulate_p</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Whether the simulations will be performed in parallel depends on model complexity and size.
Running several large simulations that require a lot of memory at the same time may actually slow down the overall progress.
Those cases will benefit more from parallel evaluation of equations / use of multithreaded linear equations solvers.</p>
</li>
<li><p class="first">Performing sensitivity analysis</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">SALib.analyze.sobol</span> <span class="kn">import</span> <span class="n">analyze</span>

<span class="n">res</span> <span class="o">=</span> <span class="n">analyze</span><span class="p">(</span><span class="n">problem</span><span class="p">,</span> <span class="n">theta_max</span><span class="p">,</span> <span class="n">print_to_console</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<span class="c1"># 1st-order variance-based sensitivities and the confidence intervals</span>
<span class="c1"># (individual parameters contributions)</span>
<span class="n">S1</span>      <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="s1">&#39;S1&#39;</span><span class="p">]</span>
<span class="n">S1_conf</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="s1">&#39;S1_conf&#39;</span><span class="p">]</span>

<span class="c1"># 2nd-order variance-based sensitivities and the confidence intervals</span>
<span class="c1"># (interactions between parameters)</span>
<span class="n">S2</span>      <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="s1">&#39;S2&#39;</span><span class="p">]</span>
<span class="n">S2_conf</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="s1">&#39;S2_conf&#39;</span><span class="p">]</span>

<span class="c1"># Total sensitivity indices and the confidence intervals</span>
<span class="n">ST</span>      <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="s1">&#39;ST&#39;</span><span class="p">]</span>
<span class="n">ST_conf</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="s1">&#39;ST_conf&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>1st order and total sensitivity indices (for the Sobol method):</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>-------------------------------------------------------
    Param          S1    S1_conf         ST    ST_conf
-------------------------------------------------------
        B    0.094110   0.089475   0.581946   0.150334
    gamma   -0.002416   0.011938   0.044354   0.028461
      psi    0.171040   0.097859   0.524576   0.140252
  theta_a    0.072511   0.043878   0.523382   0.177241
  theta_0    0.002343   0.004746   0.008174   0.007650
</pre></div>
</div>
<p>2nd order sensitivities (for the Sobol method):</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>-------------------------------------------------------
Parameter pairs          S2    S2_conf
-------------------------------------------------------
        B/gamma    0.180434   0.153318
          B/psi    0.260698   0.172012
      B/theta_a    0.143292   0.145452
      B/theta_0    0.177137   0.150218
      gamma/psi    0.000981   0.024855
  gamma/theta_a    0.004953   0.040380
  gamma/theta_0   -0.009390   0.027726
    psi/theta_a    0.166102   0.173568
    psi/theta_0   -0.016474   0.132210
theta_a/theta_0    0.109086   0.112104
</pre></div>
</div>
</li>
<li><p class="first">Generation of scatter plots (using <code class="xref py py-meth docutils literal"><span class="pre">matplotlib.pyplot.scatter()</span></code> function):</p>
<div class="figure align-center" style="width: 620pt">
<a class="reference internal image-reference" href="_images/tutorial_sa_3-scatter_sobol.png"><img alt="_images/tutorial_sa_3-scatter_sobol.png" src="_images/tutorial_sa_3-scatter_sobol.png" style="width: 600pt;" /></a>
</div>
</li>
</ol>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="saltelli2008" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[4]</td><td><em>(<a class="fn-backref" href="#id7">1</a>, <a class="fn-backref" href="#id8">2</a>, <a class="fn-backref" href="#id10">3</a>)</em> A. Saltelli et al. Global sensitivity analysis. The Primer.
Wiley-Interscience (2008).
<a class="reference external" href="http://isbnsearch.org/isbn/0470059974">ISBN-10: 0470059974</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="panell1997" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[5]</a></td><td>D.J. Pannell. Sensitivity Analysis of Normative Economic Models: Theoretical Framework and Practical Strategies.
Agricultural Economics 1997; 16:139–152.
<a class="reference external" href="https://doi.org/10.1016/S0169-5150(96)01217-0">doi:10.1016/S0169-5150(96)01217-0</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="saltelli2005" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[6]</td><td><em>(<a class="fn-backref" href="#id11">1</a>, <a class="fn-backref" href="#id13">2</a>)</em> A. Saltelli, M. Ratto, S. Tarantola, F. Campolongo.
Sensitivity Analysis for Chemical Models. Chem. Rev. (2005), 105(7):2811-2828.
<a class="reference external" href="http://dx.doi.org/10.1021/cr040659d">doi:10.1021/cr040659d</a></td></tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="executing-optimisations">
<h2>6.16. Executing optimisations<a class="headerlink" href="#executing-optimisations" title="Permalink to this headline">¶</a></h2>
<p>The goal of mathematical optimisation is to select a best element (with regard to some criterion) from some
set of available alternatives <a class="footnote-reference" href="#optimisation" id="id14">[7]</a>.</p>
<p>The following types of optimisation problems are supported in <strong>DAE Tools</strong>:</p>
<ul class="simple">
<li>Nonlinear optimisation problems</li>
<li>Mixed-integer nonlinear programming</li>
<li>Constrained and unconstrained problems</li>
<li>Continuous and discrete problems</li>
</ul>
<div class="section" id="optimisation-setup">
<h3>6.16.1. Optimisation setup<a class="headerlink" href="#optimisation-setup" title="Permalink to this headline">¶</a></h3>
<p>In general, the optimisation activities use the same model specification and the same simulation setup
as in the simulation runs.
However, some additional information are required:</p>
<ol class="arabic simple">
<li>The objective function</li>
<li>Optimisation variables</li>
<li>Optimisation constraints</li>
</ol>
<p>These information are specified in the <a class="reference internal" href="activity.html#pyActivity.daeSimulation.SetUpOptimization" title="pyActivity.daeSimulation.SetUpOptimization"><code class="xref py py-meth docutils literal"><span class="pre">SetUpOptimization()</span></code></a> function.</p>
<div class="section" id="specifying-the-objective-function">
<h4>6.16.1.1. Specifying the objective function<a class="headerlink" href="#specifying-the-objective-function" title="Permalink to this headline">¶</a></h4>
<p>By default, a single objective function object is declared and the objective function can be accessed
using the <a class="reference internal" href="activity.html#pyActivity.daeSimulation.ObjectiveFunction" title="pyActivity.daeSimulation.ObjectiveFunction"><code class="xref py py-attr docutils literal"><span class="pre">ObjectiveFunction</span></code></a> property.
Its residual can be set as in ordinary equations.
It is assumed that the optimisation solver tries to perform a minimisation.
If a maximisation is required the objective function should be specified as <span class="math">\(-F_{obj}\)</span>.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">SetUpOptimization</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># x1, x2 and x3 are optimisation variables (assigned variables, that is degrees of freedom).</span>

    <span class="c1"># The ObjectiveFunction object is automatically created by the framework</span>
    <span class="c1"># and only its residual needs to be specified.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ObjectiveFunction</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">x1</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">x2</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">x3</span><span class="p">()</span>
</pre></div>
</div>
<p>Scaling of the objective function can be left to be done by optimisation solvers or set manually.
The default scaling is 1.0 and can be changed using the <a class="reference internal" href="core.html#pyCore.daeObjectiveFunction.Scaling" title="pyCore.daeObjectiveFunction.Scaling"><code class="xref py py-attr docutils literal"><span class="pre">Scaling</span></code></a> property.
In addition, the objective function absolute tolerance can be specified using the
<a class="reference internal" href="core.html#pyCore.daeObjectiveFunction.AbsTolerance" title="pyCore.daeObjectiveFunction.AbsTolerance"><code class="xref py py-attr docutils literal"><span class="pre">AbsTolerance</span></code></a> property.</p>
</div>
<div class="section" id="specifying-optimisation-variables">
<h4>6.16.1.2. Specifying optimisation variables<a class="headerlink" href="#specifying-optimisation-variables" title="Permalink to this headline">¶</a></h4>
<p>There are three types of optimisation variables in <strong>DAE Tools</strong>:</p>
<ol class="arabic simple">
<li>Continuous (specified using the function <a class="reference internal" href="activity.html#pyActivity.daeSimulation.SetContinuousOptimizationVariable" title="pyActivity.daeSimulation.SetContinuousOptimizationVariable"><code class="xref py py-meth docutils literal"><span class="pre">SetContinuousOptimizationVariable()</span></code></a>)</li>
<li>Integer (specified using the function <a class="reference internal" href="activity.html#pyActivity.daeSimulation.SetIntegerOptimizationVariable" title="pyActivity.daeSimulation.SetIntegerOptimizationVariable"><code class="xref py py-meth docutils literal"><span class="pre">SetIntegerOptimizationVariable()</span></code></a>)</li>
<li>Binary (value 0 or 1) (specified using the function <a class="reference internal" href="activity.html#pyActivity.daeSimulation.SetBinaryOptimizationVariable" title="pyActivity.daeSimulation.SetBinaryOptimizationVariable"><code class="xref py py-meth docutils literal"><span class="pre">SetBinaryOptimizationVariable()</span></code></a>)</li>
</ol>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">SetUpOptimization</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># x1, x2 and x3 are optimisation variables (assigned variables, that is degrees of freedom).</span>

    <span class="c1"># Continuous optimisation variable: (lower bound, upper bound and the starting point as floats)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ov1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SetContinuousOptimizationVariable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">x1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">);</span>

    <span class="c1"># Integer optimisation variable: (lower bound, upper bound and the starting point as integers)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ov2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SetIntegerOptimizationVariable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">x2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Binary optimisation variable: (the starting point)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ov3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SetBinaryOptimizationVariable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">x3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="specifying-optimisation-constraints">
<h4>6.16.1.3. Specifying optimisation constraints<a class="headerlink" href="#specifying-optimisation-constraints" title="Permalink to this headline">¶</a></h4>
<p>There are three types of optimisation constraints in <strong>DAE Tools</strong>:</p>
<ol class="arabic simple">
<li>Inequality (specified using the function <a class="reference internal" href="activity.html#pyActivity.daeSimulation.CreateInequalityConstraint" title="pyActivity.daeSimulation.CreateInequalityConstraint"><code class="xref py py-meth docutils literal"><span class="pre">CreateInequalityConstraint()</span></code></a>)</li>
<li>Equality (specified using the function <a class="reference internal" href="activity.html#pyActivity.daeSimulation.CreateEqualityConstraint" title="pyActivity.daeSimulation.CreateEqualityConstraint"><code class="xref py py-meth docutils literal"><span class="pre">CreateEqualityConstraint()</span></code></a>)</li>
</ol>
<p>Constraints in <strong>DAE Tools</strong> are similar to ordinary equations.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">SetUpOptimization</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># x1, x2 and x3 are optimisation variables (assigned variables, that is degrees of freedom).</span>

    <span class="c1"># Inequality constraint: g(i) &lt;= 0)</span>
    <span class="c1"># The constraint: x1 &gt;= 25 in daetools becomes: 25 - x1 &lt;= 0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">c1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CreateInequalityConstraint</span><span class="p">(</span><span class="s2">&quot;Constraint 1&quot;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">c1</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="mi">25</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">x1</span><span class="p">()</span>

    <span class="c1"># Equality constraint: h(i) = 0</span>
    <span class="c1"># The constraint: x2 + x3 = 10 in daetools becomes: x2 + x3 - 10 = 0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CreateEqualityConstraint</span><span class="p">(</span><span class="s2">&quot;Constraint 2&quot;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">c2</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">x1</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">x2</span><span class="p">()</span> <span class="o">-</span> <span class="mi">10</span>
</pre></div>
</div>
<p>Scaling of constraints can be left to be done by optimisation solvers or set manually.
The default scaling is 1.0 and can be changed using the <a class="reference internal" href="core.html#pyCore.daeOptimizationConstraint.Scaling" title="pyCore.daeOptimizationConstraint.Scaling"><code class="xref py py-attr docutils literal"><span class="pre">Scaling</span></code></a> property.
In addition, the absolute tolerance for constraints can be specified using the
<a class="reference internal" href="core.html#pyCore.daeOptimizationConstraint.AbsTolerance" title="pyCore.daeOptimizationConstraint.AbsTolerance"><code class="xref py py-attr docutils literal"><span class="pre">AbsTolerance</span></code></a> property.</p>
</div>
</div>
<div class="section" id="optimisation-solvers">
<h3>6.16.2. Optimisation Solvers<a class="headerlink" href="#optimisation-solvers" title="Permalink to this headline">¶</a></h3>
<p>The following optimisation solvers are interfaced <a class="reference external" href="https://projects.coin-or.org/Bonmin">BONMIN</a>,
<a class="reference external" href="https://projects.coin-or.org/IPOPT">IPOPT</a>,
and <a class="reference external" href="http://ab-initio.mit.edu/wiki/index.php/NLopt">NLOPT</a> :</p>
<ul class="simple">
<li>IPOPT NLP solver:
<code class="xref py py-class docutils literal"><span class="pre">pyIPOPT</span></code> class from <code class="xref py py-mod docutils literal"><span class="pre">daetools.solvers.ipopt</span></code> module.</li>
<li>BONMIN MINLP solver:
<code class="xref py py-class docutils literal"><span class="pre">pyBONMIN</span></code> class from <code class="xref py py-mod docutils literal"><span class="pre">daetools.solvers.bonmin</span></code> module.</li>
<li>NLOPT set of local/global optimisation solvers:
<code class="xref py py-class docutils literal"><span class="pre">pyNLOPT</span></code> class from <code class="xref py py-mod docutils literal"><span class="pre">daetools.solvers.nlopt</span></code> module.</li>
</ul>
<p>Solvers can be imported in the following way:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Import IPOPT NLP solver:</span>
<span class="kn">from</span> <span class="nn">daetools.solvers.ipopt</span> <span class="kn">import</span> <span class="n">pyIPOPT</span>
<span class="n">nlpsolver</span> <span class="o">=</span> <span class="n">pyIPOPT</span><span class="o">.</span><span class="n">daeIPOPT</span><span class="p">()</span>

<span class="c1"># Import BONMIN MINLP solver:</span>
<span class="kn">from</span> <span class="nn">daetools.solvers.bonmin</span> <span class="kn">import</span> <span class="n">pyBONMIN</span>
<span class="n">nlpsolver</span> <span class="o">=</span> <span class="n">pyBONMIN</span><span class="o">.</span><span class="n">daeBONMIN</span><span class="p">()</span>

<span class="c1"># Import NLOPT set of optimisation solvers:</span>
<span class="kn">from</span> <span class="nn">daetools.solvers.nlopt</span> <span class="kn">import</span> <span class="n">pyNLOPT</span>
<span class="n">nlpsolver</span> <span class="o">=</span> <span class="n">pyNLOPT</span><span class="o">.</span><span class="n">daeNLOPT</span><span class="p">(</span><span class="n">algorithm</span><span class="p">)</span>
<span class="c1"># The algorithm argument can be one of:</span>
<span class="c1"># &#39;NLOPT_GN_DIRECT_L_RAND_NOSCAL&#39;,&#39;NLOPT_GN_ORIG_DIRECT&#39;,&#39;NLOPT_GN_ORIG_DIRECT_L&#39;,&#39;NLOPT_GD_STOGO&#39;,&#39;NLOPT_GD_STOGO_RAND&#39;,</span>
<span class="c1"># &#39;NLOPT_LD_LBFGS_NOCEDAL&#39;,&#39;NLOPT_LD_LBFGS&#39;,&#39;NLOPT_LN_PRAXIS&#39;,&#39;NLOPT_LD_VAR1&#39;,&#39;NLOPT_LD_VAR2&#39;,&#39;NLOPT_LD_TNEWTON&#39;,</span>
<span class="c1"># &#39;NLOPT_LD_TNEWTON_RESTART&#39;,&#39;NLOPT_LD_TNEWTON_PRECOND&#39;,&#39;NLOPT_LD_TNEWTON_PRECOND_RESTART&#39;,&#39;NLOPT_GN_CRS2_LM&#39;,</span>
<span class="c1"># &#39;NLOPT_GN_MLSL&#39;,&#39;NLOPT_GD_MLSL&#39;,&#39;NLOPT_GN_MLSL_LDS&#39;,&#39;NLOPT_GD_MLSL_LDS&#39;,&#39;NLOPT_LD_MMA&#39;,&#39;NLOPT_LN_COBYLA&#39;,</span>
<span class="c1"># &#39;NLOPT_LN_NEWUOA&#39;,&#39;NLOPT_LN_NEWUOA_BOUND&#39;,&#39;NLOPT_LN_NELDERMEAD&#39;,&#39;NLOPT_LN_SBPLX&#39;,&#39;NLOPT_LN_AUGLAG&#39;,&#39;NLOPT_LD_AUGLAG&#39;,</span>
<span class="c1"># &#39;NLOPT_LN_AUGLAG_EQ&#39;,&#39;NLOPT_LD_AUGLAG_EQ&#39;,&#39;NLOPT_LN_BOBYQA&#39;,&#39;NLOPT_GN_ISRES&#39;,</span>
<span class="c1"># &#39;NLOPT_AUGLAG&#39;,&#39;NLOPT_AUGLAG_EQ&#39;,&#39;NLOPT_G_MLSL&#39;,&#39;NLOPT_G_MLSL_LDS&#39;,&#39;NLOPT_LD_SLSQP&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="running-an-optimisation">
<h3>6.16.3. Running an optimisation<a class="headerlink" href="#running-an-optimisation" title="Permalink to this headline">¶</a></h3>
<p>Optimisations are run in a very similar fashion as simulations. The only additional information required
are the <a class="reference internal" href="activity.html#pyActivity.daeOptimization" title="pyActivity.daeOptimization"><code class="xref py py-class docutils literal"><span class="pre">daeOptimization</span></code></a> and the NLP/MINLP solver objects (depending on the problem type):</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="c1"># Create Log, NLPSolver, DAESolver, DataReporter, Simulation and Optimization objects</span>
<span class="n">log</span>          <span class="o">=</span> <span class="n">daePythonStdOutLog</span><span class="p">()</span>
<span class="n">daesolver</span>    <span class="o">=</span> <span class="n">daeIDAS</span><span class="p">()</span>
<span class="n">nlpsolver</span>    <span class="o">=</span> <span class="n">daeIPOPT</span><span class="p">()</span>
<span class="n">datareporter</span> <span class="o">=</span> <span class="n">daeTCPIPDataReporter</span><span class="p">()</span>
<span class="n">simulation</span>   <span class="o">=</span> <span class="n">mySimulation</span><span class="p">()</span>
<span class="n">optimization</span> <span class="o">=</span> <span class="n">daeOptimization</span><span class="p">()</span>

<span class="c1"># Enable reporting of all variables</span>
<span class="n">simulation</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">SetReportingOn</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># Set the time horizon and the reporting interval</span>
<span class="n">simulation</span><span class="o">.</span><span class="n">ReportingInterval</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">simulation</span><span class="o">.</span><span class="n">TimeHorizon</span> <span class="o">=</span> <span class="o">...</span>

<span class="c1"># Connect data reporter</span>
<span class="n">simName</span> <span class="o">=</span> <span class="n">simulation</span><span class="o">.</span><span class="n">m</span><span class="o">.</span><span class="n">Name</span> <span class="o">+</span> <span class="n">strftime</span><span class="p">(</span><span class="s2">&quot; [m.%Y %H:%M:%S]&quot;</span><span class="p">,</span> <span class="n">localtime</span><span class="p">())</span>
<span class="k">if</span><span class="p">(</span><span class="n">datareporter</span><span class="o">.</span><span class="n">Connect</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">simName</span><span class="p">)</span> <span class="o">==</span> <span class="bp">False</span><span class="p">):</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>

<span class="c1"># Initialise the optimisation</span>
<span class="n">optimization</span><span class="o">.</span><span class="n">Initialize</span><span class="p">(</span><span class="n">simulation</span><span class="p">,</span> <span class="n">nlpsolver</span><span class="p">,</span> <span class="n">daesolver</span><span class="p">,</span> <span class="n">datareporter</span><span class="p">,</span> <span class="n">log</span><span class="p">)</span>

<span class="c1"># Run</span>
<span class="n">optimization</span><span class="o">.</span><span class="n">Run</span><span class="p">()</span>

<span class="c1"># Clean up</span>
<span class="n">optimization</span><span class="o">.</span><span class="n">Finalize</span><span class="p">()</span>
</pre></div>
</div>
<p>Optimisations can also be executed in a simple way using the static daeActivity.optimize function.
The function uses the default objects for all missing data:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">simulation</span> <span class="o">=</span> <span class="n">simTutorial</span><span class="p">()</span>
    <span class="n">nlpsolver</span>  <span class="o">=</span> <span class="n">pyIPOPT</span><span class="o">.</span><span class="n">daeIPOPT</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">daeActivity</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">simulation</span><span class="p">,</span> <span class="n">reportingInterval</span>       <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                                            <span class="n">timeHorizon</span>             <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                                            <span class="n">nlpsolver</span>               <span class="o">=</span> <span class="n">nlpsolver</span><span class="p">,</span>
                                            <span class="n">nlpsolver_setoptions_fn</span> <span class="o">=</span> <span class="n">setOptions</span><span class="p">,</span>
                                            <span class="n">reportSensitivities</span>     <span class="o">=</span> <span class="bp">True</span><span class="p">,</span>
                                            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="optimisation" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[7]</a></td><td><a class="reference external" href="https://en.wikipedia.org/wiki/Mathematical_optimization">Mathematical optimization</a></td></tr>
</tbody>
</table>
</div>
</div>
</div>


    </div>
      
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="_sources/pyDAE_user_guide.rst.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; Copyright 2008-2019, Dragan Nikolic.<br/>
      Last updated on Mar 29, 2019.<br/>
    </p>
  </div>
</footer>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-52277546-1', 'daetools.com');
  ga('send', 'pageview');
</script>


  </body>
</html>