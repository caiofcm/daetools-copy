<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>2. Programming Paradigms &#8212; DAE Tools 1.9.0 documentation</title>
    
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootswatch-3.3.6/readable/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="_static/bootstrap-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.9.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="_static/bootstrap-3.3.6/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="_static/[d][a][e].ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="3. Architecture" href="architecture.html" />
    <link rel="prev" title="1. Introduction" href="introduction.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body role="document">

  <div id="navbar" class="navbar navbar-inverse navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="index.html"><span><img src="_static/[d][a][e]_Tools_project.png"></span>
          DAE Tools</a>
        <span class="navbar-text navbar-version pull-left"><b>1.9.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="/">Home</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">1. Introduction</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">2. Programming Paradigms</a></li>
<li class="toctree-l1"><a class="reference internal" href="architecture.html">3. Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_daetools.html">4. Getting DAE Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">5. Getting Started with DAE Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyDAE_user_guide.html">6. User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyDAE_api_ref.html">7. API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials.html">Tutorials</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">2. Programming Paradigms</a><ul>
<li><a class="reference internal" href="#the-hybrid-approach">2.1. The Hybrid approach</a></li>
<li><a class="reference internal" href="#the-equation-oriented-approach">2.2. The Equation-Oriented approach</a></li>
<li><a class="reference internal" href="#the-object-oriented-approach">2.3. The Object-Oriented approach</a></li>
<li><a class="reference internal" href="#programming-language">2.4. Programming language</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <div class="section" id="programming-paradigms">
<h1>2. Programming Paradigms<a class="headerlink" href="#programming-paradigms" title="Permalink to this headline">¶</a></h1>
<div class="section" id="the-hybrid-approach">
<span id="hybrid-approach"></span><h2>2.1. The Hybrid approach<a class="headerlink" href="#the-hybrid-approach" title="Permalink to this headline">¶</a></h2>
<p>In general, two main approaches to mathematical modelling currently exist:
(a) use of modelling languages, either domain specific or multi-domain such as Modelica, Ascend,
gPROMS, GAMS, Dymola, APMonitor, and
(b) use of general-purpose programming languages, either lower level third-generation languages
such as C, C++ and Fortran (i.e. PETSc and SUNDIALS),
or higher level fourth-generation languages such as Python (i.e. Assimulo) and
multi-paradigm numerical languages: Matlab, Mathematica, Maple, Scilab, and GNU Octave.
Domain Specific Languages (DSL) are a special-purpose programming or specification languages
dedicated to a particular problem domain and directly support the key concepts necessary to describe the underlying
problems. They are created specifically to solve problems in a particular domain and usually not intended to be able to
solve problems outside it (although that may be technically possible in some cases). More versatile, multi-domain
modelling languages (such as Modelica or gPROMS) are capable of solving problems in different application domains.
Despite their versatility, modelling languages commonly lack or have a limited access to the operating system,
third-party numerical libraries and other capabilities that characterise full-featured programming languages, scripting
or otherwise.
In contrast, general-purpose languages are created to solve problems in a wide variety of application
domains, do not support concepts from any domain, and have a direct access to the operating system, low-level
functions and third-party libraries.</p>
<p><strong>DAE Tools</strong> approach is a type of a hybrid approach:</p>
<ul class="simple">
<li>it is implemented using the general-purpose programming languages such as C++ and Python</li>
</ul>
<p>but</p>
<ul class="simple">
<li>provides the Application Programming Interface (API) that resembles a syntax of modelling languages as much as possible</li>
</ul>
<p>and</p>
<ul class="simple">
<li>takes advantage of of the higher level general purpose languages to offer an access to the operating system,
low-level functions and large number of numerical libraries to solve various numerical problems
(i.e. calculating derivatives and sensitivities, solving linear and DAE systems and optimisation problems)</li>
</ul>
<p>API comparison between <a class="reference external" href="http://www.modelica.org">Modelica</a>, <a class="reference external" href="http://www.psenterprise.com/gproms">gPROMS</a>
and <strong>DAE Tools</strong> for a very simple dynamical model (basically a tank with a liquid inside, an inlet and
an outlet flow where the outlet flowrate depends on the liquid level in the tank):</p>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="31%" />
<col width="35%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="_images/modelica_model.png"><img alt="modelica_model" src="_images/modelica_model.png" style="width: 200pt;" /></a></td>
<td><a class="reference internal" href="_images/gPROMS_model.png"><img alt="gPROMS_model" src="_images/gPROMS_model.png" style="width: 200pt;" /></a></td>
<td><a class="reference internal" href="_images/daetools_model.png"><img alt="daetools_model" src="_images/daetools_model.png" style="width: 320pt;" /></a></td>
</tr>
<tr class="row-even"><td><strong>a) Modelica</strong></td>
<td><strong>b) gPROMS</strong></td>
<td><strong>c) DAE Tools</strong></td>
</tr>
</tbody>
</table>
<p><strong>DAE Tools</strong> provide the low-level modelling concepts such as parameters, variables, equations, ports, models,
state transition networks, discrete events etc. so that the key concepts from new application domains
can be added on top of those low level concepts. For instance, the key modelling concepts from the
simulator-independent xml-based domain specific language for modelling of biological neural
networks <a class="reference external" href="http://software.incf.org/software/nineml">NineML</a> such as neurones, synapses, connectivity
patterns, populations of neurones, projections etc. are based on <strong>DAE Tools</strong> low-level concepts.</p>
<p>Side-by-side comparison between the DSL approach and the <strong>DAE Tools</strong> hybrid approach:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>DSL Approach</strong></th>
<th class="head"><strong>DAE Tools Approach</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Domain-specific languages allow solutions to be expressed in the idiom and at the level of abstraction
of the problem domain (direct support for all modelling concepts by the language syntax)</td>
<td>Modelling concepts cannot be expressed directly in the programming language and have to be emulated in
the API or in some other way</td>
</tr>
<tr class="row-odd"><td>Clean, concise, ellegant and natural way of building model descriptions: the code can be self documenting</td>
<td>The support for modelling concepts is much more verbose and less elegant; however, DAE Tools can generate
XML+MathML based model reports that can be either rendered in XHTML format using XSLT transformations
(representing the code documentation) or used as an XML-based model exchange language.</td>
</tr>
<tr class="row-even"><td>Domain-specific languages could enhance quality, productivity, reliability, maintainability and portability</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>DSLs could be and often are simulator independent making a model exchange easier</td>
<td>Programming language dependent; however, a large number of scientific software libraries exposes its
functionality to Python via Python wrappers</td>
</tr>
<tr class="row-even"><td>Cost of designing, implementing, and maintaining a domain-specific language as well as the tools required
to develop with it (IDE): a compiler/lexical parser/interpreter must be developed with all burden that comes
with it (such as error handling, grammar ambiguities, hidden bugs etc)</td>
<td>A compiler/lexical parser/interpreter is an integral part of the programming language (c++, Python) with a
robust error handling, universal grammar and massively tested</td>
</tr>
<tr class="row-odd"><td>Cost of learning a new language vs. its limited applicability: users are required to master a new language
(yet another language grammar)</td>
<td>No learning of a new language required (everything done in a favourite programming language)</td>
</tr>
<tr class="row-even"><td>Increased difficulty of integrating the DSL with other components: calling external functions/libraries and
interaction with other software is limited by the existence of wrappers around a simulator engine
(for instance some scripting languages like Python or javascript)</td>
<td>Calling external functions/libraries and interaction with other software is a built-in feature</td>
</tr>
<tr class="row-odd"><td>Models usually cannot be created in the runtime/on the fly (or at least not easily) and cannot be modified
in the runtime</td>
<td>Models can be created in the runtime/on the fly and easily modified in the runtime</td>
</tr>
<tr class="row-even"><td>Setting up a simulation (ie. the values of parameters values, initial conditions, initially active states)
is embedded in the language and it is typically difficult to do it on the fly or to obtain the values from
some other software (for example to chain several software calls where outputs of previous calls represent
inputs to the subsequent ones)</td>
<td>Setting up a simulation is done programmaticaly and the initial values can be obtained from some other software
(chaining several software calls is easy since a large number of libraries make Python wrappers available)</td>
</tr>
<tr class="row-odd"><td>Schedules (operating procedures) are not flexible; manipulation of model parameters, variables, equations,
simulation results etc is limited to only those operations provided by the language</td>
<td>Schedules are completely flexible (within the limits of a programming language itself) and a
manipulation of model parameters, variables, equations, simulation results etc can be done in any way which
a user considers suitable for her problem</td>
</tr>
<tr class="row-even"><td>Only the type of results provided by the language/simulator is available; custom processing is usually not
possible or if a simulator does provide a way to build extensions it is limited to the functionality made
available to them</td>
<td>The results processing can be done in any way which a user considers suitable(again within the limits of a
programming language itself)</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="the-equation-oriented-approach">
<span id="equation-oriented-approach"></span><h2>2.2. The Equation-Oriented approach<a class="headerlink" href="#the-equation-oriented-approach" title="Permalink to this headline">¶</a></h2>
<p>In general, three approaches to process modelling exist (<a class="footnote-reference" href="#morton2003" id="id1">[1]</a>):</p>
<ul class="simple">
<li>Sequential Modular (<strong>SeqM</strong>) approach</li>
<li>Simultaneous Modular (<strong>SimM</strong>) approach</li>
<li>Equation-Oriented (<strong>EO</strong>) approach</li>
</ul>
<p>The pros &amp; cons of the first two approaches are extensively studied in the literature. Under the <strong>EO</strong> approach all
equations and variables which constitute the model representing the process are gathered together. The equations are solved
simultaneously using a suitable mathematical algorithm (Morton, 2003 <a class="footnote-reference" href="#morton2003" id="id2">[1]</a>). Equation-oriented simulation requires
simultaneous solution of a set of differential algebraic equations (<strong>DAE</strong>) which itself requires a solution of a set of
nonlinear algebraic equations (<strong>NLAE</strong>) and linear algebraic equations (<strong>LAE</strong>). The Newton&#8217;s method or some variant of it
is almost always used to solve problems described by NLAEs. A brief history of Equation-Oriented solvers and comparison of
<strong>SeqM</strong> and <strong>EO</strong> approaches as well as descriptions of the simultaneous modular and equation-oriented methods can be found
in Morton, 2003 (<a class="footnote-reference" href="#morton2003" id="id3">[1]</a>). Also a good overview of the equation-oriented approach and its application in
<a class="reference external" href="http://www.psenterprise.com/gproms">gPROMS</a> is given by Barton &amp; Pantelides (<a class="footnote-reference" href="#pantelides1" id="id5">[2]</a> <a class="footnote-reference" href="#pantelides2" id="id6">[3]</a> <a class="footnote-reference" href="#pantelides3" id="id7">[4]</a>).</p>
<p><strong>DAE Tools</strong> apply the Equation-Oriented approach to process modelling.
The following types of processes can be modelled:</p>
<ul class="simple">
<li>Lumped and distributed</li>
<li>Steady-state and dynamic</li>
</ul>
<p>Problems can be formulated as linear, non-linear, and (partial) differential algebraic systems (of index 1).
The most common problems are initial value problems of implicit form. Equations can be ordinary or discontinuous,
where discontinuities are automatically handled by the framework. A good overview of discontinuous equations and
a procedure for location of equation discontinuities is given by Park &amp; Barton (<a class="footnote-reference" href="#parkbarton" id="id8">[5]</a>)
and in <a class="reference external" href="https://computation.llnl.gov/casc/sundials/documentation/ida_guide/node3.html#SECTION00330000000000000000documentation">Sundials IDA</a>
(used in DAE Tools).</p>
<p>The main characteristics of the Equation-oriented (acausal) approach:</p>
<ul>
<li><p class="first">Equations are given in an implicit form (as a residual):</p>
<div class="math">
\[F(\dot {x}, x, y, p) = 0\]</div>
<p>where <span class="math">\(x\)</span> and <span class="math">\(\dot {x}\)</span> are state variables and their derivatives,
<span class="math">\(y\)</span> are degrees of freedom and <span class="math">\(p\)</span> are parameters.</p>
</li>
<li><p class="first">Input-Output causality is not fixed</p>
<p>The benefits are:</p>
<ul>
<li><p class="first">Increased model re-use</p>
</li>
<li><p class="first">Support for different simulation scenarios (based on a single model) by specifying
different degrees of freedom. For instance, an equation given in the following form:</p>
<div class="math">
\[x_1 + x_2 + x_3 = 0\]</div>
<p>can be used to determine either <cite>x1</cite>, <cite>x2</cite> or <cite>x3</cite> depending on what combination
of variables is known:</p>
<div class="math">
\[ \begin{align}\begin{aligned}x_1 = -x_2 - x_3 \newline\\\vee \newline\\x_2 = -x_1 - x_3 \newline\\\vee \newline\\x_3 = -x_1 - x_2\end{aligned}\end{align} \]</div>
</li>
</ul>
</li>
</ul>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="morton2003" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>, <a class="fn-backref" href="#id3">3</a>)</em> Morton, W., Equation-Oriented Simulation and Optimization. <em>Proc. Indian Natl. Sci. Acad.</em> 2003, 317-357.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="pantelides1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[2]</a></td><td>Pantelides, C. C., and P. I. Barton, Equation-oriented dynamic simulation current status and future perspectives, <em>Computers &amp; Chemical Engineering</em>, vol. 17, no. Supplement 1, pp. 263 - 285, 1993.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="pantelides2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[3]</a></td><td>Barton, P. I., and C. C. Pantelides, gPROMS - a Combined Discrete/Continuous Modelling Environment for Chemical Processing Systems, <em>Simulation Series</em>, vol. 25, no. 3, pp. 25-34, 1993.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="pantelides3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[4]</a></td><td>Barton, P. I., and C. C. Pantelides, Modeling of combined discrete/continuous processes&#8221;, <em>AIChE Journal</em>, vol. 40, pp. 966-979, 1994.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="parkbarton" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[5]</a></td><td>Park, T., and P. I. Barton, State event location in differential-algebraic models&#8221;, <em>ACM Transactions on Modeling and Computer Simulation</em>, vol. 6, no. 2, New York, NY, USA, ACM, pp. 137-165, 1996.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="the-object-oriented-approach">
<span id="object-oriented-approach"></span><h2>2.3. The Object-Oriented approach<a class="headerlink" href="#the-object-oriented-approach" title="Permalink to this headline">¶</a></h2>
<p>The Object-Oriented approach to process modelling is adopted in <strong>DAE Tools</strong>.
The main characteristics of such an approach are:</p>
<ul class="simple">
<li>Everything is an object</li>
<li>Models are classes derived from the base daeModel class</li>
<li>Basically all OO concepts supported by the target language (c++, Python) are allowed,
except few exceptions<ul>
<li>Multiple inheritance is supported</li>
<li>Models can be parametrized (using templates in c++)</li>
<li>Derived classes always inherit all declared parameters, variables, equations etc. (polymorphism achieved through virtual functions where the declaration takes place)</li>
<li>All parameters, variables, equations etc. remain public</li>
</ul>
</li>
<li>Hierarchical model decomposition</li>
</ul>
</div>
<div class="section" id="programming-language">
<span id="python-programming-language"></span><h2>2.4. Programming language<a class="headerlink" href="#programming-language" title="Permalink to this headline">¶</a></h2>
<p><strong>DAE Tools</strong> core libraries are written in standard c++. However, <a class="reference external" href="http://www.python.org">Python</a> programming language is
used as the main modelling language.</p>
<p>An excellent overview of Python is given by Hoyt Koepke (University of Washington):
<a class="reference external" href="http://www.stat.washington.edu/~hoytak/blog/whypython.html">10 Reasons Python Rocks for Research</a>.</p>
<p>The main reason for use of Python is (as the authors say):
&#8220;<em>Python is an easy to learn, powerful programming language. It has efficient high-level data structures and a simple
but effective approach to object-oriented programming. Python&#8217;s elegant syntax and dynamic typing, together with its
interpreted nature, make it an ideal language for scripting and rapid application development in many areas on
most platforms</em>&#8221; <a class="reference external" href="http://docs.python.org/tutorial">link</a>.</p>
<p>And: <em>&#8220;Often, programmers fall in love with Python because of the increased productivity it provides. Since there is no
compilation step, the edit-test-debug cycle is incredibly fast</em>&#8221; <a class="reference external" href="http://www.python.org/doc/essays/blurb">link</a>. Also, please
have a look on <a class="reference external" href="http://www.python.org/doc/essays/comparisons">a comparison to the other languages</a>. Based on the information
available online, and according to the personal experience, the python programs are much shorter and take an order of magnitude
less time to develop it. Initially I developed daePlotter module in c++; it took me about one month of part time coding. But,
then I moved to python: reimplementing it in PyQt took me just two days (with several new features added), while the code size
shrank from 24 cpp modules to four python modules only!</p>
<p>&#8220;<em>Where Python code is typically 3-5 times shorter than equivalent Java code, it is often 5-10 times shorter than equivalent
C++ code! Anecdotal evidence suggests that one Python programmer can finish in two months what two C++ programmers can&#8217;t
complete in a year. Python shines as a glue language, used to combine components written in C++</em>&#8221;
<a class="reference external" href="http://www.python.org/doc/essays/comparisons">link</a>.</p>
<p>Obviously, not everything can be developed in python; a heavy c++ artillery is still necessary for highly complex projects.</p>
</div>
</div>


    </div>
      
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="_sources/paradigms.rst.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; Copyright 2008-2019, Dragan Nikolic.<br/>
      Last updated on Mar 29, 2019.<br/>
    </p>
  </div>
</footer>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-52277546-1', 'daetools.com');
  ga('send', 'pageview');
</script>


  </body>
</html>